---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(janitor)
library(tidyverse)
library(zoo)
library(readABF)
library(here)

theme_set(ggplot2::theme_minimal())

# Really just a wrapper for loadABF()
readABF_as_matrix <- function(
  path = "",
  channels = c("IN 4", "IN 9")){

  trace <- readABF::readABF(file = path)

  start.time <- trace$header$recTime[1]
  end.time <- trace$header$recTime[2]
  obs <- nrow(trace$data[[1]])

  temp <- trace$data[[1]][, (trace$channelNames %in% channels)]
  temp <- as.matrix(temp)

  colnames(temp) <- trace$channelNames[trace$channelNames %in% channels]
  temp <- cbind(temp, Time = seq(from = start.time,
                                 to = end.time,
                                 length.out = obs))

  return(temp)
}
```

```{r}
# Found in "C:/Users/Daniel/Documents/Trace_Holding"
# "190808a" "190903" "190904" "190905" "190906" "190915" "190917" "190918" "190830" "190907"

# Missing:
# "190924"  "190924a" "190926" 
# "190927a" "190930"  "191001"  "190927"  "191004"  
# "190930a"


# Sizes of the files we want:
# fi -- 46855 KB
  # 190808a_0049
  # 4 6 7 9 11 12 14

# -nA -- 14657 KB
# tevc -- 5633 KB
# epsp -- 3853 KB
  # 190918_0020 
  # 4 7 9 12 14

```

Index the traces in the trace dir by file size.
```{r}
traces_dir <- "C:/Users/Daniel/Documents/Trace_Holding"


files_df <- data.frame(files = list.files(traces_dir),
                       bytes = unlist(map(list.files(traces_dir), 
                                          function(abf){ file.info(paste0(traces_dir, "/",abf))$size })))

#              files    bytes
# 1 190808a_0000.abf 15006208 <- gap free recording.
# 2 190808a_0001.abf 15006208
# 3 190808a_0002.abf 15006208

files_df$Experiment <- unlist(transpose(str_split(files_df$files, pattern = "_"))[[1]])

files_df$kb <- files_df$bytes/1000

files_df$Type <- ""
files_df[files_df$kb > 44000 &
           files_df$kb < 48000, "Type"] <- "fi"

files_df[files_df$kb > 3000 &
           files_df$kb < 4500, "Type"] <- "epsp"

Baseline = c(
    "190924",
    "190924a",
    "190926",
    "190927",
    "190927a",
    "190930",
    "190930a")
  Compensated = c(
    "190808a", 
    "190830", 
    "190904", 
    "191001", 
    "191004")
  Delayed = c(
    "190903",
    "190905", 
    "190906", 
    "190907", 
    "190915", 
    "190917", 
    "190918")

file_groups <- data.frame(
  Experiment = c(Baseline, Compensated, Delayed),
  Group = rep(c("Baseline", "Compensated", "Delayed"), times = c(length(Baseline), length(Compensated), length(Delayed)))
)




full_join(file_groups, files_df) %>% filter(Type %in% c("fi", "epsp")) %>% group_by(Group, Experiment) %>% tally()


full_join(file_groups, files_df) %>% filter(is.na(files)) %>% group_by(Group, Experiment) %>% tally()




```

finding missing files in shared drive w/o microsoft search
```{r}
# start_loc <- "S:/Data_Daniel"
# 
# # list.files(start_loc)
# # list.files(start_loc, include.dirs = T)
# # 
# # list.dirs(start_loc)
# # 
# # list.dirs("C:/Users/Daniel/Desktop/")
# # 
# # tic <- Sys.time()
# # all_abfs <- list.files("S:/Data_Daniel", "*.abf", recursive = T)
# # toc <- Sys.time()
# # print(toc - tic)
# # 
# # save(all_abfs, file = "C:/Users/Daniel/Desktop/all_abfs")
# # 
# # save(all_abfs, file = "C:/Users/Daniel/Desktop/all_abfs2")
# # write.csv(as.data.frame(all_abfs), file = "C:/Users/Daniel/Desktop/all_abfs.csv")
# 
# all_abfs_on_shared_drive <- read.csv("C:/Users/Daniel/Desktop/all_abfs.csv")
# 
# abf_names <- str_extract_all(all_abfs_on_shared_drive$all_abfs, "[[^/]]*[[:punct:]]abf$") 
# 
# all_abfs_on_shared_drive$abf_names <- abf_names
# 
# times_matched <- unlist(map(seq(1, nrow(all_abfs_on_shared_drive)), function(i){
#   # if it matches at least once the sum will be >0. It should match at most once.
#   times.matched <- sum(unlist(map(file_groups$Experiment, function(prefix){
#     str_detect(all_abfs_on_shared_drive$abf_names[[i]], paste0(as.character(prefix), "_")) # adding a terminal _ to the search string will prevent 000000a from matching to both 000000 and itself. 
#   })))  
#   
#   return(times.matched)
# }))
# 
# all_abfs_on_shared_drive$times_matched <- times_matched
# 
# # Looks like it's working as expected 
# if (max(times_matched) > 1){
#   all_abfs_on_shared_drive[all_abfs_on_shared_drive$times_matched == max(times_matched), ]
# }
# 
# # matches
# all_abfs_match <- all_abfs_on_shared_drive[all_abfs_on_shared_drive$times_matched == 1, ]
# 
# all_abfs_match$size  <- NA
# all_abfs_match$mtime <- as.POSIXct(NA)
# all_abfs_match$ctime <- as.POSIXct(NA)
# all_abfs_match$atime <- as.POSIXct(NA)
# 
# for (i in seq(1, nrow(all_abfs_match))){
#   current_info <- file.info(paste(start_loc, all_abfs_match[i, "all_abfs"], sep = "/") )  
#   
#   all_abfs_match[i, "size"]  <- current_info$size
#   all_abfs_match[i, "mtime"] <- current_info$mtime # file modification
#   all_abfs_match[i, "ctime"] <- current_info$ctime # last status change
#   all_abfs_match[i, "atime"] <- current_info$atime # last access time
# }
# 
# 
# all_abfs_match$abf_names <- all_abfs_match$abf_names %>% unlist()
# 
# 
# # find duplicated abfs
# dupe_abfs <- all_abfs_match %>% 
#   select(abf_names) %>% 
#   group_by(abf_names) %>% 
#   tally() %>% 
#   filter(n > 1)
# 
# all_abfs_match$keep <- F
# # Keep all non duplicates
# all_abfs_match[!(all_abfs_match$abf_names %in% as.character(dupe_abfs$abf_names)), "keep"] <- T
# 
# for (i in seq(1, nrow(dupe_abfs))){
#   # if same size, keep oldest
#   if (length( unique( all_abfs_match[all_abfs_match$abf_names == as.character(dupe_abfs[i, "abf_names"]), "size"] ) ) == 1){
#     # unless they're the same, then keep the first.
#     if (length( unique(all_abfs_match[all_abfs_match$abf_names == as.character(dupe_abfs[i, "abf_names"]), "mtime"]) ) == 1){
#       all_abfs_match[all_abfs_match$abf_names == as.character(dupe_abfs[i, "abf_names"]), "keep"][1] <- T
#     } else {
#       warning(paste("Dupe", as.character(i), "has multiple times! Additional logic needed!"))
#       #TODO
#     }
#   } else {
#       warning(paste("Dupe", as.character(i), "has unequal file sizes! Additional logic needed!"))
#   }
# }
# 
# 
# target_abfs <- all_abfs_match[all_abfs_match$keep == T & all_abfs_match$size < 13000000, ]
# # install.packages("gdata")
# target_abfs$size %>% sum() %>% gdata::humanReadable()
# 
# 
# local_abfs <- list.files("C:/Users/Daniel/Documents/Trace_Holding/", pattern = ".abf")
# target_abfs <- target_abfs[!(target_abfs$abf_names %in% local_abfs), ] 
# 
# 
# # Copy
# for (i in seq(1, nrow(target_abfs))){
#   temp_path <- paste(start_loc, as.character(target_abfs[i, "all_abfs"]), sep = "/")
#   if (file.exists(temp_path)){
#     file.copy(from = temp_path,
#               to = "C:/Users/Daniel/Documents/Trace_Holding/")
#   } else {
#     warning(paste("Item", as.character(i), "does not exist!"))
#   }
# }

```

## Working through and example -- 
```{r Custom Functions}
# now works for multiple sweeps
readABF_as_matrix2 <- function(
  path = "",
  channels = c("IN 4", "IN 9"), # "all" is also acceptable
  relative.time = T
){
  
  trace <- readABF::readABF(file = path)
  
  start.time <- trace$header$recTime[1]
  end.time <- trace$header$recTime[2]
  
  temp_list <- map(seq(1, length(trace$data)), function(i){
    # obs <- nrow(trace$data[[i]])
    
    if (mean(channels %in% trace$channelNames) == 1){
      temp <- trace$data[[i]][, (trace$channelNames %in% channels)]
      temp <- cbind(temp, rep(i, nrow(temp)))
      temp <- as.matrix(temp)
      colnames(temp) <- c(trace$channelNames[trace$channelNames %in% channels], "Sweep")
      return(temp)
    } else if (channels == "all"){
      temp <- trace$data[[i]]
      temp <- cbind(temp, rep(i, nrow(temp)))
      temp <- as.matrix(temp)
      colnames(temp) <- c(trace$channelNames, "Sweep")
      
      return(temp)
    } else {
      current_options <- paste(as.array(trace$channelNames), sep =", ")
      warning(paste("Provided Channels do not exist. \nPlease select 'all' or select from the following existing channels:\n"))
      warning(current_options)
      
      temp <- NA
      return(temp)
    }
    
  })
  
  if(sum(is.na(temp_list)) > 0){
    warning("Exiting due to missing Sweep or improper channel selection.")
    return(NULL)
  } else {
    temp <- do.call(rbind, temp_list)
    
  }
  
  if (relative.time == F){
    temp <- cbind(temp, Time = seq(from = start.time,
                                   to = end.time,
                                   length.out = nrow(temp)))
    return(temp)
  } else if (relative.time == T){
    temp <- cbind(temp, Time = seq(from = 0,
                                   to = end.time-start.time,
                                   length.out = nrow(temp)))
    return(temp)
  } else {
    warning("Exiting due to 'relative.time' being neither 'T' or 'F'.")
    return(NULL)
  }
}

place_params_for_predict_voltage_trace <- function(tau = 10.0,
                                                   Rin = 1.0){
  write.table(tau, file = "./temp/measured_tau.txt", sep = "", row.names = F, col.names = F)
  write.table(Rin, file = "./temp/measured_Rin.txt", sep = "", row.names = F, col.names = F)
}

place_data_for_predict_voltage_trace <- function(input.df = temp[temp$sweep==1, ],
                                                 Time.ch = "Time",
                                                 Inj.ch = "In7",
                                                 ...){
  input.df <- input.df[, c(Time.ch, Inj.ch)]
  names(input.df) <- c("Time", "Inj")
  write.csv(input.df,
            file = "./temp/current_inj.csv",
            row.names = F
  )
}

#TODO the second half of the recording has no current injection!
#ggplot()+geom_path(data = predicted_response, aes(Time, predicted), color = "blue")

run_predict_voltage_trace.py <- function(){
  shell("conda activate base")
  shell("python ./Python/predict_voltage_trace.py")
}

retrieve_predicted_voltage <- function(){
  return(
    cbind(read.csv("./temp/time_steps.csv"), 
          read.csv("./temp/predicted_voltage.csv"))
    )
}



```



## Show traces we're working with
```{r}
# Cleaner
# "190903_0025.abf" # FI
# "190903_0023.abf" # epsp
# "190903_0021.abf" # gj na
# "190903_0020.abf" # gj tevc

file_list <- list(FI = "190903_0025.abf",
                  EPSP = "190903_0023.abf",
                  GJCC = "190903_0021.abf", 
                  GJVC = "190903_0020.abf")

trace_list <- map(seq_along(file_list), function(i){
  temp <- readABF_as_matrix2(path = paste0("C:/Users/Daniel/Documents/Trace_Holding/", file_list[[i]]),
                     channels = "all",
                     relative.time = T) %>%
    as.data.frame() %>% 
    janitor::clean_names(case = "upper_camel") %>% 
    mutate(Sweep = as.factor(Sweep)) %>% 
    group_by(Sweep) %>% 
    mutate(MinTime = min(Time, na.rm = T)) %>% 
    mutate(Time = Time - MinTime) %>% 
    select(-MinTime)
})

names(trace_list) <- c("FI", "EPSP", "GJCC", "GJVC")

## GJVC: get Ig, Ileak====
temp <- trace_list$GJVC
### Setup
i_leak <- temp[seq(1, nrow(temp), by = 1), ] %>%
  filter(Time > 0.75) %>%
  mutate(In4 = as.numeric(In4)) %>%
  mutate(In7 = as.numeric(In7))

i_leak <- i_leak %>% 
  mutate(Segment = ifelse(Time >= 0.8 & Time <= 1.0, "PreStep", 
                          ifelse(Time >= 1.2 & Time <= 1.25, "Step", 
                                 "NA" ))) %>% 
  group_by(Sweep, Segment) %>% 
  mutate(In4Mean = mean(In4, na.rm = T),
         In7Mean = mean(In7, na.rm = T),
         In9Mean = mean(In9, na.rm = T),
         In12Mean = mean(In12, na.rm = T))

### Ig 
i_leak[seq(1, nrow(i_leak), length.out = 1000), ] %>% 
  gather("key", "value", c("In4", "In9")) %>% 
  ggplot(aes(Time, value, color = Segment, group = Sweep))+
  geom_path()+
  facet_grid(.~key)

i_g <- i_leak %>% 
  select(Sweep, Segment, In4Mean, 
         #In7Mean, 
         # In9Mean, 
         In12Mean
         ) %>% 
  filter(Segment != "NA") %>% 
  distinct() %>% 
  pivot_wider(names_from = "Segment", 
              values_from = c("In4Mean", "In12Mean")) %>% 
  mutate(In4Mean_Step = In4Mean_Step - In4Mean_PreStep,
         In12Mean_Step = In12Mean_Step - In12Mean_PreStep) %>% 
  select(Sweep, In4Mean_Step, In12Mean_Step) %>%
  rename(In4Mean = In4Mean_Step, In12Mean = In12Mean_Step) %>% 
  filter(abs(In4Mean) >= 4) 

i_g %>% 
  ggplot(aes(In4Mean, In12Mean))+
  geom_smooth(method = lm)+
  geom_point()

In4_to_In9_Ig <- as.numeric(broom::tidy(lm(In12Mean ~ In4Mean, data = i_g))[2, "estimate"])


### Ileak
i_leak %>% 
  ggplot(aes(Time, In4, color = Segment, group = Sweep))+
  geom_path()

i_leak <- i_leak %>% 
  ungroup() %>%
  select(Sweep, Segment, In4Mean, In7Mean) %>% 
  filter(Segment != "NA") %>% 
  distinct() %>% 
  filter(abs(In4Mean + 60) > 3 )
  
fm <- lm(In4Mean ~ In7Mean, data = i_leak)

In4_R <- as.numeric(broom::tidy(fm)[2, "estimate"])





## GJCC: get R_C, C ====
temp <- trace_list$GJCC

temp_plt <- temp[seq(1, nrow(temp), by = 1), ] %>% 
  filter(Sweep == 4) %>%
  mutate(In4 = as.numeric(In4)) %>% 
  mutate(In7 = as.numeric(In7))

### test minpack.lm ####
# install.packages("minpack.lm")
library(minpack.lm)
temp_plt %>% 
  ggplot(aes(Time, In4, color = Sweep))+
  geom_vline(xintercept = 3.0775)+
  geom_vline(xintercept = 4.5775)+
  geom_path()+
  xlim(3, 5)
  

### Proof of principle 1 fit. ####
# https://stackoverflow.com/questions/26560849/exponential-regression-with-nls-in-r
# https://stats.stackexchange.com/questions/160552/why-is-nls-giving-me-singular-gradient-matrix-at-initial-parameter-estimates
#https://rpubs.com/mengxu/exponential-model

time_length <- 1.5
data_subset <- temp_plt[temp_plt$Time >= 3.0775 & temp_plt$Time <= 3.0772+time_length, ]



# data_offset_y <- min(data_subset$In4) - 10
# data_subset$In4 <- data_subset$In4 - data_offset_y

data_offset_x <- min(data_subset$Time)
data_subset$Time <- data_subset$Time - data_offset_x


### 1 term fit ####
fm <- nlsLM(
  In4 ~ a*exp(b*Time) + c, 
  data = data_subset, 
  start = list(a = 1, b = -0.01, c = 10)
  )


tidy_fm <- broom::tidy(fm)


temp <- data.frame(x = seq(0, 1.5, length.out = 100)) %>% 
  mutate(y1 = as.numeric(tidy_fm[1, "estimate"])*exp(as.numeric(tidy_fm[2, "estimate"]) * x) + as.numeric(tidy_fm[3, "estimate"])
         )


data_subset %>% 
  ggplot(aes(Time, In4))+
  geom_path(size = 2, color = "white")+
  geom_path(data = temp, aes(x = x, y = y1), size = 1, color = "yellow")+
  see::theme_blackboard()


# V(t) = Vmax*(1-e^(-t/tau)) # rise
# V(t) = Vmax*(e^(-t/tau)) # fall

Vmax = -123



Vmax = 10
tau = 2 # smaller == faster

nsteps = 100
testdf <- data.frame(Time = seq(0, 100, length.out = nsteps), 
                     Vmax = NA,
                     Vrest = -10,
                     Rin = 1,
                     Inj_nA = rep(c(0,0), each = nsteps/2),
                     V = 0)

testdf$Vmax = (testdf$Rin*testdf$Inj_nA)+testdf$Vrest

for (i in seq(2, nrow(testdf))){
  # at each step, is vmax > | < v(t-1)?
  if (testdf[i-1, "V"] < testdf[i, "Vmax"]){
    # if greater apply rise formula   
    # testdf[i, "V"] <- Vmax*(1-exp(-testdf[i, "Time"] / tau)) # rise
    testdf[i, "V"] <- testdf[i, "Vmax"]*(1-exp(-testdf[i, "Time"] / tau)) # rise
    
  } else if (testdf[i-1, "V"] > testdf[i, "Vmax"]){
    # if lesser  apply fall formula
    # testdf[i, "V"] <- Vmax*exp(-testdf[i, "Time"] / tau) # fall
    testdf[i, "V"] <- testdf[i, "Vmax"]*(-exp(-testdf[i, "Time"] / tau)) # fall
    
  } else {
    testdf[i, "V"] <- testdf[i, "Vmax"]
  }
  
  


}
testdf %>% 
  ggplot(aes(x = Time, y = V))+lemon::geom_pointline()




























testdf <- temp_plt[temp_plt$Time >= 2.0775 & temp_plt$Time <= 3.0772+time_length, ] %>% 
  ungroup() %>% 
  dplyr::select(Time, In7, In4) %>%
  mutate(In4_p = NA, 
         Fit = -50.8,
         In4_target = NA)




fit_time_array <- testdf[testdf$Time >= 3.0772 & testdf$Time <= 3.0772+time_length, "Time"]
fit_time_array <- fit_time_array - min(fit_time_array) # ensure we're applying it to the right time length
testdf[testdf$Time >= 3.0772 & testdf$Time <= 3.0772+time_length, "Fit"] <- as.numeric(tidy_fm[1, "estimate"])*exp(as.numeric(tidy_fm[2, "estimate"]) * fit_time_array) + as.numeric(tidy_fm[3, "estimate"])


In4_rest = -50.8
In4_Rin = (-123-In4_rest)/-6
rec_timestep <- testdf[2, "Time"] - testdf[1, "Time"]

testdf[1, "In4_p"] <- testdf[1, "In4"]


# as.numeric(tidy_fm[1, "estimate"])*exp(as.numeric(tidy_fm[2, "estimate"]) * rec_timestep) + as.numeric(testdf[i, "In7"])*In4_Rin

testdf$In4_target <- testdf$In7*In4_Rin + In4_rest
# testdf[i, "In4_target"] <- (In4_rest + (as.numeric(testdf[i, "In7"])*In4_Rin)) 

i=2
for (i in seq(2, nrow(testdf))){
  testdf[i, "In4_p"] <- as.numeric(tidy_fm[1, "estimate"])*exp(as.numeric(tidy_fm[2, "estimate"]) * rec_timestep) + as.numeric(testdf[i, "In4_target"]) + as.numeric(testdf[i-2, "In4_p"])  
}



testdf %>% 
  ggplot(aes(Time, In4))+
  geom_path(size = 2, color = "white")+
  geom_path(aes(y = Fit), size = 1, color = "yellow")+
  geom_path(aes(y = In4_target), size = 1, color = "orange")+
  geom_path(aes(y = In4_p), size = 1, color = "red")+
  see::theme_blackboard()



### redo with more complicated model ####
# fm <- nlsLM(
#   In4 ~ a*exp(b*Time) + c*exp(d*Time)+ e, 
#   data = data_subset, 
#   start = list(a = 1, b = -0.01, c = 1, d = -0.1, e = 10)
#   )
# 
# data_subset %>% 
#   ggplot(aes(Time, In4))+
#   geom_path()+
#   geom_path(data = data.frame(In4 = predict(fm, data_subset),
#                               Time = data_subset$Time), color = "red")
# 
# tidy_fm <- broom::tidy(fm)
# 
# 
# temp <- data.frame(x = seq(0, 1.5, length.out = 100)) %>% 
#   mutate(y1 = as.numeric(tidy_fm[1, "estimate"])*exp(as.numeric(tidy_fm[2, "estimate"]) * x),
#          y2 = as.numeric(tidy_fm[3, "estimate"])*exp(as.numeric(tidy_fm[4, "estimate"]) * x),
#          y3 = as.numeric(tidy_fm[1, "estimate"])*exp(as.numeric(tidy_fm[2, "estimate"]) * x) + as.numeric(tidy_fm[3, "estimate"])*exp(as.numeric(tidy_fm[4, "estimate"]) * x) + as.numeric(tidy_fm[5, "estimate"])
#          )
# 
# 
# data_subset %>% 
#   ggplot(aes(Time, In4))+
#   geom_path(size = 2, color = "white")+
#   geom_path(data = temp, aes(x = x, y = y1), size = 1, color = "yellow")+ # slower exponential term (tau0) is the membrane time constant
#   geom_path(data = temp, aes(x = x, y = y2), size = 1, color = "orange")+
#   geom_path(data = temp, aes(x = x, y = y3), size = 1, color = "red")+
#   see::theme_abyss()

### ####

# 
# temp <- data_subset %>% dplyr::select()
# temp
# 
# mutate(y1 = as.numeric(tidy_fm[1, "estimate"])*exp(as.numeric(tidy_fm[2, "estimate"]) * x) + as.numeric(tidy_fm[3, "estimate"])
#          )





In4_tau0 <- as.numeric(tidy_fm[2, "estimate"])
# fm <- nlsLM(
#   # In4 ~ a*exp(-b*In7)+c, 
#   In4 ~ a*exp(-b*In7)+c*exp(-d*In7)+e, 
#   data=data_subset, 
#   # start=list(a=1, b=1, c=50),  
#   start=list(a=1, b=1, c=1, d=1, e=50),  
#   algorithm = "LM",
#   control = nls.lm.control(maxiter = 1000))

In4_R
In4_tau0


In4_Rin = -123/-6

Inj_nA <- -6
v_rest = 83.5# -49.6


data_subset$In4_p <- NA
data_subset$In4_delta <- NA
data_subset <- data_subset[, c("In4_delta", "In4_p", "In4", "In7", "Time")]



data_subset[1, "In4_p"] <- data_subset[1, "In4"]
i=2

data_subset[i-1, "In4_p"]*exp(-1*((data_subset[i, "Time"] - data_subset[i-1, "Time"]) / (In4_tau0)))


data_subset %>% 
  ggplot(aes(Time, In4))+
  geom_path(size = 2, color = "white")+
  geom_path(aes(y = In4_p), size = 1, color = "yellow")+
  see::theme_abyss()



# Q = CV
# dQ/dt = C*(dV/dt)
# I_c (capacitive current)
# I_c = C*(dV/dt)

# delta_V (across resistor) = IR
# E is vRest
# V - E = IR
# I_R = current across resistor
# I_R = (V-E) / R

# I_c + I_R = 0

#R*C*(dv/dt) = E - V









# tau * V'(t) = V_Cl - V(t) + I_stim(t) / (Area * g_CL)
# tau == C_mem / g_Cl

# V_Cl == rest?

# cell of radius 10 μm
# Cm =1 μF/cm2
# gCl =0.3 mS/cm2
# subject to a 20 ms, 10 pA current injection


V_t = +10
V_rest = -68
I_stim = 0#.0001
max_time = 0.1
nsteps = 10

temp <- data.frame(Time = seq(0, max_time, length.out = nsteps),
           mV = NA)
temp[1, "mV"] <- V_t



for (i in 2:nrow(temp)){
  cell_area = (pi*10)^2 * (1/10000)
  v_prime =  (V_rest - V_t + (I_stim/(cell_area*0.3)) ) / (1/0.3) # div by tau
  temp[i, "mV"] <- v_prime
  V_t <- v_prime+V_t
}



cumsum(x = temp$mV)

temp %>% 
  ggplot(aes(x = Time, y = mV))+
  geom_path()






# ### what is the effect of the length of time used? ####

# 
# test_lengths <-   seq(0.01, (4.57760 - 3.0774), length.out = 12)
# 
# test_length_fit <- map(test_lengths, function(time_length){
#     # time_length <- 0.02
# data_subset <- temp_plt[temp_plt$Time >= 3.0772 & temp_plt$Time <= 3.0772+time_length, ]
# 
# #TODO exponential fit here is very poor. 
# # lm(log(In4) ~ In7, data = data_subset)
# data_offset_y <- min(data_subset$In4) - 10
# data_subset$In4 <- data_subset$In4 - data_offset_y
# 
# data_offset_x <- min(data_subset$Time)
# data_subset$Time <- data_subset$Time - data_offset_x
# 
# 
# # redo with more complicated model
# fm <- nlsLM(
#   In4 ~ a*exp(b*Time) + c*exp(d*Time)+ e, 
#   data = data_subset, 
#   start = list(a = 1, b = -0.01, c = 1, d = -0.1, e = 10), 
#   control = nls.lm.control(maxiter = 1000)
#   )
# 
# return(fm)
# })
# 
# data_subset <- temp_plt[temp_plt$Time >= 3.0772 & temp_plt$Time <= 3.0772+max(test_lengths), ]
# data_offset_y <- min(data_subset$In4) - 10
# data_subset$In4 <- data_subset$In4 - data_offset_y
# 
# data_offset_x <- min(data_subset$Time)
# data_subset$Time <- data_subset$Time - data_offset_x
# 
# prediction_df <- map(seq_along(test_length_fit), function(i){
#   fm <- test_length_fit[[i]]
#   
#   predict(fm, data_subset)
# })
# 
# prediction_df <- as.data.frame(do.call(cbind, prediction_df))
# names(prediction_df) <- as.character(test_lengths)
# prediction_df <- cbind(Time = data_subset$Time, prediction_df)
# 
# 
# library(gganimate)
# plt_df <- gather(prediction_df, 
#        key = "Duration", value = "In4", 
#        as.character(test_lengths)) 
# 
# # plt_gif <- 
# ggplot(data_subset, aes(Time, In4))+
#   geom_point(color = "white")+
#   # geom_point(color = "white")+ #aes(color = Duration))+
#   geom_point(data = plt_df, aes(color = Duration))+
#   brms::theme_black()+
#   geom_point(data = plt_df, aes(x = as.numeric(Duration)), color = "white")+
#   # labs(title = 'Duration Fit: {frame_time}', x = 'Seconds', y = 'Shifted mV') +
#   transition_states(Duration) +
#   ease_aes('linear')
# 
# 
# # save as a GIF
# animate(plt_gif, fps = 10, width = 750, height = 450)
# anim_save("Curve_Fitting.gif")
# test_length_fit <- do.call(rbind, test_length_fit) 
# 
# test_length_fit <- full_join(mutate(temp_plt, SampleDuration = 0), test_length_fit)
# 
# test_length_fit <- test_length_fit %>% 
#   mutate(SampleDuration = as.factor(SampleDuration)) 
# 
# test_length_fit %>% 
#   ggplot(aes(Time, In4, color = SampleDuration))+
#   geom_line()+
#   viridis::scale_color_viridis(discrete = T)+
#   see::theme_blackboard()+
#   theme(legend.position = "bottom")+
#   xlim(3, 3.5)
# 
# 
# 
# ggplot(aes(Time, In4))+
#   geom_path(data = temp_plt)+
#   geom_path(data = test_length_fit[test_length_fit$SampleDuration == 0.01, ], color = "red")+
#   xlim(3, 5)
# 
# 
# insertList = list(a=1,b=-0.01,c=1,d=-0.01)
# fm <- nls(In4 ~ a*exp(In7) + c*exp(d*In7), data = inj_current_data, start = insertList )


```






visualization:

(epsp) How could we slice up the trace? 
```{r}
## Here's the stimulus used in the protocol ====
# sweep duration should be 19.687 seconds
epsp_stim <- readABF_as_matrix(here("inst", "extdata", "epsp_stim_files", "08 current injection.abf"),
                  channels = "Axo1I2")
epsp_stim <- as_tibble(epsp_stim) %>%
  mutate(Time = Time - min(Time, na.rm = T)) %>%
  rename(Stim = Axo1I2)


shading_annotations <- data.frame(
  starts = c(0.40,
             4.87,
             10.74,
             16.74),
  next_start = c(4.87,
                 10.74,
                 16.74,
                 19.685),
  equal_len = c(0.40,
                4.87,
                10.74,
                16.74) + 2.945,
  on_end = c(2,
             6.17,
             12.54, 
             18.5),
  equal_on = c(0.40,
               4.87,
               10.74,
               16.74) + 1.30
)

ggplot()+
  geom_vline(xintercept = c(shading_annotations$starts, shading_annotations$equal_len, shading_annotations$next_start, shading_annotations$equal_on), color = "gray")+
    geom_path(data = epsp_stim, aes(Time, Stim+1.5))+
  geom_rect(data = shading_annotations, aes(xmin = starts, xmax = next_start, ymin = 0, ymax = 0.5), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[1], color = RColorBrewer::brewer.pal(3, "Set1")[1])+
  geom_rect(data = shading_annotations, aes(xmin = starts, xmax = equal_len, ymin = -0.5, ymax = 0), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[1], color = RColorBrewer::brewer.pal(3, "Set1")[1])+
  geom_rect(data = shading_annotations, aes(xmin = starts, xmax = on_end, ymin = -1, ymax = -0.5), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[2], color = RColorBrewer::brewer.pal(3, "Set1")[2])+
  geom_rect(data = shading_annotations, aes(xmin = starts, xmax = equal_on, ymin = -1.5, ymax = -1), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[2], color = RColorBrewer::brewer.pal(3, "Set1")[2])+
  theme_classic()+
  geom_vline(xintercept = 12.54)+
  ylim(-1.5, 9.5)+
  labs(title = "Ways to Segement EPSP Stim")
```


```{r}
to_use <- full_join(file_groups, files_df) %>% filter(Type == "epsp" & Group %in% c("Baseline", "compensated", "Delayed"))


ephys_meta <- readxl::read_excel(here("inst", "extdata", "ManualDataEphys02.xlsx"), sheet = "MetadataEphys") #"TECC", "TEVC", "IA", "IHTK"

ephys_meta <- ephys_meta %>% 
  mutate(num_zeros = 4 - floor(log(Recording))) %>% 
  mutate(num_zeros = ifelse(num_zeros == 3, "000", 
                            ifelse(num_zeros == 2, "00", 
                                   ifelse(num_zeros == 1, "0", NA)))) %>% 
  mutate(files = paste0(Experiment, "_", num_zeros, as.character(Recording), ".abf" ))


#


# trace_list <- map(seq(1, nrow(to_use)), function(i){
#   trace <- readABF_as_matrix(
#     path = paste0(traces_dir, "/", as.character(to_use[i, "files"])),
#     channels = c("IN 4", "IN 7", 
#                  "IN 9", "IN 12"#, "IN 14"
#     ))
#   
#   trace <- as.data.frame(trace) %>% 
#     janitor::clean_names(case = "upper_camel") %>% 
#     mutate(Time = Time - min(Time, na.rm = T),
#            Experiment = to_use[i, "Experiment"],
#            Group = to_use[i, "Group"],
#            files = to_use[i, "files"]
#     )
#   
#   if (ncol(trace) == 8){
#      return(trace) 
#   } else {
#     return(
#       data.frame(In4 = NA,
#                  In7 = NA, 
#                  In9 = NA, 
#                  In12 = NA, 
#                  Time = NA,
#                  Experiment = to_use[i, "Experiment"],
#                  Group = to_use[i, "Group"],
#                  files = to_use[i, "files"])
#       )
#   }
# })

# trace_df <- do.call(rbind, trace_list) %>% pivot_longer(names_to = "Channel", values_to = "mV", c("In4", "In7", "In9", "In12"))
# 
# 
# # find the low variance traces and drop them. Thesea are in the bath.
# trace_dstats <- trace_df %>%
#   group_by(files, Channel) %>%
#   summarise(sd = sd(mV, na.rm = T),
#             mean = mean(mV, na.rm = T),
#             min = min(mV, na.rm =T),
#             max = max(mV, na.rm = T)) %>%
#   mutate(range = abs(max - min))
# 
# trace_df <- full_join(trace_df, trace_dstats)
# 
# 
# trace_df$Channel <- factor(trace_df$Channel, levels = c("In4", "In9", "In7", "In12"))
# # GROUP = "Baseline"
# 
# 
# ## Big picture show everything ====
# for (GROUP  in c("Baseline", "Compensated", "Delayed")){
#   trace_df[seq(1, nrow(trace_df), by = 25), ] %>%
#     filter(Group == GROUP) %>%
#     mutate(colorvar = ifelse(Channel %in% c("In4", "In9"), "mV", "nA")) %>%
#     filter(colorvar == "mV") %>%
#     ggplot(aes(x = Time, y = mV, group = Channel, color = Channel))+
#     # scattermore::geom_scattermore()+
#     geom_path(alpha = 0.9)+
#     theme_minimal()+
#     theme(legend.position = "")+
#     scale_color_brewer(palette = "Set1")+
#     ylim(-70, -10)+
#     facet_wrap(.~files, scales = "free")
# 
#   ggsave(here("figures", paste0("prelim_trace_vis_", GROUP, ".pdf")), width = 9, height = 9)
# 
# }

```





This is the way
```{r}
M <- readABF_as_matrix2(path = "C:/Users/Daniel/Documents/Trace_Holding/190915_0019.abf", #190924_0022.abf",
                   channels = "all",
                   relative.time = T)

temp <- as_tibble(M) %>% 
  janitor::clean_names(case = "upper_camel") %>% 
  mutate(Sweep = as.factor(Sweep)) %>% 
  group_by(Sweep) %>% 
  mutate(MinTime = min(Time, na.rm = T)) %>% 
  mutate(Time = Time - MinTime) %>% 
  filter(Sweep == 1) #%>% 
  # mutate(In7 = rollmean(In7, 17, fill = "extend"))


# temp %>% 
#   ggplot(aes(In7, In4))+
#   geom_path()+
#   geom_smooth(method = lm, fullrange = T, linetype = "dashed")+
#   theme_minimal()

fm <- lm(In4 ~ In7, data = temp)
fm_newdata <- data.frame(In4 = NA, 
                         In7 = temp$In7,
                         Time = temp$Time,
                         sweep = temp$Sweep)
fm_newdata$In4 <- predict(fm, newdata = fm_newdata)


temp <- temp[, c("Time", "In7", "In4")]

temp <- full_join(temp, rename(fm_newdata, lm = In4))

#TODO add in Rin / Tau programmatically

# 190915_0017 #-6nA
# 190915_0019 #epsp
# LC 5
# 
# Est. Rin: 51.21/6 = 8.535 MOhm
# Est. Taus: 
# Tau1			Tau2
# 58.482597351074219	11.020112037658691
# 21.417860031127930	N/A
place_params_for_predict_voltage_trace(tau = 21.417860031127930, Rin = 8.535)

place_data_for_predict_voltage_trace(input.df = temp, Time.ch = "Time", Inj.ch = "In7")

run_predict_voltage_trace.py()

predicted_response <- retrieve_predicted_voltage()



t1 <- temp
t2 <- as_tibble(predicted_response)

# # Feels hacky, but there seems to be a float rounding error here. E.g. Time 0.000199 != 0.0002
# t1$ms <- round(t1$Time * 10000)#/10000
# t2$ms <- round(t2$Time * 10000)#/10000
# 
# t1 <- t1 %>% dplyr::select(-Time)
# t2 <- t2 %>% dplyr::select(-Time)
# 
# t3 <- full_join(t1, t2) 

t3 <- cbind(t1, t2[, "predicted"]) 


t3$Vinf <- (t3$In7*8.535)-49.5
t3$predicted <- t3$predicted-49.5




plt_left <- 
t3 %>% gather(key = "Method", value = "mV", c("lm", "Vinf", "predicted")) %>% 
  ggplot(aes(Time, mV, color = Method))+
  geom_path()+
  geom_path(data = t3, aes(Time, In4), color = "black")+
  theme_minimal()+
  theme(legend.position = "")+
  facet_grid(Method~.)




t3_subtracted <- t3
t3_subtracted$lm <- t3_subtracted$In4 - t3_subtracted$lm
t3_subtracted$Vinf <- t3_subtracted$In4 - t3_subtracted$Vinf
t3_subtracted$predicted <- t3_subtracted$In4 - t3_subtracted$predicted
t3_subtracted$In4 <- t3_subtracted$In4 - -49.5

plt_mid <-
t3_subtracted %>% gather(key = "Method", value = "mV", c("lm", "Vinf", "predicted")) %>%
  ggplot(aes(Time, mV, color = Method))+
  geom_path()+ #TODO It seems there is a nA that's causing early termination here?
  geom_path(data = t3_subtracted, aes(Time, In4), color = "black")+
  theme_minimal()+
  theme(legend.position = "")+
  facet_grid(Method~.)

plt_right <- 
t3 %>% gather(key = "Method", value = "mV", c("lm", "Vinf", "predicted")) %>% 
  ggplot(aes(In4, mV, color = Method))+
  geom_path()+
  geom_abline(intercept = 0, slope = 1)+
  theme_minimal()+
  theme(legend.position = "")+
  facet_grid(Method~.)
  

library(patchwork)

(plt_left | plt_mid | plt_right) + plot_layout(widths = c(3, 3, 2))

#TODO
# works, now we need to automate the process. Maybe have a datasheet that we pull rin, tau from. 
```

## Depricate below


Previous way
```{r}

#TODO delete after adaption -- copied 12.34, 20/07/27



# Calculate, don't regress, mV ----
# Test:
# "190918_0025.abf" # FI
# "190918_0019.abf" # epsp
# "190918_0021.abf" # gj na
# "190918_0009.abf" # gj tevc

# Cleaner
# "190903_0025.abf" # FI
# "190903_0023.abf" # epsp
# "190903_0021.abf" # gj na
# "190903_0020.abf" # gj tevc


file_list <- list(FI = "190903_0025.abf",
             EPSP = "190903_0023.abf",
             GJCC = "190903_0021.abf", 
             GJVC = "190903_0020.abf")

trace_list <- map(seq_along(file_list), function(i){
  temp <- readABF_as_matrix2(path = paste0("C:/Users/Daniel/Documents/Trace_Holding/", file_list[[i]]),
                     channels = "all",
                     relative.time = T) %>%
    as.data.frame() %>% 
    janitor::clean_names(case = "upper_camel") %>% 
    mutate(Sweep = as.factor(Sweep)) %>% 
    group_by(Sweep) %>% 
    mutate(MinTime = min(Time, na.rm = T)) %>% 
    mutate(Time = Time - MinTime) %>% 
    select(-MinTime)
})

names(trace_list) <- c("FI", "EPSP", "GJCC", "GJVC")

## GJVC: get Ig, Ileak, C ====
temp <- trace_list$GJVC
### Ig 
#TODO

### Ileak
i_leak <- temp[seq(1, nrow(temp), by = 1), ] %>%
  filter(Time > 0.75) %>%
  mutate(In4 = as.numeric(In4)) %>%
  mutate(In7 = as.numeric(In7))

i_leak <- i_leak %>% 
  mutate(Segment = ifelse(Time >= 0.8 & Time <= 1.0, "PreStep", 
                          ifelse(Time >= 1.2 & Time <= 1.25, "Step", 
                                 "NA" ))) %>% 
  group_by(Sweep, Segment) %>% 
  mutate(In4Mean = mean(In4, na.rm = T),
         In7Mean = mean(In7, na.rm = T))

i_leak %>% 
  ggplot(aes(Time, In4, color = Segment))+
  geom_path()

i_leak <- i_leak %>% 
  ungroup() %>%
  select(Sweep, Segment, In4Mean, In7Mean) %>% 
  filter(Segment != "NA") %>% 
  distinct() %>% 
  filter(abs(In4Mean + 60) > 3 )
  
fm <- lm(In4Mean ~ In7Mean, data = i_leak)

In4_R <- as.numeric(broom::tidy(fm)[2, "estimate"])





### Capacitance

# temp_plt <- temp[seq(1, nrow(temp), by = 1), ] %>% 
#   filter(Sweep == 1) %>%
#   mutate(In4 = as.numeric(In4)) %>% 
#   mutate(In7 = as.numeric(In7))
# 
# 
# # capacitance
# plt.1.1 <- temp_plt %>% 
#   ggplot(aes(Time, In4))+
#   geom_path()+
#   xlim(1.0, 1.5)
# 
# 
# plt.2.2 <- 
# temp_plt %>% 
#   ggplot(aes(Time, In7))+
#   geom_ribbon(data = temp_plt[temp_plt$Time >=1.0253215, ], aes(xmin = Time, xmax = Time, ymax = -20.40344, ymin = In7), fill = "gray", alpha = 0.8)+
#   geom_hline(yintercept = mean(unlist(temp_plt[temp_plt$Time >= 1.028 & temp_plt$Time <= 1.030, "In7"])), color = "blue")+
#   geom_hline(yintercept = mean(unlist(temp_plt[temp_plt$Time >= 1 & temp_plt$Time <= 1.024, "In7"])), color = "red")+
#   geom_path()+
#   xlim(1.0225, 1.03)+
#   ylim(-1010, 200)
# 
# 
# plt.2.1 <- 
# temp_plt %>% 
#   ggplot(aes(Time, In7))+
#   geom_ribbon(data = temp_plt[temp_plt$Time >=1.0253215, ], aes(xmin = Time, xmax = Time, ymax = -20.40344, ymin = In7), fill = "gray", alpha = 0.8)+
#   geom_hline(yintercept = mean(unlist(temp_plt[temp_plt$Time >= 1.028 & temp_plt$Time <= 1.030, "In7"])), color = "blue")+
#   geom_hline(yintercept = mean(unlist(temp_plt[temp_plt$Time >= 1 & temp_plt$Time <= 1.024, "In7"])), color = "red")+
#   geom_path()+
#   xlim(1.0, 1.5)+
#   ylim(-1010, 200)
# 
# 
# library(patchwork)
# 
# (plt.1.1 / plt.2.1) | plt.2.2

## GJCC: get R_C, C ====
temp <- trace_list$GJCC

temp_plt <- temp[seq(1, nrow(temp), by = 1), ] %>% 
  filter(Sweep == 4) %>%
  mutate(In4 = as.numeric(In4)) %>% 
  mutate(In7 = as.numeric(In7))

### test minpack.lm ####
# install.packages("minpack.lm")
library(minpack.lm)
temp_plt %>% 
  ggplot(aes(Time, In4, color = Sweep))+
  geom_vline(xintercept = 3.0775)+
  geom_vline(xintercept = 4.5775)+
  geom_path()+
  xlim(3, 5)
  

### Proof of principle 1 fit. ####
# https://stackoverflow.com/questions/26560849/exponential-regression-with-nls-in-r
# https://stats.stackexchange.com/questions/160552/why-is-nls-giving-me-singular-gradient-matrix-at-initial-parameter-estimates
#https://rpubs.com/mengxu/exponential-model

time_length <- 1.5
data_subset <- temp_plt[temp_plt$Time >= 3.0775 & temp_plt$Time <= 3.0772+time_length, ]



# data_offset_y <- min(data_subset$In4) - 10
# data_subset$In4 <- data_subset$In4 - data_offset_y

data_offset_x <- min(data_subset$Time)
data_subset$Time <- data_subset$Time - data_offset_x


### 1 term fit ####
fm <- nlsLM(
  In4 ~ a*exp(b*Time) + c, 
  data = data_subset, 
  start = list(a = 1, b = -0.01, c = 10)
  )


tidy_fm <- broom::tidy(fm)


temp <- data.frame(x = seq(0, 1.5, length.out = 100)) %>% 
  mutate(y1 = as.numeric(tidy_fm[1, "estimate"])*exp(as.numeric(tidy_fm[2, "estimate"]) * x) + as.numeric(tidy_fm[3, "estimate"])
         )


data_subset %>% 
  ggplot(aes(Time, In4))+
  geom_path(size = 2, color = "white")+
  geom_path(data = temp, aes(x = x, y = y1), size = 1, color = "yellow")+
  see::theme_blackboard()


# V(t) = Vmax*(1-e^(-t/tau)) # rise
# V(t) = Vmax*(e^(-t/tau)) # fall

Vmax = -123



Vmax = 10
tau = 2 # smaller == faster

nsteps = 100
testdf <- data.frame(Time = seq(0, 100, length.out = nsteps), 
                     Vmax = NA,
                     Vrest = -10,
                     Rin = 1,
                     Inj_nA = rep(c(0,0), each = nsteps/2),
                     V = 0)

testdf$Vmax = (testdf$Rin*testdf$Inj_nA)+testdf$Vrest

for (i in seq(2, nrow(testdf))){
  # at each step, is vmax > | < v(t-1)?
  if (testdf[i-1, "V"] < testdf[i, "Vmax"]){
    # if greater apply rise formula   
    # testdf[i, "V"] <- Vmax*(1-exp(-testdf[i, "Time"] / tau)) # rise
    testdf[i, "V"] <- testdf[i, "Vmax"]*(1-exp(-testdf[i, "Time"] / tau)) # rise
    
  } else if (testdf[i-1, "V"] > testdf[i, "Vmax"]){
    # if lesser  apply fall formula
    # testdf[i, "V"] <- Vmax*exp(-testdf[i, "Time"] / tau) # fall
    testdf[i, "V"] <- testdf[i, "Vmax"]*(-exp(-testdf[i, "Time"] / tau)) # fall
    
  } else {
    testdf[i, "V"] <- testdf[i, "Vmax"]
  }
  
  


}
testdf %>% 
  ggplot(aes(x = Time, y = V))+lemon::geom_pointline()




























testdf <- temp_plt[temp_plt$Time >= 2.0775 & temp_plt$Time <= 3.0772+time_length, ] %>% 
  ungroup() %>% 
  dplyr::select(Time, In7, In4) %>%
  mutate(In4_p = NA, 
         Fit = -50.8,
         In4_target = NA)




fit_time_array <- testdf[testdf$Time >= 3.0772 & testdf$Time <= 3.0772+time_length, "Time"]
fit_time_array <- fit_time_array - min(fit_time_array) # ensure we're applying it to the right time length
testdf[testdf$Time >= 3.0772 & testdf$Time <= 3.0772+time_length, "Fit"] <- as.numeric(tidy_fm[1, "estimate"])*exp(as.numeric(tidy_fm[2, "estimate"]) * fit_time_array) + as.numeric(tidy_fm[3, "estimate"])


In4_rest = -50.8
In4_Rin = (-123-In4_rest)/-6
rec_timestep <- testdf[2, "Time"] - testdf[1, "Time"]

testdf[1, "In4_p"] <- testdf[1, "In4"]


# as.numeric(tidy_fm[1, "estimate"])*exp(as.numeric(tidy_fm[2, "estimate"]) * rec_timestep) + as.numeric(testdf[i, "In7"])*In4_Rin

testdf$In4_target <- testdf$In7*In4_Rin + In4_rest
# testdf[i, "In4_target"] <- (In4_rest + (as.numeric(testdf[i, "In7"])*In4_Rin)) 

i=2
for (i in seq(2, nrow(testdf))){
  testdf[i, "In4_p"] <- as.numeric(tidy_fm[1, "estimate"])*exp(as.numeric(tidy_fm[2, "estimate"]) * rec_timestep) + as.numeric(testdf[i, "In4_target"]) + as.numeric(testdf[i-2, "In4_p"])  
}



testdf %>% 
  ggplot(aes(Time, In4))+
  geom_path(size = 2, color = "white")+
  geom_path(aes(y = Fit), size = 1, color = "yellow")+
  geom_path(aes(y = In4_target), size = 1, color = "orange")+
  geom_path(aes(y = In4_p), size = 1, color = "red")+
  see::theme_blackboard()



### redo with more complicated model ####
# fm <- nlsLM(
#   In4 ~ a*exp(b*Time) + c*exp(d*Time)+ e, 
#   data = data_subset, 
#   start = list(a = 1, b = -0.01, c = 1, d = -0.1, e = 10)
#   )
# 
# data_subset %>% 
#   ggplot(aes(Time, In4))+
#   geom_path()+
#   geom_path(data = data.frame(In4 = predict(fm, data_subset),
#                               Time = data_subset$Time), color = "red")
# 
# tidy_fm <- broom::tidy(fm)
# 
# 
# temp <- data.frame(x = seq(0, 1.5, length.out = 100)) %>% 
#   mutate(y1 = as.numeric(tidy_fm[1, "estimate"])*exp(as.numeric(tidy_fm[2, "estimate"]) * x),
#          y2 = as.numeric(tidy_fm[3, "estimate"])*exp(as.numeric(tidy_fm[4, "estimate"]) * x),
#          y3 = as.numeric(tidy_fm[1, "estimate"])*exp(as.numeric(tidy_fm[2, "estimate"]) * x) + as.numeric(tidy_fm[3, "estimate"])*exp(as.numeric(tidy_fm[4, "estimate"]) * x) + as.numeric(tidy_fm[5, "estimate"])
#          )
# 
# 
# data_subset %>% 
#   ggplot(aes(Time, In4))+
#   geom_path(size = 2, color = "white")+
#   geom_path(data = temp, aes(x = x, y = y1), size = 1, color = "yellow")+ # slower exponential term (tau0) is the membrane time constant
#   geom_path(data = temp, aes(x = x, y = y2), size = 1, color = "orange")+
#   geom_path(data = temp, aes(x = x, y = y3), size = 1, color = "red")+
#   see::theme_abyss()

### ####

# 
# temp <- data_subset %>% dplyr::select()
# temp
# 
# mutate(y1 = as.numeric(tidy_fm[1, "estimate"])*exp(as.numeric(tidy_fm[2, "estimate"]) * x) + as.numeric(tidy_fm[3, "estimate"])
#          )





In4_tau0 <- as.numeric(tidy_fm[2, "estimate"])
# fm <- nlsLM(
#   # In4 ~ a*exp(-b*In7)+c, 
#   In4 ~ a*exp(-b*In7)+c*exp(-d*In7)+e, 
#   data=data_subset, 
#   # start=list(a=1, b=1, c=50),  
#   start=list(a=1, b=1, c=1, d=1, e=50),  
#   algorithm = "LM",
#   control = nls.lm.control(maxiter = 1000))

In4_R
In4_tau0


In4_Rin = -123/-6

Inj_nA <- -6
v_rest = 83.5# -49.6


data_subset$In4_p <- NA
data_subset$In4_delta <- NA
data_subset <- data_subset[, c("In4_delta", "In4_p", "In4", "In7", "Time")]



data_subset[1, "In4_p"] <- data_subset[1, "In4"]
i=2

data_subset[i-1, "In4_p"]*exp(-1*((data_subset[i, "Time"] - data_subset[i-1, "Time"]) / (In4_tau0)))


data_subset %>% 
  ggplot(aes(Time, In4))+
  geom_path(size = 2, color = "white")+
  geom_path(aes(y = In4_p), size = 1, color = "yellow")+
  see::theme_abyss()



# Q = CV
# dQ/dt = C*(dV/dt)
# I_c (capacitive current)
# I_c = C*(dV/dt)

# delta_V (across resistor) = IR
# E is vRest
# V - E = IR
# I_R = current across resistor
# I_R = (V-E) / R

# I_c + I_R = 0

#R*C*(dv/dt) = E - V









# tau * V'(t) = V_Cl - V(t) + I_stim(t) / (Area * g_CL)
# tau == C_mem / g_Cl

# V_Cl == rest?

# cell of radius 10 μm
# Cm =1 μF/cm2
# gCl =0.3 mS/cm2
# subject to a 20 ms, 10 pA current injection


V_t = +10
V_rest = -68
I_stim = 0#.0001
max_time = 0.1
nsteps = 10

temp <- data.frame(Time = seq(0, max_time, length.out = nsteps),
           mV = NA)
temp[1, "mV"] <- V_t



for (i in 2:nrow(temp)){
  cell_area = (pi*10)^2 * (1/10000)
  v_prime =  (V_rest - V_t + (I_stim/(cell_area*0.3)) ) / (1/0.3) # div by tau
  temp[i, "mV"] <- v_prime
  V_t <- v_prime+V_t
}



cumsum(x = temp$mV)

temp %>% 
  ggplot(aes(x = Time, y = mV))+
  geom_path()






# ### what is the effect of the length of time used? ####

# 
# test_lengths <-   seq(0.01, (4.57760 - 3.0774), length.out = 12)
# 
# test_length_fit <- map(test_lengths, function(time_length){
#     # time_length <- 0.02
# data_subset <- temp_plt[temp_plt$Time >= 3.0772 & temp_plt$Time <= 3.0772+time_length, ]
# 
# #TODO exponential fit here is very poor. 
# # lm(log(In4) ~ In7, data = data_subset)
# data_offset_y <- min(data_subset$In4) - 10
# data_subset$In4 <- data_subset$In4 - data_offset_y
# 
# data_offset_x <- min(data_subset$Time)
# data_subset$Time <- data_subset$Time - data_offset_x
# 
# 
# # redo with more complicated model
# fm <- nlsLM(
#   In4 ~ a*exp(b*Time) + c*exp(d*Time)+ e, 
#   data = data_subset, 
#   start = list(a = 1, b = -0.01, c = 1, d = -0.1, e = 10), 
#   control = nls.lm.control(maxiter = 1000)
#   )
# 
# return(fm)
# })
# 
# data_subset <- temp_plt[temp_plt$Time >= 3.0772 & temp_plt$Time <= 3.0772+max(test_lengths), ]
# data_offset_y <- min(data_subset$In4) - 10
# data_subset$In4 <- data_subset$In4 - data_offset_y
# 
# data_offset_x <- min(data_subset$Time)
# data_subset$Time <- data_subset$Time - data_offset_x
# 
# prediction_df <- map(seq_along(test_length_fit), function(i){
#   fm <- test_length_fit[[i]]
#   
#   predict(fm, data_subset)
# })
# 
# prediction_df <- as.data.frame(do.call(cbind, prediction_df))
# names(prediction_df) <- as.character(test_lengths)
# prediction_df <- cbind(Time = data_subset$Time, prediction_df)
# 
# 
# library(gganimate)
# plt_df <- gather(prediction_df, 
#        key = "Duration", value = "In4", 
#        as.character(test_lengths)) 
# 
# # plt_gif <- 
# ggplot(data_subset, aes(Time, In4))+
#   geom_point(color = "white")+
#   # geom_point(color = "white")+ #aes(color = Duration))+
#   geom_point(data = plt_df, aes(color = Duration))+
#   brms::theme_black()+
#   geom_point(data = plt_df, aes(x = as.numeric(Duration)), color = "white")+
#   # labs(title = 'Duration Fit: {frame_time}', x = 'Seconds', y = 'Shifted mV') +
#   transition_states(Duration) +
#   ease_aes('linear')
# 
# 
# # save as a GIF
# animate(plt_gif, fps = 10, width = 750, height = 450)
# anim_save("Curve_Fitting.gif")
# test_length_fit <- do.call(rbind, test_length_fit) 
# 
# test_length_fit <- full_join(mutate(temp_plt, SampleDuration = 0), test_length_fit)
# 
# test_length_fit <- test_length_fit %>% 
#   mutate(SampleDuration = as.factor(SampleDuration)) 
# 
# test_length_fit %>% 
#   ggplot(aes(Time, In4, color = SampleDuration))+
#   geom_line()+
#   viridis::scale_color_viridis(discrete = T)+
#   see::theme_blackboard()+
#   theme(legend.position = "bottom")+
#   xlim(3, 3.5)
# 
# 
# 
# ggplot(aes(Time, In4))+
#   geom_path(data = temp_plt)+
#   geom_path(data = test_length_fit[test_length_fit$SampleDuration == 0.01, ], color = "red")+
#   xlim(3, 5)
# 
# 
# insertList = list(a=1,b=-0.01,c=1,d=-0.01)
# fm <- nls(In4 ~ a*exp(In7) + c*exp(d*In7), data = inj_current_data, start = insertList )




```




```{r}
#TODO Are we getting all the sweeps? The recording is 4x the length that would be expected. 
get_epsp_trace <- function(file.name = to_use[i, "files"],
                           file.Exp = to_use[i, "Experiment"],
                           file.Group = to_use[i, "Group"]){
  trace <- readABF_as_matrix(
    path = paste0(traces_dir, "/", as.character(file.name)),
    channels = c("IN 4", "IN 7", 
                 "IN 9", "IN 12"#, "IN 14"
    ))
  
  trace <- as.data.frame(trace) %>% 
    janitor::clean_names(case = "upper_camel") %>% 
    mutate(Time = Time - min(Time, na.rm = T),
           Experiment = as.character(file.Exp),
           Group = as.character(file.Exp),
           files = as.character(file.name)
    )
  
  if (ncol(trace) == 8){
     return(trace) 
  } else {
    return(
      data.frame(In4 = NA,
                 In7 = NA, 
                 In9 = NA, 
                 In12 = NA, 
                 Time = NA,
                 Experiment = as.character(file.Exp),
                 Group = as.character(file.Group),
                 files = as.character(file.name))
      )
  }
}




i = min(which(to_use$Group == "Baseline"))
# j = min(which(to_use$Group == "Delayed"))
j = which(to_use$Group == "Baseline")
i.ch = "In4"
j.ch = "In4"





xdata <- get_epsp_trace(file.name = to_use[i, "files"],
                        file.Exp = to_use[i, "Experiment"],
                        file.Group = to_use[i, "Group"])
ydata <- get_epsp_trace(file.name = to_use[j, "files"],
                        file.Exp = to_use[j, "Experiment"],
                        file.Group = to_use[j, "Group"])

plt.data <- data.frame(
  Time = xdata$Time,
  x = xdata[[i.ch]],
  y = ydata[[j.ch]])

plt <- plt.data %>% 
  ggplot(aes(x = x, y = y))+
  geom_abline(intercept = 0, slope = 1, color = "firebrick")+
  scattermore::geom_scattermore()+
  geom_smooth(method = "lm", fullrange = T)+
  theme_minimal()

```


workspace 
```{r}


trace_df2 <- full_join(trace_df, ephys_meta)




             
## Work with a single trace ====
keep_every <- 25

tr_baseline <- trace_df[seq(1, nrow(trace_df), by = keep_every), ]  %>% filter(files == "190930_0009.abf")
tr_compensated <- trace_df[seq(1, nrow(trace_df), by = keep_every), ]  %>% filter(files == "191004_0030.abf") #TODO see also 190808a_0014.abf
tr_delayed <- trace_df[seq(1, nrow(trace_df), by = keep_every), ]  %>% filter(files == "190915_0019.abf")

tr_baseline %>% 
  filter(Channel == "In7") %>% 
  mutate(mV = rollmean(mV, k = 17, fill = "extend")) %>% 
  ggplot(aes(x = Time, y = mV, color = Channel))+
  geom_path()+
  geom_vline(xintercept = c())+
  theme_minimal()+
  theme(legend.position = "bottom")+
  scale_color_brewer(palette = "Set1")

```



```{r}
trace <- readABF_as_matrix(
  path = paste0("C:/Users/Daniel/Documents/Trace_Holding/", as.character(files_df[files_df$Type == "epsp", "files"])[1] ),
  channels = c("IN 4", "IN 7", "IN 9", "IN 12", "IN 14"))

as.data.frame(trace) %>% 
  dplyr::select(Time, `IN 4`, `IN 9`) %>% 
  tidyr::gather(Channel, mV, c("IN 4", "IN 9")) %>% 
  ggplot(aes(Time, mV, color = Channel))+
  geom_path()+
  scale_color_brewer(palette = "Set1")
```


epsp annotation
```{r}
trace <- as.data.frame(trace) %>% janitor::clean_names(case = "upper_camel")

# Restructure
trace_p1 <- trace[,      c("In4", "In7",  "Time")] %>% 
  gather(Channel, Value, c("In4", "In7"))  %>% 
  mutate(Unit = ifelse(Channel %in% c("In4", "In9"), "mV", 
                ifelse(Channel %in% c("In7", "In12"), "nA", NA)))

trace_p2 <- trace[,      c("In9", "In12", "Time")] %>% 
  gather(Channel, Value, c("In9", "In12")) %>% 
  mutate(Unit = ifelse(Channel %in% c("In4", "In9"), "mV", 
                ifelse(Channel %in% c("In7", "In12"), "nA", NA)))

trace <- rbind(trace_p1, trace_p2)

#    Condition   Experiment     n
#    <fct>       <chr>      <int>
#  1 Baseline    190924         2
#  2 Baseline    190924a        2
#  3 Baseline    190926         3
#  4 Baseline    190927         2
#  5 Baseline    190927a        3
#  6 Baseline    190930         2
#  7 Baseline    190930a        2
#  8 Compensated 190808a        3
#  9 Compensated 190830         1
# 10 Compensated 190904         2
# 11 Compensated 191001         2
# 12 Compensated 191004         2
# 13 Delayed     190903         2
# 14 Delayed     190905         2
# 15 Delayed     190906         2
# 16 Delayed     190907         1
# 17 Delayed     190915         3
# 18 Delayed     190917         3
# 19 Delayed     190918         2



```




# Processing current clamp traces. 

 
```{r}
traces <- list.files(here::here("inst", "extdata", "ABFs", "ExcitabilityEPSP"))

## load in traces, make them into dfs, and give them names equal to their file names ====
stim <- map(traces, function(i){
  readABF_as_matrix(
  path = paste0(here::here("inst", "extdata", "orig_waveforms"), "/", i),
  channels = c("IN 4", "IN 9"))
})
names(stim) <- traces
stim <- plyr::ldply(stim, data.frame)
stim <- rename(stim, Trace = .id)

## find the start time for each trace and adjust the mime of each so all begin at 0 ====
min.times <- stim %>% group_by(Trace) %>% summarise(min(Time))

stim$min.time <- NA
walk(seq(from = 1, to = nrow(min.times)), 
     function(i){
       stim[stim$Trace == as.character(min.times[i, "Trace"]), "min.time"] <<- as.numeric(min.times[i, 2])
     })

stim <- stim %>% mutate(Time = Time - min.time) %>% gather(Ch, mV, c("IN.4", "IN.9"))

## Remove any artifacts ====
#large artifact in 180717a_0013.abf between 4.918, 4.926. Replace with values at 4.918
# replace.vals <- stim %>% ungroup() %>% filter(Trace == "180717a_0013.abf", Time == 0) %>% group_by(Ch)
stim[stim$Trace == "180717a_0013.abf" & (stim$Time > 4.918 & stim$Time < 4.926), "mV"] <- -56.0


## Smooth ====
stim <- stim %>% 
  ungroup() %>% 
  group_by(Trace, Ch) %>% 
  mutate(mV.f = zoo::rollmean(x = mV, k = 5, fill = "extend")) %>%
  mutate(ID = paste(Ch, Trace)) %>%
  ungroup()
  

### The diversity of traces used ####
# stim %>%
#   # filter(Trace == "180717a_0013.abf") %>%
#   ggplot(aes(Time, mV.f, group = ID, color = Trace))+
#   geom_line(alpha = 0.6)+
#   facet_grid(.~Ch)+
#   theme(legend.position = "")


# See the standardized protocols to pair them with ####
# "180221_0029.abf", "TEA sync",
# "180308_0013.abf", "b",
# "180425_0017.abf", "c",
# "180510_0034.abf", "a", 
# "180604_0009.abf", "TEA async",
# "190408_0026.abf", "d",
# "191209_0011.abf", "HA 90"

# stim[stim$Trace %in% c("180221_0029.abf", 
#                        "180308_0013.abf", 
#                        "180425_0017.abf", 
#                        "180510_0034.abf", 
#                        "180604_0009.abf", 
#                        "190408_0026.abf", 
#                        "191209_0011.abf"),  ] %>%
#   ggplot(aes(Time, mV.f, group = ID, color = Ch))+
#   geom_line(alpha = 0.6)+
#   facet_grid(Trace~.)+
#   theme(legend.position = "")




one.trace <- stim %>%
  # filter(Trace %in% c("170710_0037.abf", "180718a_0009.abf")) %>% #FIXME When ready, remove to put all through
  dplyr::select(-min.time,  -ID, -mV) %>%
  spread(Ch, mV.f)


### Once again, lots of crazy variation ####
# one.trace %>% ggplot(aes(group = Trace))+
#   geom_line(aes(x = Time, y = IN.4), color = "Steelblue")+
#   geom_line(aes(x = Time, y = IN.9), color = "Firebrick")


### We can see the overlap/lack of same here. We should get a unity line when there is no differnce in the stimulus.
# one.trace %>% ggplot()+
#   geom_path(aes(x = IN.4, y = IN.9, color = Time))


```

For summary plot later
```{r}
plt.trace.variation <- one.trace



```

```{r}
# First pass at annotation ----

# one.trace %>% ggplot()+
#   geom_line(aes(x = Time, y = IN.4), color = "Steelblue")+
#   geom_line(aes(x = Time, y = IN.9), color = "Firebrick")+
#   geom_hline(yintercept = min(one.trace$IN.4, na.rm = T), color = "Steelblue")+
#   geom_hline(yintercept = min(one.trace$IN.9, na.rm = T), color = "Firebrick")


# one.trace %>%
#   # Voltage difference
#   mutate(diff = IN.4 - IN.9) %>% # Not really useful atm
#   mutate(intersect.V = ifelse( # lower of the two, used for overlap
#     IN.4 <= IN.9,
#     IN.4, IN.9
#     )
#     ) %>%
#     mutate(union.V = ifelse( # Higher of the two.
#     IN.4 >= IN.9,
#     IN.4, IN.9
#     )
#     ) %>%
#   mutate(higher.V.min = ifelse(
#     min(one.trace$IN.4, na.rm = T) >= min(one.trace$IN.9, na.rm = T),
#      min(one.trace$IN.4, na.rm = T),
#      min(one.trace$IN.9, na.rm = T)
#   )) %>%
#   mutate(Overlap.V =  intersect.V - higher.V.min) %>%
#   ggplot()+
#   geom_line(aes(x = Time, y = Overlap.V))+
#   geom_ribbon(aes(x = Time, ymin=min(Overlap.V), ymax=Overlap.V))+
#   geom_line(aes(x = Time, y = IN.4 - min(one.trace$IN.4, na.rm = T)),
#             color = "Steelblue",
#             size = 1)+
#   geom_line(aes(x = Time, y = IN.9 - min(one.trace$IN.9, na.rm = T)),
#             color = "Firebrick",
#             size = 1)

# geom_line(aes(x = Time, y = IN.4), color = "Steelblue")+
# geom_line(aes(x = Time, y = IN.9), color = "Firebrick")
# geom_hline(yintercept = min(one.trace$IN.4, na.rm = T), color = "Steelblue")+
# geom_hline(yintercept = min(one.trace$IN.9, na.rm = T), color = "Firebrick")

# geom_line(aes(x = Time, y = IN.4 - min(one.trace$IN.4, na.rm = T)), color = "Steelblue")+
# geom_line(aes(x = Time, y = IN.9 - min(one.trace$IN.9, na.rm = T)), color = "Firebrick")+
# geom_line(aes(x = Time, y = diff))

# Second pass at annotation ----

## Group by trace and add possible predictors to it ====

### min, baseline, max, median, and mean mV, and duration (period) ####
one.trace <-
  one.trace %>%
  ungroup() %>%
  gather(Ch, mV, c("IN.4", "IN.9")) %>%
  group_by(Trace, Ch) %>%
  # Min Voltage
  mutate(Min.V = min(mV, na.rm = T)) %>%
  # Baseline voltage
  # Defining as average of the lowest 20% of points
  mutate(Use.in.Base = quantile(mV, probs = .2, na.rm = T)) %>%
  mutate(Use.in.Base = ifelse(mV <= Use.in.Base,
    mV,
    NA
  )) %>%
  mutate(Use.in.Base = mean(Use.in.Base, na.rm = T)) %>%
  # Max voltage
  mutate(Max.V = max(mV, na.rm = T)) %>%
  # Median Voltage
  mutate(Med.V = median(mV, na.rm = T)) %>%
  # Mean Voltage
  mutate(Mean.V = mean(mV, na.rm = T)) %>%
  # Duration
  mutate(Max.Time = max(Time, na.rm = T))

### Delay between channels ####
# Get time at which voltage traces cross a threshold. Then compute the abs(difference)
delays.to.annotate <- one.trace %>%
  mutate(Delay = (mV >= quantile(mV, probs = .9, na.rm = T))) %>%
  filter(Delay == T) %>%
  summarise(
    Thres.Time.b = min(Time, na.rm = T),
    Thres.Time.e = max(Time, na.rm = T)
  )

one.trace$Onset <- NA
one.trace$Termination <- NA
walk(seq(1, nrow(delays.to.annotate)), function(i) {
  one.trace[
    one.trace$Trace == as.character(delays.to.annotate[i, "Trace"]) &
      one.trace$Ch == as.character(delays.to.annotate[i, "Ch"]),
    "Onset"
  ] <<- as.numeric(delays.to.annotate[i, "Thres.Time.b"])

  one.trace[
    one.trace$Trace == as.character(delays.to.annotate[i, "Trace"]) &
      one.trace$Ch == as.character(delays.to.annotate[i, "Ch"]),
    "Termination"
  ] <<- as.numeric(delays.to.annotate[i, "Thres.Time.e"])
})

### Add in On duration, Duty Cycle, and AUC ####
one.trace <- one.trace %>%
  # On duration
  mutate(On.Duration = Termination - Onset) %>%
  # Duty Cycle
  mutate(Duty.Cycle = On.Duration / Max.Time) %>%
  # AUC
  # Using Min.V
  mutate(AUC = (mV - Min.V))


## make a list with more user friendly names ====

# Each elemen tof the list consists of only one channel.
one.trace.list <- map(c("IN.4", "IN.9"), function(i) {
  temp <- filter(one.trace, Ch == i)

  temp.names <- names(temp)

  temp.names[!(temp.names %in% c("Trace", "Time", "Ch"))] <-
    paste(temp.names[!(temp.names %in% c("Trace", "Time", "Ch"))], i, sep = "_")

  names(temp) <- temp.names

  temp %>% ungroup()

  return(temp)
})

# put the channels back together
one.trace <- full_join(
  one.trace.list[[1]],
  one.trace.list[[2]],
  by = c("Trace", "Time")
)


##add in delay for each channel (if it starts first it's 0), percent delay, corrlation between channels, and intersectional overlap between channels ==== 
one.trace <- one.trace %>%
  dplyr::group_by(Trace) %>%
  # Delay
  mutate(Delay_IN.4 = ifelse(
    Onset_IN.4 <= Onset_IN.9,
    0,
    Onset_IN.4 - Onset_IN.9
  )) %>%
  mutate(Delay_IN.9 = ifelse(
    Onset_IN.9 <= Onset_IN.4,
    0,
    Onset_IN.9 - Onset_IN.4
  )) %>%
  # Percent Delay (can be converted into phase)
  mutate(P.Delay_IN.4 = Delay_IN.4 / Max.Time_IN.4) %>%
  mutate(P.Delay_IN.9 = Delay_IN.9 / Max.Time_IN.9) %>%
  # Correlation
  mutate(Cor = cor(mV_IN.4, mV_IN.9,
    use = "pairwise.complete.obs",
    method = "pearson"
  )) %>%
  # intersect AUC / % overlap
  mutate(Min.AUC = ifelse(AUC_IN.4 <= AUC_IN.9,
    AUC_IN.4,
    AUC_IN.9
  ))


## show that min AUC is acting as expected ====
# one.trace %>%
#   ggplot(aes(group = Trace)) +
#   geom_line(aes(x = Time, y = mV_IN.4 - Min.V_IN.4), color = "Blue", alpha = 0.4) +
#   geom_line(aes(x = Time, y = mV_IN.9 - Min.V_IN.9), color = "Red", alpha = 0.4) +
#   geom_line(aes(x = Time, y = Min.AUC), color = "Purple") +
#   facet_grid(. ~ Trace)
```

```{r}
## Get summary of all ====

# 1. Get single value descriptors for each trace
one.trace  <- one.trace %>% 
  ungroup() %>% 
  dplyr::group_by(Trace) %>% 
  # Voltages
  mutate(Mean.Min.V = mean(mean(Min.V_IN.4, na.rm = T), mean(Min.V_IN.9, na.rm = T))) %>% 
  mutate(Mean.Max.V = mean(mean(Max.V_IN.4, na.rm = T), mean(Max.V_IN.9, na.rm = T))) %>% 
  mutate(Mean.Med.V = mean(mean(Med.V_IN.4, na.rm = T), mean(Med.V_IN.9, na.rm = T))) %>% 
  mutate(Mean.Mean.V = mean(mean(Mean.V_IN.4, na.rm = T), mean(Mean.V_IN.9, na.rm = T))) %>% 
  
  # Times
  mutate(Mean.Duration = mean(mean(Max.Time_IN.4, na.rm = T), mean(Max.Time_IN.9, na.rm = T))) %>%
  mutate(Mean.On.Duration = mean(mean(On.Duration_IN.4, na.rm = T), mean(On.Duration_IN.9, na.rm = T))) %>% 
  mutate(Mean.Duty.Cycle = mean(mean(Duty.Cycle_IN.4, na.rm = T), mean(Duty.Cycle_IN.9, na.rm = T))) %>% 
  
  mutate(Onset.Delay = max(Delay_IN.4, Delay_IN.9, na.rm = T)) %>% 
  mutate(P.Onset.Delay = max(P.Delay_IN.4, P.Delay_IN.9, na.rm = T)) %>% 
  
  # AUCs -- convert to single value of mV/trace
  mutate(Mean.AUC = mean(sum(AUC_IN.4, na.rm = T), sum(AUC_IN.9, na.rm = T))) %>% 
  mutate(Min.AUC = sum(Min.AUC, na.rm = T)) %>% 
  ## and mV/S
  mutate(Mean.AUC.mV.S = Mean.AUC/Mean.Duration) %>%
  mutate(Min.AUC.mV.S = Min.AUC/Mean.Duration) %>%

  # Clean up selection
  dplyr::select(Trace, #Time, 
                Mean.Min.V, Mean.Max.V, Mean.Med.V, Mean.Mean.V, 
                Mean.Duration, Mean.On.Duration, Mean.Duty.Cycle, 
                Onset.Delay, P.Onset.Delay,
                Mean.AUC, Min.AUC, 
                Mean.AUC.mV.S, Min.AUC.mV.S,
                Cor) %>% ungroup()
 
# 2. Remove the duplicate measures.  
one.trace <- one.trace[!(duplicated(one.trace)), ] 

# 3. Join with gj change datasets
## get the OG dataset ====
# Orig <- M.clean %>% 
Orig <- M.d %>%
  dplyr::filter(Condition %in% c("PS.0.orig",     
                                 "PS.22.orig",   
                                 "PS.45.orig",   
                                 "PS.90.orig",
                                 "PS.180.orig"))
Orig.exps <- Orig$Experiment %>% unique()

## get the standardized dataset ====
Standard <- M.d %>% 
  dplyr::filter(Condition %in% c("PS.0.High.Amp", 
                                 "PS.22.High.Amp", 
                                 "PS.90.HA",
                                 "PS.0", 
                                 "PS.22", 
                                 "PS.45", 
                                 "PS.90"))

## Make trace names join-able ====
new.Trace.names <- stringr::str_split(one.trace$Trace, pattern = "_0") %>% 
  map(function(i){
    pluck(i,1)
  }) %>% unlist()

# Manually fix two
# Orig.exps[!(Orig.exps %in% new.Trace.names)]
# new.Trace.names[!(new.Trace.names %in% Orig.exps)]
new.Trace.names[new.Trace.names == "171016_B"] <- "171016"
new.Trace.names[new.Trace.names == "171017_A"] <- "171017"

one.trace <- one.trace %>% mutate(Experiment = new.Trace.names)


## Produce New Datasets ====
one.trace.orig <- one.trace[!(one.trace$Trace %in% 
                                c("180221_0029.abf", 
                                  "180308_0013.abf",
                                  "180425_0017.abf",
                                  "180510_0034.abf",
                                  "180604_0009.abf",
                                  "190408_0026.abf",
                                  "191209_0011.abf")), ]

one.trace.standard <- one.trace[one.trace$Trace %in% 
                                  c("180221_0029.abf", 
                                    "180308_0013.abf",
                                    "180425_0017.abf",
                                    "180510_0034.abf",
                                    "180604_0009.abf",
                                    "190408_0026.abf",
                                    "191209_0011.abf"), ]

one.trace.standard$Condition <- NA
one.trace.standard[one.trace.standard$Trace == "180221_0029.abf", "Condition"] <- "PS.0.High.Amp"
one.trace.standard[one.trace.standard$Trace == "180308_0013.abf", "Condition"] <- "PS.22"
one.trace.standard[one.trace.standard$Trace == "180425_0017.abf", "Condition"] <- "PS.45"
one.trace.standard[one.trace.standard$Trace == "180510_0034.abf", "Condition"] <- "PS.0"
one.trace.standard[one.trace.standard$Trace == "180604_0009.abf", "Condition"] <- "PS.22.High.Amp"
one.trace.standard[one.trace.standard$Trace == "190408_0026.abf", "Condition"] <- "PS.90"
one.trace.standard[one.trace.standard$Trace == "191209_0011.abf", "Condition"] <- "PS.90.HA"



Orig <- full_join(Orig, one.trace.orig, by = "Experiment")

Standard <- full_join(Standard, one.trace.standard, by = "Condition")
```

Version 1 of the figure displaying individualized data.

```{r}
# plt.trace.variation <- plt.trace.variation[plt.trace.variation$Trace %in% unique(plt.trace.variation$Trace)[c(1,2,4,11,14,#17,19,
#                                                                                                               20,21,26)], ]


plt.trace.variation <- plt.trace.variation[!(plt.trace.variation$Trace %in% 
                                c("180221_0029.abf", 
                                  "180308_0013.abf",
                                  "180425_0017.abf",
                                  "180510_0034.abf",
                                  "180604_0009.abf",
                                  "190408_0026.abf",
                                  "191209_0011.abf")),]

# Add in labels for facetting
temp <- Orig %>% dplyr::select(Condition, Experiment#, Mean.Duration, Mean.On.Duration
                               ) %>% rename(Trace = Experiment) %>% distinct() 



# which experiments use the same stim protocol?
temp1 <- left_join(mutate(plt.trace.variation, Trace = unlist(transpose(str_split(plt.trace.variation$Trace, "_"))[[1]]) ) , temp) %>% dplyr::select(-Condition)

temp1 %>% 
  group_by(Trace) %>% 
  summarise(Duration = max(Time)) %>% arrange(Duration)
	
#     Trace   Duration
# 1	  170623b	2.799864

# 2	  170803b	3.165165

# 3	  170825a	3.200130
# 4	  170925A	3.200130

# 5	  170705a	3.240090
# 6  	170710	3.240090
# 7  	170711e	3.240090

# 8	  170814b	4.300029

# 9	  170808a	4.399929
# 10	170808b	4.399929
# 11	170811	4.399929
# 12	171016	4.399929
# 13	171017	4.399929
# 14	171201	4.399929

# 15	180717a	5.000000

# 16	170828a	5.200128
# 17	180717	5.200128

# 18	170728a	5.435892
# 19	170801a	5.435892
# 20	170802a	5.435892
# 21	170803a	5.435892

# 22	180718	5.660000
# 23	180718a	5.660000

# 24	170817b	5.900094

# 25	170713b	6.216777

# 26	170824a	9.300024



temp1 %>% 
  filter(Trace %in% c(
    # "170623b", "170803b", 
    # "170825a", "170925A", #same stim
    # "170705a", "170710", #same stim
                 "170711e",
               
    # "170814b", 
    # "170808a", "170808b",  "170811",  # Same Stim
                 "171016",  "171017",  "171201" #(171016 and 171201 look to be the same but the clamp on the latter is much worse -- unlikely that it acts as the same stim. Code it as a separate variable?)
    # "180717a", 
    # "170828a", "180717"  # Same Stim
    # "170728a", "170801a", "170802a", "170803a", #same stim
    # "180718",  "180718a"#same stim
    # "170817b", "170713b", "170824a"
  )) %>% 
  group_by(Trace) %>% 
  mutate(Duration = round(max(Time), digits = 2)) %>% 
  gather(key = Ch, value = mV, c("IN.4", "IN.9")) %>% 
  ggplot()+
  geom_line(aes(x = Time, y = mV, group = Trace, color = as.character(Duration)))+
  facet_grid(Trace~Ch)+
  theme(legend.position = "")



```

First test of showing individualized phase
```{r}
# denomerator <- 16
for (denomerator in c(16, 8, 4, 2)){

temp2 <- left_join(mutate(plt.trace.variation, Trace = unlist(transpose(str_split(plt.trace.variation$Trace, "_"))[[1]]) ) , temp)

# time.tol <- 0.01
# temp2[(temp2$Mean.Duration > 3.24-time.tol & temp2$Mean.Duration < 3.24+time.tol) |
#         (temp2$Mean.Duration > 5.900094-time.tol & temp2$Mean.Duration < 5.900094+time.tol) | 
#         (temp2$Mean.Duration > 9.300024-time.tol & temp2$Mean.Duration < 9.300024+time.tol), ] %>% 

temp2 <- temp2 %>% dplyr::filter(Trace %in% c("170711e", "170817b")) %>% dplyr::select(-IN.4)




temp2 <- temp2 %>% 
  group_by(Trace) %>% 
  mutate(IN.9 = IN.9 - min(IN.9, na.rm = T)) %>%
  # mutate(mV2 = mV - max(mV, na.rm = T)) %>% 
  mutate(ShiftSec = max(Time, na.rm = T)/denomerator) %>% 
  mutate(Time2 = ifelse(Time < max(Time, na.rm = T)-ShiftSec, Time+ShiftSec, Time-(max(Time, na.rm = T)-ShiftSec)) )

# temp2[temp2$Trace == "170817b", "mV2"] <- temp2[temp2$Trace == "170817b", "mV2"] + min(temp2[temp2$Trace == "170711e", "mV2"], na.rm = T)
# temp2[temp2$Trace == "170817b", "mV"] <- temp2[temp2$Trace == "170817b", "mV2"] + min(temp2[temp2$Trace == "170711e", "mV2"], na.rm = T)


X.shift <- (1.57 -0.355)

ggplot(temp2)+
  geom_line(data = temp2[temp2$Trace == "170711e",], aes(x = Time + X.shift, y = IN.9, group = Trace))+
  geom_line(data = temp2[temp2$Trace == "170711e",], aes(x = Time2 + X.shift, y = IN.9-10, group = Trace))+
  geom_line(data = temp2[temp2$Trace == "170817b",], aes(x = Time, y = IN.9-20, group = Trace))+
  geom_line(data = temp2[temp2$Trace == "170817b",], aes(x = Time2, y = IN.9-30, group = Trace))+
  geom_segment(aes(x = 0, xend = 1, y = -30, yend = -30), size = 1)+
  geom_segment(aes(x = 0, xend = 0, y = -30, yend = -25), size = 1)+
    # geom_vline(xintercept = 1.56)+
  geom_segment(aes(x = 1.56, xend = 1.56+0.2025056, y = 10, yend = 10), size = 1, color = "cornflowerblue")+
  geom_segment(aes(x = 1.56, xend = 1.56+0.3687559 , y = -10, yend = -10), size = 1, color = "cornflowerblue")+
  theme_void()
  
ggsave(here("data", "figures", as.character(paste0("individual_pro_", as.character(round(360/denomerator, digits = 2)), "_v1.pdf"))), 
       width = 8.79, height = 7.21)

ggsave(here("data", "figures", as.character(paste0("individual_pro_", as.character(round(360/denomerator, digits = 2)), "_v1.svg"))), 
       width = 8.79, height = 7.21)
}
```


Second test
```{r}
# Use fraction shift


temp3 <- left_join(mutate(plt.trace.variation, Trace = unlist(transpose(str_split(plt.trace.variation$Trace, "_"))[[1]]) ) , temp)

	
#   Trace mtime
# 1	170623b	2.799864
# 2	170803b	3.165165
# 3	170825a	3.200130
# 4	170925A	3.200130
# 5	170705a	3.240090
# 6	170710	3.240090
# 7	170711e	3.240090
# 8	170814b	4.300029
# 9	170808a	4.399929
# 10	170808b	4.399929
# 11	170811	4.399929
# 12	171016	4.399929
# 13	171017	4.399929
# 14	171201	4.399929
# 15	180717a	5.000000
# 16	170828a	5.200128
# 17	180717	5.200128
# 18	170728a	5.435892
# 19	170801a	5.435892
# 20	170802a	5.435892
# 21	170803a	5.435892
# 22	180718	5.660000
# 23	180718a	5.660000
# 24	170817b	5.900094
# 25	170713b	6.216777
# 26	170824a	9.300024

temp3 <- temp3 %>% dplyr::filter(Trace %in% c("170711e", "170814b", "180718a", "170817b")) %>% dplyr::select(-IN.4)

temp3$Trace <- factor(temp3$Trace, level = c("170711e", "170814b", "180718a", "170817b"))


# denomerator <- 16

for (denomerator in c(16, 8, 4, 2)){

temp3 <- temp3 %>% 
  group_by(Trace) %>% 
  mutate(IN.9 = IN.9 - min(IN.9, na.rm = T)) %>%
  # mutate(mV2 = mV - max(mV, na.rm = T)) %>% 
  mutate(ShiftSec = max(Time, na.rm = T)/denomerator) %>% 
  mutate(Time2 = ifelse(Time < max(Time, na.rm = T)-ShiftSec, Time+ShiftSec, Time-(max(Time, na.rm = T)-ShiftSec)) ) %>% 
  ungroup() %>% 
  mutate(shift_down = max(IN.9, na.rm = T)) %>% 
  mutate(numeric_fac = as.numeric(as.factor(Trace))) %>% 
  mutate(mV = IN.9 - (((numeric_fac-1) * 2) * shift_down) - shift_down ) %>% 
  mutate(mV2 = IN.9 - ((numeric_fac-1) * 2) * shift_down)

  
annotation_df <- temp3 %>% 
  group_by(Trace, ShiftSec, numeric_fac) %>% 
  summarise(#mV_max = max(mV, na.rm = T), 
            mV_min = min(mV, na.rm = T)#,
            # mV2_max = max(mV2, na.rm = T)#, 
            #mV2_min = min(mV2, na.rm = T)
            ) %>% 
  ungroup() %>% 
  mutate(ShiftSec = round(ShiftSec, digits = 3))


tic <- Sys.time()
temp3 %>% 
  ggplot()+
  geom_segment(data = annotation_df, aes(x = 0, xend = ShiftSec, y = mV_min, yend = mV_min), color = "cornflowerblue", size = 2)+
  geom_line(aes(x = Time, y = mV2, group = Trace))+
  geom_line(aes(x = Time2, y = mV, group = Trace))+
  geom_text(data = annotation_df, 
            aes(x = 0.12, y = mV_min+2, label = ShiftSec, group = Trace), 
            parse = T )+
  geom_path(data = data.frame(x = c(-0.1, -0.1, 0.9), y = c(-72, -82, -82)), aes(x = x, y = y))+
  # annotate("text", x = 0.12, y = 11, parse = TRUE, label = as.character(expression(paste(phi, 
  #                                                                                        " = "
  #                                                                                        )
  #                                                                                  )
  #                                                                       )
  #          )+
  theme_void()

ggsave(here("data", "figures", as.character(paste0("individual_pro_", as.character(round(360/denomerator, digits = 2)), "_v2.pdf"))), 
       width = 8.79, height = 7.21)

ggsave(here("data", "figures", as.character(paste0("individual_pro_", as.character(round(360/denomerator, digits = 2)), "_v2.svg"))), 
       width = 8.79, height = 7.21)
}
```


PCA is now shelved.
```{r}

# temp <- Orig[, c(
#   "Time",
#   "r11", "r12", "r1", "rc", "cc", "rmp", 
#   # "gj", 
#   # "intercept.peak_htk", "slope.peak_htk", "intercept.end_htk", "slope.end_htk", "intercept.peak_a", "slope.peak_a", "intercept.end_a", "slope.end_a", "a.peak.nA", "htk.peak.nA", 
#   # "inter", "Trace", 
#   "Mean.Min.V", "Mean.Max.V", "Mean.Med.V", "Mean.Mean.V", "Mean.Duration", "Mean.On.Duration", "Mean.Duty.Cycle", "Onset.Delay", "P.Onset.Delay", "Mean.AUC", "Min.AUC", "Mean.AUC.mV.S", "Min.AUC.mV.S", "Cor"
# )] %>% 
#   dplyr::filter(Time == 40) %>% 
#   dplyr::select(-Time)
# 
# library(factoextra)
# z <- prcomp(~., data = temp, center = TRUE, scale. = TRUE)
# fviz_screeplot(z, addlabels = TRUE, ylim = c(0, 50))
# fviz_pca_var(z, col.var="contrib",
#              gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
#              repel = TRUE # Avoid text overlapping
#              )
# 
# 
# ## Standardized protocols
# plt.list <- map(list(
#   c("PS.0.High.Amp", "PS.22.High.Amp", "PS.90.HA"),
#   c("PS.22", "PS.45", "PS.0", "PS.90"),
#   c("PS.0.High.Amp", "PS.22.High.Amp", "PS.90.HA", "PS.22", "PS.45", "PS.0", "PS.90")
# ), function(i){
#   temp <- Standard[Standard$Condition %in% i , c(
#     "Time",
#     "r11", "r12", "r1", "rc", "cc", "rmp", 
#     # "gj",
#     # "intercept.peak_htk", "slope.peak_htk", "intercept.end_htk", "slope.end_htk", "intercept.peak_a", "slope.peak_a", "intercept.end_a", "slope.end_a", "a.peak.nA", "htk.peak.nA",
#     # "inter", "Trace", 
#     "Mean.Min.V", "Mean.Max.V", "Mean.Med.V", "Mean.Mean.V", #"Mean.Duration", 
#          "Mean.On.Duration", "Mean.Duty.Cycle", "Onset.Delay", "P.Onset.Delay", "Mean.AUC", "Min.AUC", "Mean.AUC.mV.S", "Min.AUC.mV.S", "Cor"
#   )] %>% 
#     dplyr::filter(Time == 40) %>% 
#     dplyr::select(-Time)
#   
#   z <- prcomp(~., data = temp, center = TRUE, scale. = TRUE)
#   plt.scree <- fviz_screeplot(z, addlabels = TRUE#, ylim = c(0, 50)
#                               )
#   plt.biplt <- fviz_pca_var(z, col.var="contrib",
#                             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
#                             repel = TRUE # Avoid text overlapping
#   )
#   
#   return(list(scree = plt.scree,
#               biplt = plt.biplt))
# })
# 
# 
# plt.list[[1]]$scree
# plt.list[[1]]$biplt
# plt.list[[2]]$scree
# plt.list[[2]]$biplt
# plt.list[[3]]$scree
# plt.list[[3]]$biplt
```
