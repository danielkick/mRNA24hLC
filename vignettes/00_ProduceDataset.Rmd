---
title: "Produce Dataset"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
library(here)
library(tidyverse)
library(janitor)

library(zoo)
library(readABF)

library(broom)
library(minpack.lm) # getting Tau
library(patchwork)
library(ggsci)
library(cowplot)
library(patchwork)


library(minpack.lm) # for use in fit_tau_1term_exp()

theme_set(ggplot2::theme_minimal())


library(devtools)
devtools::load_all()
```

## Forward 
This file represents the full preparation of data. Ideally, where we pull processed data (e.g. where I've manually extraced values in clamp fit) will ultimately be replaced with automated, repeatable, and auditable processing. Auditing will be accomplished by including and option to write graphs of the input/output. 

```{r}
# TODO replace manual processing with automatic
# TODO Generate audit output
# TODO edit metadata file so as to allow for specification of traces or regions of traces to be excluded from a file (e.g. drop a segment with loss of voltage clamp)
```

## Build metadata

```{r global params}
use.file.path <- here("inst", "extdata", "ManualDataEphys02.xlsx")

abf_dir_path <- "D:/0000_Traces_mRNA24hLC/"

```

# Working off of non-processed data ----

## Find all the relevant files
```{r}
metadata <- read_excel(use.file.path, sheet = "MetadataEphys")  




# update_type_names <- as_tibble(t(matrix(
#   c("htk", "htk", # ion
#     "a", "a",
#     "htkc", "htkc",
#     "ac", "ac",
#     
#     "tevc", "gjvc", # gj, Rs
#     "igj", "gjcc",
#     "igj_50", "gjcc",
#     
#     "fi_50", "fi", # excitability
#     "fi", "fi",
#     "epsp", "epsp",
#     "epsp_50", "epsp",
#     
#     "gj", "Unknown" #FIXME what are these?
#   ), nrow = 2)))
# names(update_type_names) <- c("InFile", "NewType")

```


```{r}
# Check for missing files relative to the abf directory
```


```{r}
absent_traces <- metadata[!is.na(metadata$Type), ]
absent_traces$Exists <- F

abf_dir <- list.files(abf_dir_path)
for (i in seq(1, nrow(absent_traces))){
  # make the file name
  num_zeros <- 4-nchar(absent_traces[i, "Recording"])
  num_zeros <- case_when(num_zeros == 0 ~ "",
                         num_zeros == 1 ~ "0",
                         num_zeros == 2 ~ "00",
                         num_zeros == 3 ~ "000")
  
  abf_name <- paste(as.character(absent_traces[i, "Experiment"]),
                    paste0(num_zeros, as.character(absent_traces[i, "Recording"]), ".abf"), 
                    sep = "_")
  # check if it exists in the dir
  absent_traces[i, "Exists"] <- abf_name %in% abf_dir
  
  # print(abf_name)
}


absent_traces %>% 
  group_by(Exists) %>% 
  tally()


absent_traces %>% 
  group_by(Condition, Type, Exists) %>% 
  tally() 
```


Finding missing ABFs on the shared drive w/o Microsoft's search
```{r}
# Indexing all the ABFs in my directory on the shared drive is time consumming (~55 minutes over the VPN). It should only be done when an index doesn't exist already of if there's reason to beleave the index is no longer accurate. 
if (!file.exists(here("inst", "extdata", "shared_drive_abf_index.csv"))){
  start_loc <- "S:/Data_Daniel"
  
  tic <- Sys.time()
  all_abfs <- list.files("S:/Data_Daniel", "*.abf", recursive = T)
  toc <- Sys.time()
  print(toc - tic)
  
  write.csv(as.data.frame(all_abfs), file = here("inst", "extdata", "shared_drive_abf_index.csv"))
  rm(list = "all_abfs")
} 
all_abfs_on_shared_drive <- read.csv(here("inst", "extdata", "shared_drive_abf_index.csv"))




abf_names <- str_extract_all(all_abfs_on_shared_drive$all_abfs, "[[^/]]*[[:punct:]]abf$")

all_abfs_on_shared_drive$abf_names <- abf_names

times_matched <- unlist(map(seq(1, nrow(all_abfs_on_shared_drive)), function(i){
  # if it matches at least once the sum will be >0. It should match at most once.
  times.matched <- sum(unlist(map(file_groups$Experiment, function(prefix){
    str_detect(all_abfs_on_shared_drive$abf_names[[i]], paste0(as.character(prefix), "_")) # adding a terminal _ to the search string will prevent 000000a from matching to both 000000 and itself.
  })))

  return(times.matched)
}))

all_abfs_on_shared_drive$times_matched <- times_matched

# Looks like it's working as expected
if (max(times_matched) > 1){
  all_abfs_on_shared_drive[all_abfs_on_shared_drive$times_matched == max(times_matched), ]
}

# matches
all_abfs_match <- all_abfs_on_shared_drive[all_abfs_on_shared_drive$times_matched == 1, ]

all_abfs_match$size  <- NA
all_abfs_match$mtime <- as.POSIXct(NA)
all_abfs_match$ctime <- as.POSIXct(NA)
all_abfs_match$atime <- as.POSIXct(NA)

for (i in seq(1, nrow(all_abfs_match))){
  current_info <- file.info(paste(start_loc, all_abfs_match[i, "all_abfs"], sep = "/") )

  all_abfs_match[i, "size"]  <- current_info$size
  all_abfs_match[i, "mtime"] <- current_info$mtime # file modification
  all_abfs_match[i, "ctime"] <- current_info$ctime # last status change
  all_abfs_match[i, "atime"] <- current_info$atime # last access time
}


all_abfs_match$abf_names <- all_abfs_match$abf_names %>% unlist()


# find duplicated abfs
dupe_abfs <- all_abfs_match %>%
  select(abf_names) %>%
  group_by(abf_names) %>%
  tally() %>%
  filter(n > 1)

all_abfs_match$keep <- F
# Keep all non duplicates
all_abfs_match[!(all_abfs_match$abf_names %in% as.character(dupe_abfs$abf_names)), "keep"] <- T

for (i in seq(1, nrow(dupe_abfs))){
  # if same size, keep oldest
  if (length( unique( all_abfs_match[all_abfs_match$abf_names == as.character(dupe_abfs[i, "abf_names"]), "size"] ) ) == 1){
    # unless they're the same, then keep the first.
    if (length( unique(all_abfs_match[all_abfs_match$abf_names == as.character(dupe_abfs[i, "abf_names"]), "mtime"]) ) == 1){
      all_abfs_match[all_abfs_match$abf_names == as.character(dupe_abfs[i, "abf_names"]), "keep"][1] <- T
    } else {
      warning(paste("Dupe", as.character(i), "has multiple times! Additional logic needed!"))
      #TODO
    }
  } else {
      warning(paste("Dupe", as.character(i), "has unequal file sizes! Additional logic needed!"))
  }
}


target_abfs <- all_abfs_match[all_abfs_match$keep == T & all_abfs_match$size < 13000000, ]
# install.packages("gdata")
target_abfs$size %>% sum() %>% gdata::humanReadable()


local_abfs <- list.files("C:/Users/Daniel/Documents/Trace_Holding/", pattern = ".abf")
target_abfs <- target_abfs[!(target_abfs$abf_names %in% local_abfs), ]


# Copy
for (i in seq(1, nrow(target_abfs))){
  temp_path <- paste(start_loc, as.character(target_abfs[i, "all_abfs"]), sep = "/")
  if (file.exists(temp_path)){
    file.copy(from = temp_path,
              to = "C:/Users/Daniel/Documents/Trace_Holding/")
  } else {
    warning(paste("Item", as.character(i), "does not exist!"))
  }
}



```




```{r}
#TODO for each of these files get the relevant data and place it in an rds with some metadata for merging later
```


## Handling different kinds of files (Proof of principle)
###Load in data (ionic currents)
```{r}
file_list <- list(FI = "190903_0025.abf",
                  EPSP = "190903_0023.abf",
                  GJCC = "190903_0021.abf", 
                  GJVC = "190903_0020.abf",
                  
                  HTK  = "190903_0031.abf",
                  HTKC = "190903_0034.abf",
                  A    = "190903_0030.abf",
                  AC   = "190903_0033.abf")

trace_list <- map(seq_along(file_list), function(i){
  temp <- readABF_as_matrix2(path = paste0(abf_dir_path, 
                                           # "C:/Users/Daniel/Documents/Trace_Holding/", 
                                           file_list[[i]]),
                     channels = "all",
                     relative.time = T) %>%
    as.data.frame() %>% 
    janitor::clean_names(case = "upper_camel") %>% 
    mutate(Sweep = as.factor(Sweep)) %>% 
    group_by(Sweep) %>% 
    mutate(MinTime = min(Time, na.rm = T)) %>% 
    mutate(Time = Time - MinTime) %>% 
    select(-MinTime)
})

names(trace_list) <- names(file_list)
```

### Show all
```{r}
example_plots <- map(trace_list, function(i){
  downsample_data(i, len = 5000) %>%
    ungroup() %>% 
    gather(Ch, Value, c("In4","In7","In9","In12")) %>% 
    mutate(Cell = case_when(Ch %in% c("In4","In7") ~ "Cell A",
                            Ch %in% c("In9","In12") ~ "Cell B",)) %>% 
    mutate(ChType = case_when(Ch %in% c("In4","In9") ~ "mV",
                              Ch %in% c("In7","In12") ~ "nA",)) %>% 
    mutate(Ch = factor(.$Ch, levels = c("In4","In7","In9","In12"))) %>% 
    ggplot(aes(Time, Value, group = Sweep, color = Cell))+
    geom_line()+
    facet_wrap(ChType~Cell, scales = "free_y", ncol = 2)+
    labs(y = "")+
    theme(legend.position = "")+
    scale_color_aaas()
})

plot_grid(plotlist = example_plots)
```


###GJVC
```{r}
## GJVC: get Ig, Ileak====
temp <- trace_list$GJVC
### Setup
i_leak <- temp[seq(1, nrow(temp), by = 1), ] %>%
  filter(Time > 0.75) %>%
  mutate(In4 = as.numeric(In4)) %>%
  mutate(In7 = as.numeric(In7))

i_leak <- i_leak %>% 
  mutate(Segment = ifelse(Time >= 0.8 & Time <= 1.0, "PreStep", 
                          ifelse(Time >= 1.2 & Time <= 1.25, "Step", 
                                 "NA" ))) %>% 
  group_by(Sweep, Segment) %>% 
  mutate(In4Mean = mean(In4, na.rm = T),
         In7Mean = mean(In7, na.rm = T),
         In9Mean = mean(In9, na.rm = T),
         In12Mean = mean(In12, na.rm = T))

### Ig 
i_leak[seq(1, nrow(i_leak), length.out = 1000), ] %>% 
  gather("key", "value", c("In4", "In9")) %>% 
  ggplot(aes(Time, value, color = Segment, group = Sweep))+
  geom_path()+
  facet_grid(.~key)

i_g <- i_leak %>% 
  select(Sweep, Segment, In4Mean, 
         #In7Mean, 
         # In9Mean, 
         In12Mean
         ) %>% 
  filter(Segment != "NA") %>% 
  distinct() %>% 
  pivot_wider(names_from = "Segment", 
              values_from = c("In4Mean", "In12Mean")) %>% 
  mutate(In4Mean_Step = In4Mean_Step - In4Mean_PreStep,
         In12Mean_Step = In12Mean_Step - In12Mean_PreStep) %>% 
  select(Sweep, In4Mean_Step, In12Mean_Step) %>%
  rename(In4Mean = In4Mean_Step, In12Mean = In12Mean_Step) %>% 
  filter(abs(In4Mean) >= 4) 

i_g %>% 
  ggplot(aes(In4Mean, In12Mean))+
  geom_smooth(method = lm)+
  geom_point()

In4_to_In9_Ig <- as.numeric(broom::tidy(lm(In12Mean ~ In4Mean, data = i_g))[2, "estimate"])


### Ileak
i_leak %>% 
  ggplot(aes(Time, In4, color = Segment, group = Sweep))+
  geom_path()

i_leak <- i_leak %>% 
  ungroup() %>%
  select(Sweep, Segment, In4Mean, In7Mean) %>% 
  filter(Segment != "NA") %>% 
  distinct() %>% 
  filter(abs(In4Mean + 60) > 3 )
  
fm <- lm(In4Mean ~ In7Mean, data = i_leak)

In4_R <- as.numeric(broom::tidy(fm)[2, "estimate"])
```

###GJCC
```{r}
## GJCC: get CC, R_C, C, Rin ====
temp <- trace_list$GJCC

temp_plt <- temp[seq(1, nrow(temp), by = 1), ] %>% 
  filter(Sweep == 4) %>%
  mutate(In4 = as.numeric(In4)) %>% 
  mutate(In7 = as.numeric(In7))

# Show what the protocol looks like
plt1 <- temp_plt[seq(1, nrow(temp_plt), length.out = 1000), ] %>% 
  gather(key, value, c("In4", "In9")) %>% 
  ggplot(aes(Time, value, color = key))+
  geom_path()

plt2 <- temp_plt[seq(1, nrow(temp_plt), length.out = 1000), ] %>% 
  gather(key, value, c("In7", "In12")) %>% 
  mutate(key = factor(.$key, levels = c("In7", "In12"))) %>% 
  ggplot(aes(Time, value, color = key))+
  geom_path()

plt1/plt2


# annotate
temp <- temp %>% 
   mutate(Segment = case_when(Time >= 0       & Time <= 0.32820 ~ "A", #"PreStepIn12",
                              Time >= 1.32836 & Time <= 1.82836 ~ "B", #"StepIn12",
                              Time >= 2.57744 & Time <= 3.07744 ~ "C", #"PreStepIn7",
                              Time >= 4.07760 & Time <= 4.57760 ~ "D", #"StepIn7"
                              ))
```
$$r_{11}=\frac{v_1}{i_1}$$
$$r_{12}=\frac{v_2}{i_1}$$
$$r_1= \frac{r_{11}*r_{22} - r_{12}^2}{r_{22} - r_{12}}$$
$$r_c = \frac{r_{11}*r_{22} - r_{12}^2}{r_{12}}$$
```{r}
temp_resist <- temp %>% 
  group_by(Sweep, Segment) %>% 
  filter(!is.na(Segment)) %>% 
  summarise(MeanIn4 = mean(In4, na.rm = T),
            MeanIn7 = mean(In7, na.rm = T),
            MeanIn9 = mean(In9, na.rm = T),
            MeanIn12 = mean(In12, na.rm = T)) %>% 
  pivot_wider(names_from = Segment, values_from = c("MeanIn4", "MeanIn7", "MeanIn9", "MeanIn12")) %>% 
  mutate(In4_CC = MeanIn9_D/MeanIn4_D, #inj in In4
         In4_R11 = MeanIn4_D/MeanIn7_D,
         In4_R12 = MeanIn9_D/MeanIn7_D,

         
         In9_CC = MeanIn4_B/MeanIn9_B, #inj in In9
         In9_R11 = MeanIn9_B/MeanIn12_B,
         In9_R12 = MeanIn4_B/MeanIn12_B
         ) %>% 
  mutate(mean_R12 = (In4_R12+In9_R12)/2) %>% 
  mutate(In4_R1 = ((In4_R11*In9_R11) - (mean_R12^2)) / (In9_R11-mean_R12),
         In4_Rc = ((In4_R11*In9_R11) - (mean_R12^2)) / (mean_R12),
         
         In9_R1 = ((In9_R11*In4_R11) - (mean_R12^2)) / (In4_R11-mean_R12),
         In9_Rc = ((In9_R11*In4_R11) - (mean_R12^2)) / (mean_R12)
         ) %>% select(starts_with("In"))
```

```{r}
# V_rest
temp_rmp <- temp %>% 
  filter(Segment == "C") %>% 
  group_by(Sweep) %>% 
  summarise(In4_Vrest = min(In4, na.rm = T),
            In9_Vrest = min(In9, na.rm = T))
```


```{r}
# Tau
temp <- temp %>% 
   mutate(Segment = case_when(Time >= 3.07744 & Time <= 4.57760 ~ "In4Step", #"PreStepIn7",
                              Time >= 0.32820 & Time <= 1.82836 ~ "In9Step", #"StepIn7"
                              ))  

plt1 <- 
temp[seq(1, nrow(temp), length.out = 1000), ] %>% 
  gather(Key, Value, c("In4", "In9")) %>% 
  ggplot(aes(Time, Value, color = Segment, group = interaction(Key, Sweep)))+
  geom_path()

plt2 <- 
temp[seq(1, nrow(temp), length.out = 1000), ] %>% 
  ungroup() %>% 
  gather(key, value, c("In7", "In12")) %>% 
  mutate(key = factor(.$key, levels = c("In7", "In12"))) %>% 
  ggplot(aes(Time, value, color = Segment, group = interaction(key, Sweep)))+
  geom_path()

plt1/plt2

### test minpack.lm ####
# install.packages("minpack.lm")


temp_in9 <- temp %>% 
  filter(Segment == "In9Step") %>% 
  mutate(Time = Time - min(Time, na.rm = T))

test_fits <- map(unique(temp_in9$Sweep), function(i){
  fit_tau_1term_exp(df = filter(temp_in9, Sweep == i),
                    IV = "Time",
                    DV = "In9")  
})

test_fits_plts <- map(seq_along(test_fits), function(i){
  ggplot()+
    geom_line(data = as.data.frame(test_fits[[i]]$check_fit), aes(x = Time, y = Fit), color = "firebrick")+
    geom_line(data = as.data.frame(test_fits[[i]]$check_fit), aes(x = Time, y = In9), alpha = 0.8)+
    labs(subtitle = paste("tau =", as.character(
      round(test_fits[[i]]$fit[2, 2], digits = 3)
      )))
})

cowplot::plot_grid(plotlist = test_fits_plts)
```

###FI
```{r}
temp <- trace_list$FI

downsample_data <- function(df = temp, 
                            len = 5000){
  return(df[seq(1, nrow(df), length.out = len), ])
  }


downsample_data(df = temp, len = 5000) %>% 
  gather(key, value, c("In9", "In12")) %>% 
  ungroup() %>% 
  mutate(key = factor(.$key, levels = c("In9", "In12"))) %>% 
  ggplot(aes(Time, value, group = Sweep))+
  geom_line()+
  facet_wrap(key~., scales = "free_y", ncol = 1)



#r11 == ~15.3
#r1 == ~17.9

place_params_for_predict_voltage_trace(tau = 19.9, 
                                       Rin = 15.3)

# place_data_for_predict_voltage_trace(input.df = temp[temp$Sweep == 10, ], 
#                                      Time.ch = "Time", 
#                                      Inj.ch = "In12")
# 
# run_predict_voltage_trace_py()
# 
# predicted_response <- retrieve_predicted_voltage()

predicted_response_list <- map(1:11, function(i){
  place_data_for_predict_voltage_trace(input.df = temp[temp$Sweep == i, ], 
                                       Time.ch = "Time", 
                                       Inj.ch = "In12")
  
  run_predict_voltage_trace_py()
  
  predicted_response <- retrieve_predicted_voltage()
  return(predicted_response)
})


my_plts <- map(
  seq_along(predicted_response_list),
  function(i){
    ggplot()+
      geom_line(data = predicted_response_list[[i]], aes(Time, predicted-56.5))+
      geom_line(data = temp[temp$Sweep == i, ], aes(Time, In9), color = "red")+
      labs(x = "Seconds", y = "mV")+
      coord_cartesian(y = c(-150, +120))
  })

# cowplot::plot_grid(plotlist = my_plts)


my_plts[[11]] / my_plts[[11 - 2]] / my_plts[[1 + 2]] / my_plts[[1]]
```

###EPSP
(epsp) How could we slice up the trace? 
```{r}
## Here's the stimulus used in the protocol ====
# sweep duration should be 19.687 seconds
epsp_stim <- readABF_as_matrix(here("inst", "extdata", "epsp_stim_files", "08 current injection.abf"),
                  channels = "Axo1I2")
epsp_stim <- as_tibble(epsp_stim) %>%
  mutate(Time = Time - min(Time, na.rm = T)) %>%
  rename(Stim = Axo1I2)


shading_annotations <- data.frame(
  starts = c(0.40,
             4.87,
             10.74,
             16.74),
  next_start = c(4.87,
                 10.74,
                 16.74,
                 19.685),
  equal_len = c(0.40,
                4.87,
                10.74,
                16.74) + 2.945,
  on_end = c(2,
             6.17,
             12.54, 
             18.5),
  equal_on = c(0.40,
               4.87,
               10.74,
               16.74) + 1.30
)

ggplot()+
  geom_vline(xintercept = c(shading_annotations$starts, shading_annotations$equal_len, shading_annotations$next_start, shading_annotations$equal_on), color = "gray")+
    geom_path(data = epsp_stim, aes(Time, Stim+1.5))+
  geom_rect(data = shading_annotations, aes(xmin = starts, xmax = next_start, ymin = 0, ymax = 0.5), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[1], color = RColorBrewer::brewer.pal(3, "Set1")[1])+
  geom_rect(data = shading_annotations, aes(xmin = starts, xmax = equal_len, ymin = -0.5, ymax = 0), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[1], color = RColorBrewer::brewer.pal(3, "Set1")[1])+
  geom_rect(data = shading_annotations, aes(xmin = starts, xmax = on_end, ymin = -1, ymax = -0.5), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[2], color = RColorBrewer::brewer.pal(3, "Set1")[2])+
  geom_rect(data = shading_annotations, aes(xmin = starts, xmax = equal_on, ymin = -1.5, ymax = -1), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[2], color = RColorBrewer::brewer.pal(3, "Set1")[2])+
  theme_classic()+
  geom_vline(xintercept = 12.54)+
  ylim(-1.5, 9.5)+
  labs(title = "Ways to Segement EPSP Stim")
```



```{r}
temp <- trace_list$EPSP




downsample_data(df = temp, len = 5000) %>% 
  gather(key, value, c("In9", "In12")) %>% 
  ungroup() %>% 
  mutate(key = factor(.$key, levels = c("In9", "In12"))) %>% 
  ggplot(aes(Time, value, group = Sweep))+
  geom_line()+
  facet_wrap(key~., scales = "free_y", ncol = 1)



#r11 == ~15.3
#r1 == ~17.9

place_params_for_predict_voltage_trace(tau = 19.9, 
                                       Rin = 15.3)

i=1
place_data_for_predict_voltage_trace(input.df = temp[temp$Sweep == i, ], 
                                       Time.ch = "Time", 
                                       Inj.ch = "In12")
  
run_predict_voltage_trace_py()
  
predicted_response <- retrieve_predicted_voltage()


ggplot()+
  geom_line(data = temp[temp$Sweep == i, ], aes(Time, In9), color = "red")+
  geom_line(data = predicted_response, aes(Time, predicted-68), color = "black")+
  labs(x = "Seconds", y = "mV")
      

  
```


#### Proof of principle: Contrasting simulaiton with LIF to regression and VIR
```{r}
M <- readABF_as_matrix2(path = 
                          paste0(abf_dir_path, "190915_0019.abf"),
                          # "C:/Users/Daniel/Documents/Trace_Holding/190915_0019.abf", #190924_0022.abf",
                   channels = "all",
                   relative.time = T)

temp <- as_tibble(M) %>% 
  janitor::clean_names(case = "upper_camel") %>% 
  mutate(Sweep = as.factor(Sweep)) %>% 
  group_by(Sweep) %>% 
  mutate(MinTime = min(Time, na.rm = T)) %>% 
  mutate(Time = Time - MinTime) %>% 
  filter(Sweep == 1) #%>% 
  # mutate(In7 = rollmean(In7, 17, fill = "extend"))


# temp %>% 
#   ggplot(aes(In7, In4))+
#   geom_path()+
#   geom_smooth(method = lm, fullrange = T, linetype = "dashed")+
#   theme_minimal()

fm <- lm(In4 ~ In7, data = temp)
fm_newdata <- data.frame(In4 = NA, 
                         In7 = temp$In7,
                         Time = temp$Time,
                         sweep = temp$Sweep)
fm_newdata$In4 <- predict(fm, newdata = fm_newdata)


temp <- temp[, c("Time", "In7", "In4")]

temp <- full_join(temp, rename(fm_newdata, lm = In4))

#TODO add in Rin / Tau programmatically

# 190915_0017 #-6nA
# 190915_0019 #epsp
# LC 5
# 
# Est. Rin: 51.21/6 = 8.535 MOhm
# Est. Taus: 
# Tau1			Tau2
# 58.482597351074219	11.020112037658691
# 21.417860031127930	N/A
place_params_for_predict_voltage_trace(tau = 21.417860031127930, Rin = 8.535)

place_data_for_predict_voltage_trace(input.df = temp, Time.ch = "Time", Inj.ch = "In7")

run_predict_voltage_trace_py()

predicted_response <- retrieve_predicted_voltage()



t1 <- temp
t2 <- as_tibble(predicted_response)

# # Feels hacky, but there seems to be a float rounding error here. E.g. Time 0.000199 != 0.0002
# t1$ms <- round(t1$Time * 10000)#/10000
# t2$ms <- round(t2$Time * 10000)#/10000
# 
# t1 <- t1 %>% dplyr::select(-Time)
# t2 <- t2 %>% dplyr::select(-Time)
# 
# t3 <- full_join(t1, t2) 

t3 <- cbind(t1, t2[, "predicted"]) 


t3$Vinf <- (t3$In7*8.535)-49.5
t3$predicted <- t3$predicted-49.5




plt_left <- 
t3 %>% gather(key = "Method", value = "mV", c("lm", "Vinf", "predicted")) %>% 
  ggplot(aes(Time, mV, color = Method))+
  geom_path()+
  geom_path(data = t3, aes(Time, In4), color = "black")+
  theme_minimal()+
  theme(legend.position = "")+
  facet_grid(Method~.)




t3_subtracted <- t3
t3_subtracted$lm <- t3_subtracted$In4 - t3_subtracted$lm
t3_subtracted$Vinf <- t3_subtracted$In4 - t3_subtracted$Vinf
t3_subtracted$predicted <- t3_subtracted$In4 - t3_subtracted$predicted
t3_subtracted$In4 <- t3_subtracted$In4 - -49.5

plt_mid <-
t3_subtracted %>% gather(key = "Method", value = "mV", c("lm", "Vinf", "predicted")) %>%
  ggplot(aes(Time, mV, color = Method))+
  geom_path()+ #TODO It seems there is a nA that's causing early termination here?
  geom_path(data = t3_subtracted, aes(Time, In4), color = "black")+
  theme_minimal()+
  theme(legend.position = "")+
  facet_grid(Method~.)

plt_right <- 
t3 %>% gather(key = "Method", value = "mV", c("lm", "Vinf", "predicted")) %>% 
  ggplot(aes(In4, mV, color = Method))+
  geom_path()+
  geom_abline(intercept = 0, slope = 1)+
  theme_minimal()+
  theme(legend.position = "")+
  facet_grid(Method~.)
  

(plt_left | plt_mid | plt_right) + plot_layout(widths = c(3, 3, 2))

```


###HTK/A
#### </ begin copy from 02ExtractEphysData.Rmd >

---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# from TracesToTables.Rmd



```{r}
library(readABF)
library(here)
library(tidyverse)
```


```{r}
# Really just a wrapper for loadABF()
# readABF_as_matrix <- function(
#   path = "S:/Data_Daniel/ActiveProjects/181015_electrical_synapses_voltage_modification/experiments/180117_inverted_wave/raw/180205_0061.abf",
#   channels = c("IN 4", "IN 9")){
# 
#   trace <- readABF::readABF(file = path)
# 
#   start.time <- trace$header$recTime[1]
#   end.time <- trace$header$recTime[2]
#   obs <- nrow(trace$data[[1]])
# 
#   temp <- trace$data[[1]][, (trace$channelNames %in% channels)]
#   temp <- as.matrix(temp)
# 
#   colnames(temp) <- trace$channelNames[trace$channelNames %in% channels]
#   temp <- cbind(temp, Time = seq(from = start.time,
#                                  to = end.time,
#                                  length.out = obs))
# 
#   return(temp)
# }

```



```{r}
# Set here not working as expected. Does it need to go in here?
# set_here(path = "/Volumes/schulzlab/Data_Daniel/ActiveProjects/mRNA24hLCAcquisition", verbose = TRUE)
# 
# #rin path
# use.path <- here(#"/Volumes/schulzlab/Data_Daniel/ActiveProjects/mRNA24hLCAcquisition/"
#   "1h_TEA",
#   "190308_0028.abf")
# 
# # list.files("/Volumes/schulzlab/Data_Daniel/ActiveProjects/mRNA24hLCAcquisition/1h_TEA")
#    

# path.base <- "/Volumes/schulzlab/Data_Daniel/ActiveProjects/mRNA24hLCAcquisition/1h_TEA/"
path.base <- "S:/Data_Daniel/ActiveProjects/mRNA24hLCAcquisition/1h_TEA/"

file.free <- "190306_0047.abf"

# file.rin <- "190306_0052.abf"

file.tecc.gj <- "190306_0052.abf"

file.epsp <- "190306_0053.abf"
file.fi <- "190306_0056.abf"

file.tevc.gj <- "190306_0057.abf"
file.htk <- "190306_0060.abf"
file.a <- "190306_0061.abf"
file.htk.c <- "190306_0062.abf"
file.a.c <- "190306_0063.abf"


# trace <- readABF(paste0(path.base, file.htk))
# 
# $ channelNames         : chr [1:4] "IN 4" "IN 7" "IN 9" "IN 12"
#  $ data                 :List of 11
# 
# plot(trace$data[[1]][, 1])
# plot(trace$data[[2]][, 1])

readABF_as_matrix <- function(
  path = "S:/Data_Daniel/ActiveProjects/181015_electrical_synapses_voltage_modification/experiments/180117_inverted_wave/raw/180205_0061.abf"#,
  # channels = c("IN 4", "IN 9")
  ){

  # path = paste0(path.base, file.htk)
  # channels = c("IN 4", "IN 9")
  
  trace <- readABF::readABF(file = path)

  start.time <- trace$header$recTime[1]
  end.time <- trace$header$recTime[2]
  
  for (i in seq_along(trace$data)){
    # print(i)
  
  
  # obs <- nrow(trace$data[[i]])

  temp <- trace$data[[i]]#[, (trace$channelNames %in% channels)]
  temp <- as.matrix(temp)

  colnames(temp) <- trace$channelNames#[trace$channelNames %in% channels]
  temp <- cbind(temp, Sweep = rep(i, times = nrow(temp)))
  # temp <- cbind(temp, Time = seq(from = start.time,
  #                                to = end.time,
  #                                length.out = obs))
  if (i == 1){
    output <- temp
  } else {
    output <- rbind(output, temp)
  }
  }
  
  # Moved here to account for multi sweep protocols
    output <- cbind(output, Time = seq(from = start.time,
                                 to = end.time,
                                 length.out = nrow(output)))
  
  return(output)
}
```

# Current clamp protocols

## Rin

## Fi
Needs to 
  1. get voltage traces
  2. get AUC


```{r}
```



## EPSP mimic
Needs to 
  1. get voltage traces
  2. correlate between them
  3. correlate burst only portion?

# Voltage Clamp Protocols

## TEVC GJ
Needs to 
  1. get step values
  2. calculate ig via spray and bennet
  3. save control potential as well
```{r}
trace <-
readABF_as_matrix(
  path = paste0(path.base, file.tevc.gj)
  )

trace <- janitor::clean_names(as.data.frame(trace), case = "big_camel")
trace <- trace %>% group_by(Sweep) %>% mutate(RelativeTime = Time - min(Time))


ggplot(trace, aes(x = RelativeTime, y = In4, group = Sweep))+
  geom_line()+
  ylim(-100, 100)

plot(`In7` ~ RelativeTime, type = "l", data = trace)

```

```{r}
trace = trace
v1 = "In4"
i1 = "In7"
v2 = "In9"
i2 = "In12"
window.start = 0.4
window.stop = 0.5
Sweep = "Sweep"

#Spray, Harris, and Bennett 1979 states:
#"This transjunctional current (Ij) injected into the second cell gives a direct measure of junctional conductance when dividded by the the magnitude of the step change in transjunctional voltage"

 # trace = trace.htk,
 # 
 #  RelativeTime = "RelativeTime",
 #  i.ch = "In7",
 #  v.ch = "In4"

```




```{r infer mv steps 2, }

df.tevc_gj <- df.tevc_gj[!is.na(df.tevc_gj$IN4_mean), ]
df.tevc_gj <- df.tevc_gj[!is.na(df.tevc_gj$IN9_mean), ]

df.tevc_gj$inj_in_IN4 <- abs(df.tevc_gj$IN4_mean) > abs(df.tevc_gj$IN9_mean) #So we can appropriately apply the formula

df.tevc_gj$diff_in_means <- abs(df.tevc_gj$IN4_mean) - abs(df.tevc_gj$IN9_mean) #so we can drop the ones where both are held at 60mV
df.tevc_gj <- df.tevc_gj[abs(df.tevc_gj$diff_in_means) > 6,] #drop the 0mv step and the +/-5mV steps

#Apply Spray, Harris, and Bennett's calculation
df.tevc_gj$gj <- 0
df.tevc_gj[df.tevc_gj$inj_in_IN4 == FALSE, "gj"] <- df.tevc_gj[df.tevc_gj$inj_in_IN4 == FALSE, "IN7_mean"] / df.tevc_gj[df.tevc_gj$inj_in_IN4 == FALSE, "IN9_mean"]
df.tevc_gj[df.tevc_gj$inj_in_IN4 == TRUE, "gj"] <- df.tevc_gj[df.tevc_gj$inj_in_IN4 == TRUE, "IN12_mean"] / df.tevc_gj[df.tevc_gj$inj_in_IN4 == TRUE, "IN4_mean"]


#Add this column for later
df.tevc_gj[df.tevc_gj$inj_in_IN4 == TRUE, "Inj_Cell"] <- df.tevc_gj[df.tevc_gj$inj_in_IN4 == TRUE, "IN4"]
df.tevc_gj[df.tevc_gj$inj_in_IN4 == FALSE, "Inj_Cell"] <- df.tevc_gj[df.tevc_gj$inj_in_IN4 == FALSE, "IN9"]
```

```{r add directionality}
df.tevc_gj[df.tevc_gj$Inj_Cell == "LC4", "Direction"] <- "LC4 -> LC5"
df.tevc_gj[df.tevc_gj$Inj_Cell == "LC5", "Direction"] <- "LC5 -> LC4"

df.tevc_gj[, "interact"] <- interaction(df.tevc_gj$Experiment, df.tevc_gj$Direction)
```


## IHTK
  1. plot to get user to say which to drop (if there is no file with this info) # done
  2. smooth # done
  3. get peak values # done
4. get sustained values
  5. subtract off leak # done
  6. report values and leak # done
```{r}
trace <-
readABF_as_matrix(
  path = paste0(path.base, file.htk)
  )

trace <- janitor::clean_names(as.data.frame(trace), case = "big_camel")
trace <- trace %>% group_by(Sweep) %>% mutate(RelativeTime = Time - min(Time)) %>%
  ungroup()
trace <- trace %>% group_by(Sweep) %>% 
  mutate(In4  = zoo::rollmean(In4,  k = 7, fill = NA)) %>% 
  mutate(In7  = zoo::rollmean(In7,  k = 7, fill = NA)) %>% 
  mutate(In9  = zoo::rollmean(In9,  k = 7, fill = NA)) %>% 
  mutate(In12 = zoo::rollmean(In12, k = 7, fill = NA)) %>%
  ungroup()

# gather(trace, channel, mV, c("In4", "In9")) %>% ggplot(aes(RelativeTime, mV, color = channel, group = Sweep))+geom_line()+xlim(0.25, 0.3)
# 
# gather(trace, channel, mV, c("In7", "In12")) %>% ggplot(aes(RelativeTime, mV, color = channel, group = Sweep))+geom_line()+xlim(0.27, 0.28)

trace <- trace %>% ungroup()

peaks <- trace %>% group_by(Sweep) %>% filter(RelativeTime > 0.27 & RelativeTime < 0.28) %>% summarise(max.val = max(In7)) %>%
  ungroup()


peaks$mV <- NA
for (i in seq(1, nrow(peaks), 1)){
  Sweep <- peaks[i, "Sweep"] %>% as.numeric()
  
  peaks[i, "mV"] <- trace[trace$Sweep == Sweep &
                            trace$RelativeTime > 0.27 &
                            trace$RelativeTime < 0.28 &
                            trace$In7 == as.numeric(peaks[peaks$Sweep == Sweep, "max.val"]), "In4"] %>% as.numeric() %>% mean(na.rm = T)
}



fm <- lm(max.val ~ mV, filter(peaks, mV < -41))

peaks <- peaks %>% mutate(leak = predict(object = fm, newdata = peaks))
peaks <- peaks %>% mutate(leak.sub = max.val - leak)


ggplot(peaks)+
  # geom_smooth(method = "lm")+
  lemon::geom_pointline(aes(x = mV, max.val))+
  lemon::geom_pointline(aes(x = mV, leak), color = "red")+
  lemon::geom_pointline(aes(x = mV, leak.sub), color = "blue")
  

# go through sweeps plotting each and asking if the user wants to keep each one. Then return a df with the ones to keep
checkSweeps <- function(
  trace = trace,
  v.ch = "In4",
i.ch = "In7",
t.ch = "RelativeTime"
){
  use.sweeps <- data.frame(Sweep = unique(trace$Sweep),
                         Use = rep(F, times = length(unique(trace$Sweep))))
trace <- as.data.frame(trace)
for (i in seq_along(unique(trace$Sweep))){
  # use.sweep <- F
  # par(mfrow = c(1, 2))
  par(mfrow = c(2, 1))
  # with({
  plot(trace[trace$Sweep == i, v.ch] ~ trace[trace$Sweep == i, t.ch], 
       type = "l", 
       xlab="", ylab="",
       main = paste("Sweep",as.character(i)))
  plot(trace[trace$Sweep == i, i.ch] ~ trace[trace$Sweep == i, t.ch], 
       type = "l",
       xlab="", ylab="")
  # })
  
  for (j in 1:3){
    print(paste0("Retain sweep ", as.character(i),"?"))
    print("T/F or E to Exit")
    
    user.input <- readline(prompt = ">")
    
    
    if (user.input == "E" | user.input == "e"){
      break()
      
    } else if (user.input == "T" | user.input == "t"){
      use.sweeps[use.sweeps$Sweep == i, "Use"] <- T
      break()
      
    } else if (user.input == "F" | user.input == "f"){
      use.sweeps[use.sweeps$Sweep == i, "Use"] <- F
      break()
      
    } else {
      print(paste("Response not recognized.", as.character(j), "attempts remain."))
    }
    
    
  }
  if (user.input == "E" | user.input == "e"){
    break()
  }
}
return(use.sweeps)
}



```


## IA
  1. plot to get user to say which to drop (if there is no file with this info)
  2. subract user supplied IHTK (don't smooth or filter, but drop any traces that aren't present for both)
  3. smooth
  4. get peak values
  5. get sustained values
 
```{r}
trace.htk <-
readABF_as_matrix(
  path = paste0(path.base, file.htk)
  )

trace.htk <- janitor::clean_names(as.data.frame(trace.htk), case = "big_camel")
trace.htk <- trace.htk %>% group_by(Sweep) %>% mutate(RelativeTime = Time - min(Time)) %>%
  ungroup()
trace.htk <- trace.htk %>% group_by(Sweep) %>% 
  mutate(In4  = zoo::rollmean(In4,  k = 7, fill = NA)) %>% 
  mutate(In7  = zoo::rollmean(In7,  k = 7, fill = NA)) %>% 
  mutate(In9  = zoo::rollmean(In9,  k = 7, fill = NA)) %>% 
  mutate(In12 = zoo::rollmean(In12, k = 7, fill = NA)) %>%
  ungroup()



trace.a <-
readABF_as_matrix(
  path = paste0(path.base, file.a)
  )

trace.a <- janitor::clean_names(as.data.frame(trace.a), case = "big_camel")
trace.a <- trace.a %>% group_by(Sweep) %>% mutate(RelativeTime = Time - min(Time)) %>%
  ungroup()
trace.a <- trace.a %>% group_by(Sweep) %>% 
  mutate(In4  = zoo::rollmean(In4,  k = 7, fill = NA)) %>% 
  mutate(In7  = zoo::rollmean(In7,  k = 7, fill = NA)) %>% 
  mutate(In9  = zoo::rollmean(In9,  k = 7, fill = NA)) %>% 
  mutate(In12 = zoo::rollmean(In12, k = 7, fill = NA)) %>%
  ungroup()

# subtract traces
subtract_traces <- function(
  htk.data = trace.htk,
  a.data = trace.a,
  current.chs = c("In7", "In12")
){
  # htk.data = trace.htk.data %>% head()
  # a.data = trace.a %>% head()
  # Time = "Time"
  # rel.time = "RelativeTime"
  # Sweep = "Sweep"
  # current.chs = c("In7", "In12")
  
  htk.data <- as.data.frame(htk.data)
  a.data <- as.data.frame(a.data)
  
  if (length(htk.data[[current.chs[1]]]) != length(a.data[[current.chs[1]]])){
    warning("Dataframe nrows are not equal!\nReturning nothing")
    return()
  } else {
    for (i in seq_along(current.chs)){
      a.data[[current.chs[i]]] <- a.data[[current.chs[i]]] - htk.data[[current.chs[i]]]
    }
    return(a.data)
  }
}



trace.a.ls <- subtract_traces(
  htk.data = trace.htk,
  a.data = trace.a,
  current.chs = c("In7", "In12")
)


# Get max for a time window
find_local_max <- function(
  trace = trace.a.ls,
  window.start = 0.27,
  window.stop  = 0.28,
  Sweep = "Sweep",
  RelativeTime = "RelativeTime",
  i.ch = "In7",
  v.ch = "In4"
){
  # trace = trace.a.ls
  # window.start = 0.27
  # window.stop  = 0.28
  # Sweep = "Sweep"
  # RelativeTime = "RelativeTime"
  # i.ch = "In7"
  # v.ch = "In4"
  
  peaks <- trace %>% 
    group_by(Sweep) %>% 
    filter(RelativeTime > window.start & RelativeTime < window.stop) %>% 
    summarise(max.val = max(get(i.ch))) %>% 
    ungroup()
  
  peaks$mV <- NA
  for (i in seq(1, nrow(peaks), 1)){
    Sweep1 <- peaks[i, Sweep] %>% as.numeric()
    
    peaks[i, "mV"] <- trace[trace$Sweep == Sweep1 &
                              trace$RelativeTime > window.start &
                              trace$RelativeTime < window.stop &
                              trace[[i.ch]] == as.numeric(peaks[peaks$Sweep == Sweep1, "max.val"]), v.ch] %>% as.numeric() %>% mean(na.rm = T)
  }
  
  return(peaks)
}



max.a.ls <- 
find_local_max(
  trace = trace.a.ls,
  window.start = 0.27,
  window.stop  = 0.28,
  Sweep = "Sweep",
  RelativeTime = "RelativeTime",
  i.ch = "In7",
  v.ch = "In4"
)



### comparisons
max.a <- 
find_local_max(
  trace = trace.a,
  window.start = 0.27,
  window.stop  = 0.28,
  Sweep = "Sweep",
  RelativeTime = "RelativeTime",
  i.ch = "In7",
  v.ch = "In4"
)


max.htk <- 
find_local_max(
  trace = trace.htk,
  window.start = 0.27,
  window.stop  = 0.28,
  Sweep = "Sweep",
  RelativeTime = "RelativeTime",
  i.ch = "In7",
  v.ch = "In4"
)

# Leak subtract max values
subtract_leak <- function(peaks = max.htk, # output from find_local_max
                          min.mV = -81,
                          max.mV = -39){
  # peaks = max.htk # output from find_local_max
  # min.mV = -81
  # max.mV = -39
  fm <- lm(max.val ~ mV, filter(peaks, mV <= max.mV & mV >= min.mV))
  
  peaks <- peaks %>% mutate(leak = predict(object = fm, newdata = peaks))
  peaks <- peaks %>% mutate(leak.sub = max.val - leak)
  return(peaks)
}


max.htk.ls <- subtract_leak(peaks = max.htk, # output from find_local_max
                            min.mV = -81,
                            max.mV = -39)


ggplot()+
  lemon::geom_pointline(data = max.htk, aes(x = mV, max.val), color = "#fc9272")+
  lemon::geom_pointline(data = max.htk.ls, aes(x = mV, leak.sub), color = "#de2d26")+
  lemon::geom_pointline(data = max.a, aes(x = mV, max.val), color = "#9ecae1")+
  lemon::geom_pointline(data = max.a.ls, aes(x = mV, max.val), color = "#3182bd")



```


# Assess Data
```{r}
metadata <- read.csv("./inst/extdata/MetadataEphys.csv")

metadata %>% 
  gather(Channel, Cell, c("In4", "In9")) %>% 
  select(c("Experiment", "Condition", "Cell")) %>% 
  group_by(Condition) %>% 
  unique() %>% 
  tally() %>% 
  ungroup()
```



```{r}
# write file name from spreadsheet
mk_filename <- function(
  metadata.file = metadata,
  use.row = 1){
  filename <- paste0(
    as.character(
      metadata.file[use.row, "Experiment"]
    ),
    "_",
    paste0(
      rep("0", (4-length(metadata.file[use.row, "Recording"]))), collapse = ""),
    as.character(
      metadata.file[1, "Recording"]
    ),
    ".abf"
  )
  return(filename)
}


# select a prep and check that the file type isn't nonsensical
prep_abf <- function(
  file.name = "190306_0063.abf", #mk_filename()
  file.type = "ac" #metadata[row.num, "Type"] 
){
  M <- readABF_as_matrix(here("inst", "extdata", "all_traces", file.name)) %>% 
    # as.data.table() %>% 
    as.data.frame() %>% 
    janitor::clean_names(., case = "big_camel")
  
  # This is here to get rid of an unknown/uninitialized col warning
  M <- M[, names(M) ]
  
  # if metadata says its...
  if (file.type %in% c("gf")){
    # [1] "IN 4"  "IN 9"  "IN 14" "Sweep" "Time" # gap free
    #TODO
  } else if (file.type %in% c("tecc.gj")){
    # [1] "IN 4"  "IN 6"  "IN 7"  "IN 9"  "IN 11" "IN 12" "Sweep" "Time" # tecc.gj
    #TODO
  } else if (file.type %in% c("epsp")){
    # [1] "IN 4"  "IN 7"  "IN 9"  "IN 12" "IN 14" "Sweep" "Time" # epsp
    #TODO
  } else if (file.type %in% c("fi")){
    # [1] "IN 4"  "IN 6"  "IN 7"  "IN 9"  "IN 11" "IN 12" "IN 14" "Sweep" "Time" # fi
    #TODO
  } else if (file.type %in% c("htk", "a", "htkc", "ac")){
    # [1] "IN 4"  "IN 7"  "IN 9"  "IN 12" "Sweep" "Time" # tevc.gj
    # [1] "IN 4"  "IN 7"  "IN 9"  "IN 12" "Sweep" "Time" # htk
    # [1] "IN 4"  "IN 7"  "IN 9"  "IN 12" "Sweep" "Time" # a
    # [1] "IN 4"  "IN 7"  "IN 9"  "IN 12" "Sweep" "Time" # htkc
    # [1] "IN 4"  "IN 7"  "IN 9"  "IN 12" "Sweep" "Time" # ac
    if (mean(names(M) %in% c("In4", "In7", "In9", "In12", "Sweep", "Time")) != 1){
      warning(
        paste(as.character(file.name), 
              as.character(file.type), 
              "NAMES EXPECTED:", "In4", "In7", "In9", "In12", "Sweep", "Time", 
              "NAMES FOUND:", paste(names(M), collapse = " ")
        )
      )
    } 
  } else {
    warning(paste("file type", as.character(file.type), "not recognized!"))
  }
  return(M)
}


mk_rel_time <- function(df = Trace){
  df <- df %>% 
    group_by(Sweep) %>% 
    mutate(RelativeTime = Time - min(Time)) %>%
    ungroup()
  return(as.data.frame(df))
}

rollmean_tevc <- function(df = Trace,
                          use.k = 7,
                          use.fill = NA){
  df <- df %>% group_by(Sweep) %>% 
  mutate(In4  = zoo::rollmean(In4,  k = use.k, fill = use.fill)) %>% 
  mutate(In7  = zoo::rollmean(In7,  k = use.k, fill = use.fill)) %>% 
  mutate(In9  = zoo::rollmean(In9,  k = use.k, fill = use.fill)) %>% 
  mutate(In12 = zoo::rollmean(In12, k = use.k, fill = use.fill)) %>%
  ungroup()
  return(as.data.frame(df))
}

process_htk <- function(use.nrow = 5,
                        use.metadata = htks,
                        use.window.start = 0.27,
                        use.window.stop = 0.28,
                        leak.min.mV = -81,
                        leak.max.mV = -39){
  
  M <- mk_filename(
    metadata.file = use.metadata,
    use.row = use.nrow
  ) %>% prep_abf(
    file.name = .,
    file.type = use.metadata[use.nrow, "Type"]
  ) %>% 
    mk_rel_time(df = .) 
    rollmean_tevc(
    df = .,
    use.k = 7,
    use.fill = NA
  )
  
  # is there data in the In4/In7 pair?
  if (use.metadata %>% slice(use.nrow) %>% select(In4) == ""){
    # do nothing
    In4.data <- data.frame()
    
  } else {
    In4.data <- 
      find_local_max(
        trace = M,
        window.start = use.window.start,
        window.stop  = use.window.stop,
        Sweep = "Sweep",
        RelativeTime = "RelativeTime",
        i.ch = "In7",
        v.ch = "In4"
      ) %>% 
      subtract_leak(peaks = ., # output from find_local_max
                    min.mV = leak.min.mV,
                    max.mV = leak.max.mV) %>% 
      mutate(Cell = use.metadata %>% slice(use.nrow) %>% select(In4) %>% as.character())
    
  }
  # is there data in the In9/In12 pair?
  if (use.metadata %>% slice(use.nrow) %>% select(In9) == ""){
    # do nothing
    In9.data <- data.frame()
    
  } else {
    In9.data <- 
      find_local_max(
        trace = M,
        window.start = use.window.start,
        window.stop  = use.window.stop,
        Sweep = "Sweep",
        RelativeTime = "RelativeTime",
        i.ch = "In12",
        v.ch = "In9"
      ) %>% 
      subtract_leak(peaks = ., # output from find_local_max
                    min.mV = leak.min.mV,
                    max.mV = leak.max.mV) %>% 
      mutate(Cell = use.metadata %>% slice(use.nrow) %>% select(In9) %>% as.character())
    
  }
  
  # Since we set these as an empty data.frame if there is no cell we can rbind without fear of a problem.
  return(rbind(In4.data, In9.data))
}
```


```{r}
#find all htks
htks <- metadata %>% 
  filter((Pharm == "none" | Pharm == "tea") & Type == "htk") %>% 
  select(Experiment, Recording, Type, Condition, In4, In9) %>% 
  arrange(Condition)

# row 5 is not htk. has only
# In4       In9         In14 Sweep     Time

for (i in 1:NROW(htks)){
  plt <- process_htk(use.nrow = 8,
                     use.metadata = htks,
                     use.window.start = 0.27,
                     use.window.stop = 0.28,
                     leak.min.mV = -81,
                     leak.max.mV = -39) %>% 
    gather(type, i, c("max.val", "leak", "leak.sub")) %>% 
    ggplot(aes(x = mV, y = i, group = type, color = type))+
    geom_line()+
    geom_point()+
    facet_grid(.~Cell)+
    theme_dark()+
    labs(title = as.character(i)) 
  plot(plt)
}




max.htk.ls <- subtract_leak(peaks = max.htk, # output from find_local_max
                            min.mV = -81,
                            max.mV = -39)
```


## Check vs metadata

## 



#### </ end >
## Extend to batch processing
```{r}

#TODO
# works, now we need to automate the process. Maybe have a datasheet that we pull rin, tau from. 

to_use <- full_join(file_groups, files_df) %>% filter(Type == "epsp" & Group %in% c("Baseline", "compensated", "Delayed"))


ephys_meta <- readxl::read_excel(here("inst", "extdata", "ManualDataEphys02.xlsx"), sheet = "MetadataEphys") #"TECC", "TEVC", "IA", "IHTK"

ephys_meta <- ephys_meta %>% 
  mutate(num_zeros = 4 - floor(log(Recording))) %>% 
  mutate(num_zeros = ifelse(num_zeros == 3, "000", 
                            ifelse(num_zeros == 2, "00", 
                                   ifelse(num_zeros == 1, "0", NA)))) %>% 
  mutate(files = paste0(Experiment, "_", num_zeros, as.character(Recording), ".abf" ))


#


# trace_list <- map(seq(1, nrow(to_use)), function(i){
#   trace <- readABF_as_matrix(
#     path = paste0(traces_dir, "/", as.character(to_use[i, "files"])),
#     channels = c("IN 4", "IN 7", 
#                  "IN 9", "IN 12"#, "IN 14"
#     ))
#   
#   trace <- as.data.frame(trace) %>% 
#     janitor::clean_names(case = "upper_camel") %>% 
#     mutate(Time = Time - min(Time, na.rm = T),
#            Experiment = to_use[i, "Experiment"],
#            Group = to_use[i, "Group"],
#            files = to_use[i, "files"]
#     )
#   
#   if (ncol(trace) == 8){
#      return(trace) 
#   } else {
#     return(
#       data.frame(In4 = NA,
#                  In7 = NA, 
#                  In9 = NA, 
#                  In12 = NA, 
#                  Time = NA,
#                  Experiment = to_use[i, "Experiment"],
#                  Group = to_use[i, "Group"],
#                  files = to_use[i, "files"])
#       )
#   }
# })

# trace_df <- do.call(rbind, trace_list) %>% pivot_longer(names_to = "Channel", values_to = "mV", c("In4", "In7", "In9", "In12"))
# 
# 
# # find the low variance traces and drop them. Thesea are in the bath.
# trace_dstats <- trace_df %>%
#   group_by(files, Channel) %>%
#   summarise(sd = sd(mV, na.rm = T),
#             mean = mean(mV, na.rm = T),
#             min = min(mV, na.rm =T),
#             max = max(mV, na.rm = T)) %>%
#   mutate(range = abs(max - min))
# 
# trace_df <- full_join(trace_df, trace_dstats)
# 
# 
# trace_df$Channel <- factor(trace_df$Channel, levels = c("In4", "In9", "In7", "In12"))
# # GROUP = "Baseline"
# 
# 
# ## Big picture show everything ====
# for (GROUP  in c("Baseline", "Compensated", "Delayed")){
#   trace_df[seq(1, nrow(trace_df), by = 25), ] %>%
#     filter(Group == GROUP) %>%
#     mutate(colorvar = ifelse(Channel %in% c("In4", "In9"), "mV", "nA")) %>%
#     filter(colorvar == "mV") %>%
#     ggplot(aes(x = Time, y = mV, group = Channel, color = Channel))+
#     # scattermore::geom_scattermore()+
#     geom_path(alpha = 0.9)+
#     theme_minimal()+
#     theme(legend.position = "")+
#     scale_color_brewer(palette = "Set1")+
#     ylim(-70, -10)+
#     facet_wrap(.~files, scales = "free")
# 
#   ggsave(here("figures", paste0("prelim_trace_vis_", GROUP, ".pdf")), width = 9, height = 9)
# 
# }

```






## Inspiration from dynamic clamp project

```{r eval=FALSE, include=FALSE}
# First pass at annotation ----

# one.trace %>% ggplot()+
#   geom_line(aes(x = Time, y = IN.4), color = "Steelblue")+
#   geom_line(aes(x = Time, y = IN.9), color = "Firebrick")+
#   geom_hline(yintercept = min(one.trace$IN.4, na.rm = T), color = "Steelblue")+
#   geom_hline(yintercept = min(one.trace$IN.9, na.rm = T), color = "Firebrick")


# one.trace %>%
#   # Voltage difference
#   mutate(diff = IN.4 - IN.9) %>% # Not really useful atm
#   mutate(intersect.V = ifelse( # lower of the two, used for overlap
#     IN.4 <= IN.9,
#     IN.4, IN.9
#     )
#     ) %>%
#     mutate(union.V = ifelse( # Higher of the two.
#     IN.4 >= IN.9,
#     IN.4, IN.9
#     )
#     ) %>%
#   mutate(higher.V.min = ifelse(
#     min(one.trace$IN.4, na.rm = T) >= min(one.trace$IN.9, na.rm = T),
#      min(one.trace$IN.4, na.rm = T),
#      min(one.trace$IN.9, na.rm = T)
#   )) %>%
#   mutate(Overlap.V =  intersect.V - higher.V.min) %>%
#   ggplot()+
#   geom_line(aes(x = Time, y = Overlap.V))+
#   geom_ribbon(aes(x = Time, ymin=min(Overlap.V), ymax=Overlap.V))+
#   geom_line(aes(x = Time, y = IN.4 - min(one.trace$IN.4, na.rm = T)),
#             color = "Steelblue",
#             size = 1)+
#   geom_line(aes(x = Time, y = IN.9 - min(one.trace$IN.9, na.rm = T)),
#             color = "Firebrick",
#             size = 1)

# geom_line(aes(x = Time, y = IN.4), color = "Steelblue")+
# geom_line(aes(x = Time, y = IN.9), color = "Firebrick")
# geom_hline(yintercept = min(one.trace$IN.4, na.rm = T), color = "Steelblue")+
# geom_hline(yintercept = min(one.trace$IN.9, na.rm = T), color = "Firebrick")

# geom_line(aes(x = Time, y = IN.4 - min(one.trace$IN.4, na.rm = T)), color = "Steelblue")+
# geom_line(aes(x = Time, y = IN.9 - min(one.trace$IN.9, na.rm = T)), color = "Firebrick")+
# geom_line(aes(x = Time, y = diff))

# Second pass at annotation ----

## Group by trace and add possible predictors to it ====

### min, baseline, max, median, and mean mV, and duration (period) ####
one.trace <-
  one.trace %>%
  ungroup() %>%
  gather(Ch, mV, c("IN.4", "IN.9")) %>%
  group_by(Trace, Ch) %>%
  # Min Voltage
  mutate(Min.V = min(mV, na.rm = T)) %>%
  # Baseline voltage
  # Defining as average of the lowest 20% of points
  mutate(Use.in.Base = quantile(mV, probs = .2, na.rm = T)) %>%
  mutate(Use.in.Base = ifelse(mV <= Use.in.Base,
    mV,
    NA
  )) %>%
  mutate(Use.in.Base = mean(Use.in.Base, na.rm = T)) %>%
  # Max voltage
  mutate(Max.V = max(mV, na.rm = T)) %>%
  # Median Voltage
  mutate(Med.V = median(mV, na.rm = T)) %>%
  # Mean Voltage
  mutate(Mean.V = mean(mV, na.rm = T)) %>%
  # Duration
  mutate(Max.Time = max(Time, na.rm = T))

### Delay between channels ####
# Get time at which voltage traces cross a threshold. Then compute the abs(difference)
delays.to.annotate <- one.trace %>%
  mutate(Delay = (mV >= quantile(mV, probs = .9, na.rm = T))) %>%
  filter(Delay == T) %>%
  summarise(
    Thres.Time.b = min(Time, na.rm = T),
    Thres.Time.e = max(Time, na.rm = T)
  )

one.trace$Onset <- NA
one.trace$Termination <- NA
walk(seq(1, nrow(delays.to.annotate)), function(i) {
  one.trace[
    one.trace$Trace == as.character(delays.to.annotate[i, "Trace"]) &
      one.trace$Ch == as.character(delays.to.annotate[i, "Ch"]),
    "Onset"
  ] <<- as.numeric(delays.to.annotate[i, "Thres.Time.b"])

  one.trace[
    one.trace$Trace == as.character(delays.to.annotate[i, "Trace"]) &
      one.trace$Ch == as.character(delays.to.annotate[i, "Ch"]),
    "Termination"
  ] <<- as.numeric(delays.to.annotate[i, "Thres.Time.e"])
})

### Add in On duration, Duty Cycle, and AUC ####
one.trace <- one.trace %>%
  # On duration
  mutate(On.Duration = Termination - Onset) %>%
  # Duty Cycle
  mutate(Duty.Cycle = On.Duration / Max.Time) %>%
  # AUC
  # Using Min.V
  mutate(AUC = (mV - Min.V))


## make a list with more user friendly names ====

# Each elemen tof the list consists of only one channel.
one.trace.list <- map(c("IN.4", "IN.9"), function(i) {
  temp <- filter(one.trace, Ch == i)

  temp.names <- names(temp)

  temp.names[!(temp.names %in% c("Trace", "Time", "Ch"))] <-
    paste(temp.names[!(temp.names %in% c("Trace", "Time", "Ch"))], i, sep = "_")

  names(temp) <- temp.names

  temp %>% ungroup()

  return(temp)
})

# put the channels back together
one.trace <- full_join(
  one.trace.list[[1]],
  one.trace.list[[2]],
  by = c("Trace", "Time")
)


##add in delay for each channel (if it starts first it's 0), percent delay, corrlation between channels, and intersectional overlap between channels ==== 
one.trace <- one.trace %>%
  dplyr::group_by(Trace) %>%
  # Delay
  mutate(Delay_IN.4 = ifelse(
    Onset_IN.4 <= Onset_IN.9,
    0,
    Onset_IN.4 - Onset_IN.9
  )) %>%
  mutate(Delay_IN.9 = ifelse(
    Onset_IN.9 <= Onset_IN.4,
    0,
    Onset_IN.9 - Onset_IN.4
  )) %>%
  # Percent Delay (can be converted into phase)
  mutate(P.Delay_IN.4 = Delay_IN.4 / Max.Time_IN.4) %>%
  mutate(P.Delay_IN.9 = Delay_IN.9 / Max.Time_IN.9) %>%
  # Correlation
  mutate(Cor = cor(mV_IN.4, mV_IN.9,
    use = "pairwise.complete.obs",
    method = "pearson"
  )) %>%
  # intersect AUC / % overlap
  mutate(Min.AUC = ifelse(AUC_IN.4 <= AUC_IN.9,
    AUC_IN.4,
    AUC_IN.9
  ))


## show that min AUC is acting as expected ====
# one.trace %>%
#   ggplot(aes(group = Trace)) +
#   geom_line(aes(x = Time, y = mV_IN.4 - Min.V_IN.4), color = "Blue", alpha = 0.4) +
#   geom_line(aes(x = Time, y = mV_IN.9 - Min.V_IN.9), color = "Red", alpha = 0.4) +
#   geom_line(aes(x = Time, y = Min.AUC), color = "Purple") +
#   facet_grid(. ~ Trace)
```

```{r eval=FALSE, include=FALSE}
## Get summary of all ====

# 1. Get single value descriptors for each trace
one.trace  <- one.trace %>% 
  ungroup() %>% 
  dplyr::group_by(Trace) %>% 
  # Voltages
  mutate(Mean.Min.V = mean(mean(Min.V_IN.4, na.rm = T), mean(Min.V_IN.9, na.rm = T))) %>% 
  mutate(Mean.Max.V = mean(mean(Max.V_IN.4, na.rm = T), mean(Max.V_IN.9, na.rm = T))) %>% 
  mutate(Mean.Med.V = mean(mean(Med.V_IN.4, na.rm = T), mean(Med.V_IN.9, na.rm = T))) %>% 
  mutate(Mean.Mean.V = mean(mean(Mean.V_IN.4, na.rm = T), mean(Mean.V_IN.9, na.rm = T))) %>% 
  
  # Times
  mutate(Mean.Duration = mean(mean(Max.Time_IN.4, na.rm = T), mean(Max.Time_IN.9, na.rm = T))) %>%
  mutate(Mean.On.Duration = mean(mean(On.Duration_IN.4, na.rm = T), mean(On.Duration_IN.9, na.rm = T))) %>% 
  mutate(Mean.Duty.Cycle = mean(mean(Duty.Cycle_IN.4, na.rm = T), mean(Duty.Cycle_IN.9, na.rm = T))) %>% 
  
  mutate(Onset.Delay = max(Delay_IN.4, Delay_IN.9, na.rm = T)) %>% 
  mutate(P.Onset.Delay = max(P.Delay_IN.4, P.Delay_IN.9, na.rm = T)) %>% 
  
  # AUCs -- convert to single value of mV/trace
  mutate(Mean.AUC = mean(sum(AUC_IN.4, na.rm = T), sum(AUC_IN.9, na.rm = T))) %>% 
  mutate(Min.AUC = sum(Min.AUC, na.rm = T)) %>% 
  ## and mV/S
  mutate(Mean.AUC.mV.S = Mean.AUC/Mean.Duration) %>%
  mutate(Min.AUC.mV.S = Min.AUC/Mean.Duration) %>%

  # Clean up selection
  dplyr::select(Trace, #Time, 
                Mean.Min.V, Mean.Max.V, Mean.Med.V, Mean.Mean.V, 
                Mean.Duration, Mean.On.Duration, Mean.Duty.Cycle, 
                Onset.Delay, P.Onset.Delay,
                Mean.AUC, Min.AUC, 
                Mean.AUC.mV.S, Min.AUC.mV.S,
                Cor) %>% ungroup()
 
# 2. Remove the duplicate measures.  
one.trace <- one.trace[!(duplicated(one.trace)), ] 

# 3. Join with gj change datasets
## get the OG dataset ====
# Orig <- M.clean %>% 
Orig <- M.d %>%
  dplyr::filter(Condition %in% c("PS.0.orig",     
                                 "PS.22.orig",   
                                 "PS.45.orig",   
                                 "PS.90.orig",
                                 "PS.180.orig"))
Orig.exps <- Orig$Experiment %>% unique()

## get the standardized dataset ====
Standard <- M.d %>% 
  dplyr::filter(Condition %in% c("PS.0.High.Amp", 
                                 "PS.22.High.Amp", 
                                 "PS.90.HA",
                                 "PS.0", 
                                 "PS.22", 
                                 "PS.45", 
                                 "PS.90"))

## Make trace names join-able ====
new.Trace.names <- stringr::str_split(one.trace$Trace, pattern = "_0") %>% 
  map(function(i){
    pluck(i,1)
  }) %>% unlist()

# Manually fix two
# Orig.exps[!(Orig.exps %in% new.Trace.names)]
# new.Trace.names[!(new.Trace.names %in% Orig.exps)]
new.Trace.names[new.Trace.names == "171016_B"] <- "171016"
new.Trace.names[new.Trace.names == "171017_A"] <- "171017"

one.trace <- one.trace %>% mutate(Experiment = new.Trace.names)


## Produce New Datasets ====
one.trace.orig <- one.trace[!(one.trace$Trace %in% 
                                c("180221_0029.abf", 
                                  "180308_0013.abf",
                                  "180425_0017.abf",
                                  "180510_0034.abf",
                                  "180604_0009.abf",
                                  "190408_0026.abf",
                                  "191209_0011.abf")), ]

one.trace.standard <- one.trace[one.trace$Trace %in% 
                                  c("180221_0029.abf", 
                                    "180308_0013.abf",
                                    "180425_0017.abf",
                                    "180510_0034.abf",
                                    "180604_0009.abf",
                                    "190408_0026.abf",
                                    "191209_0011.abf"), ]

one.trace.standard$Condition <- NA
one.trace.standard[one.trace.standard$Trace == "180221_0029.abf", "Condition"] <- "PS.0.High.Amp"
one.trace.standard[one.trace.standard$Trace == "180308_0013.abf", "Condition"] <- "PS.22"
one.trace.standard[one.trace.standard$Trace == "180425_0017.abf", "Condition"] <- "PS.45"
one.trace.standard[one.trace.standard$Trace == "180510_0034.abf", "Condition"] <- "PS.0"
one.trace.standard[one.trace.standard$Trace == "180604_0009.abf", "Condition"] <- "PS.22.High.Amp"
one.trace.standard[one.trace.standard$Trace == "190408_0026.abf", "Condition"] <- "PS.90"
one.trace.standard[one.trace.standard$Trace == "191209_0011.abf", "Condition"] <- "PS.90.HA"



Orig <- full_join(Orig, one.trace.orig, by = "Experiment")

Standard <- full_join(Standard, one.trace.standard, by = "Condition")
```

Version 1 of the figure displaying individualized data.
```{r eval=FALSE, include=FALSE}
# plt.trace.variation <- plt.trace.variation[plt.trace.variation$Trace %in% unique(plt.trace.variation$Trace)[c(1,2,4,11,14,#17,19,
#                                                                                                               20,21,26)], ]


plt.trace.variation <- plt.trace.variation[!(plt.trace.variation$Trace %in% 
                                c("180221_0029.abf", 
                                  "180308_0013.abf",
                                  "180425_0017.abf",
                                  "180510_0034.abf",
                                  "180604_0009.abf",
                                  "190408_0026.abf",
                                  "191209_0011.abf")),]

# Add in labels for facetting
temp <- Orig %>% dplyr::select(Condition, Experiment#, Mean.Duration, Mean.On.Duration
                               ) %>% rename(Trace = Experiment) %>% distinct() 



# which experiments use the same stim protocol?
temp1 <- left_join(mutate(plt.trace.variation, Trace = unlist(transpose(str_split(plt.trace.variation$Trace, "_"))[[1]]) ) , temp) %>% dplyr::select(-Condition)

temp1 %>% 
  group_by(Trace) %>% 
  summarise(Duration = max(Time)) %>% arrange(Duration)
	
#     Trace   Duration
# 1	  170623b	2.799864

# 2	  170803b	3.165165

# 3	  170825a	3.200130
# 4	  170925A	3.200130

# 5	  170705a	3.240090
# 6  	170710	3.240090
# 7  	170711e	3.240090

# 8	  170814b	4.300029

# 9	  170808a	4.399929
# 10	170808b	4.399929
# 11	170811	4.399929
# 12	171016	4.399929
# 13	171017	4.399929
# 14	171201	4.399929

# 15	180717a	5.000000

# 16	170828a	5.200128
# 17	180717	5.200128

# 18	170728a	5.435892
# 19	170801a	5.435892
# 20	170802a	5.435892
# 21	170803a	5.435892

# 22	180718	5.660000
# 23	180718a	5.660000

# 24	170817b	5.900094

# 25	170713b	6.216777

# 26	170824a	9.300024



temp1 %>% 
  filter(Trace %in% c(
    # "170623b", "170803b", 
    # "170825a", "170925A", #same stim
    # "170705a", "170710", #same stim
                 "170711e",
               
    # "170814b", 
    # "170808a", "170808b",  "170811",  # Same Stim
                 "171016",  "171017",  "171201" #(171016 and 171201 look to be the same but the clamp on the latter is much worse -- unlikely that it acts as the same stim. Code it as a separate variable?)
    # "180717a", 
    # "170828a", "180717"  # Same Stim
    # "170728a", "170801a", "170802a", "170803a", #same stim
    # "180718",  "180718a"#same stim
    # "170817b", "170713b", "170824a"
  )) %>% 
  group_by(Trace) %>% 
  mutate(Duration = round(max(Time), digits = 2)) %>% 
  gather(key = Ch, value = mV, c("IN.4", "IN.9")) %>% 
  ggplot()+
  geom_line(aes(x = Time, y = mV, group = Trace, color = as.character(Duration)))+
  facet_grid(Trace~Ch)+
  theme(legend.position = "")



```

First test of showing individualized phase
```{r eval=FALSE, include=FALSE}
# denomerator <- 16
for (denomerator in c(16, 8, 4, 2)){

temp2 <- left_join(mutate(plt.trace.variation, Trace = unlist(transpose(str_split(plt.trace.variation$Trace, "_"))[[1]]) ) , temp)

# time.tol <- 0.01
# temp2[(temp2$Mean.Duration > 3.24-time.tol & temp2$Mean.Duration < 3.24+time.tol) |
#         (temp2$Mean.Duration > 5.900094-time.tol & temp2$Mean.Duration < 5.900094+time.tol) | 
#         (temp2$Mean.Duration > 9.300024-time.tol & temp2$Mean.Duration < 9.300024+time.tol), ] %>% 

temp2 <- temp2 %>% dplyr::filter(Trace %in% c("170711e", "170817b")) %>% dplyr::select(-IN.4)




temp2 <- temp2 %>% 
  group_by(Trace) %>% 
  mutate(IN.9 = IN.9 - min(IN.9, na.rm = T)) %>%
  # mutate(mV2 = mV - max(mV, na.rm = T)) %>% 
  mutate(ShiftSec = max(Time, na.rm = T)/denomerator) %>% 
  mutate(Time2 = ifelse(Time < max(Time, na.rm = T)-ShiftSec, Time+ShiftSec, Time-(max(Time, na.rm = T)-ShiftSec)) )

# temp2[temp2$Trace == "170817b", "mV2"] <- temp2[temp2$Trace == "170817b", "mV2"] + min(temp2[temp2$Trace == "170711e", "mV2"], na.rm = T)
# temp2[temp2$Trace == "170817b", "mV"] <- temp2[temp2$Trace == "170817b", "mV2"] + min(temp2[temp2$Trace == "170711e", "mV2"], na.rm = T)


X.shift <- (1.57 -0.355)

ggplot(temp2)+
  geom_line(data = temp2[temp2$Trace == "170711e",], aes(x = Time + X.shift, y = IN.9, group = Trace))+
  geom_line(data = temp2[temp2$Trace == "170711e",], aes(x = Time2 + X.shift, y = IN.9-10, group = Trace))+
  geom_line(data = temp2[temp2$Trace == "170817b",], aes(x = Time, y = IN.9-20, group = Trace))+
  geom_line(data = temp2[temp2$Trace == "170817b",], aes(x = Time2, y = IN.9-30, group = Trace))+
  geom_segment(aes(x = 0, xend = 1, y = -30, yend = -30), size = 1)+
  geom_segment(aes(x = 0, xend = 0, y = -30, yend = -25), size = 1)+
    # geom_vline(xintercept = 1.56)+
  geom_segment(aes(x = 1.56, xend = 1.56+0.2025056, y = 10, yend = 10), size = 1, color = "cornflowerblue")+
  geom_segment(aes(x = 1.56, xend = 1.56+0.3687559 , y = -10, yend = -10), size = 1, color = "cornflowerblue")+
  theme_void()
  
ggsave(here("data", "figures", as.character(paste0("individual_pro_", as.character(round(360/denomerator, digits = 2)), "_v1.pdf"))), 
       width = 8.79, height = 7.21)

ggsave(here("data", "figures", as.character(paste0("individual_pro_", as.character(round(360/denomerator, digits = 2)), "_v1.svg"))), 
       width = 8.79, height = 7.21)
}
```

Second test
```{r eval=FALSE, include=FALSE}
# Use fraction shift


temp3 <- left_join(mutate(plt.trace.variation, Trace = unlist(transpose(str_split(plt.trace.variation$Trace, "_"))[[1]]) ) , temp)

	
#   Trace mtime
# 1	170623b	2.799864
# 2	170803b	3.165165
# 3	170825a	3.200130
# 4	170925A	3.200130
# 5	170705a	3.240090
# 6	170710	3.240090
# 7	170711e	3.240090
# 8	170814b	4.300029
# 9	170808a	4.399929
# 10	170808b	4.399929
# 11	170811	4.399929
# 12	171016	4.399929
# 13	171017	4.399929
# 14	171201	4.399929
# 15	180717a	5.000000
# 16	170828a	5.200128
# 17	180717	5.200128
# 18	170728a	5.435892
# 19	170801a	5.435892
# 20	170802a	5.435892
# 21	170803a	5.435892
# 22	180718	5.660000
# 23	180718a	5.660000
# 24	170817b	5.900094
# 25	170713b	6.216777
# 26	170824a	9.300024

temp3 <- temp3 %>% dplyr::filter(Trace %in% c("170711e", "170814b", "180718a", "170817b")) %>% dplyr::select(-IN.4)

temp3$Trace <- factor(temp3$Trace, level = c("170711e", "170814b", "180718a", "170817b"))


# denomerator <- 16

for (denomerator in c(16, 8, 4, 2)){

temp3 <- temp3 %>% 
  group_by(Trace) %>% 
  mutate(IN.9 = IN.9 - min(IN.9, na.rm = T)) %>%
  # mutate(mV2 = mV - max(mV, na.rm = T)) %>% 
  mutate(ShiftSec = max(Time, na.rm = T)/denomerator) %>% 
  mutate(Time2 = ifelse(Time < max(Time, na.rm = T)-ShiftSec, Time+ShiftSec, Time-(max(Time, na.rm = T)-ShiftSec)) ) %>% 
  ungroup() %>% 
  mutate(shift_down = max(IN.9, na.rm = T)) %>% 
  mutate(numeric_fac = as.numeric(as.factor(Trace))) %>% 
  mutate(mV = IN.9 - (((numeric_fac-1) * 2) * shift_down) - shift_down ) %>% 
  mutate(mV2 = IN.9 - ((numeric_fac-1) * 2) * shift_down)

  
annotation_df <- temp3 %>% 
  group_by(Trace, ShiftSec, numeric_fac) %>% 
  summarise(#mV_max = max(mV, na.rm = T), 
            mV_min = min(mV, na.rm = T)#,
            # mV2_max = max(mV2, na.rm = T)#, 
            #mV2_min = min(mV2, na.rm = T)
            ) %>% 
  ungroup() %>% 
  mutate(ShiftSec = round(ShiftSec, digits = 3))


tic <- Sys.time()
temp3 %>% 
  ggplot()+
  geom_segment(data = annotation_df, aes(x = 0, xend = ShiftSec, y = mV_min, yend = mV_min), color = "cornflowerblue", size = 2)+
  geom_line(aes(x = Time, y = mV2, group = Trace))+
  geom_line(aes(x = Time2, y = mV, group = Trace))+
  geom_text(data = annotation_df, 
            aes(x = 0.12, y = mV_min+2, label = ShiftSec, group = Trace), 
            parse = T )+
  geom_path(data = data.frame(x = c(-0.1, -0.1, 0.9), y = c(-72, -82, -82)), aes(x = x, y = y))+
  # annotate("text", x = 0.12, y = 11, parse = TRUE, label = as.character(expression(paste(phi, 
  #                                                                                        " = "
  #                                                                                        )
  #                                                                                  )
  #                                                                       )
  #          )+
  theme_void()

ggsave(here("data", "figures", as.character(paste0("individual_pro_", as.character(round(360/denomerator, digits = 2)), "_v2.pdf"))), 
       width = 8.79, height = 7.21)

ggsave(here("data", "figures", as.character(paste0("individual_pro_", as.character(round(360/denomerator, digits = 2)), "_v2.svg"))), 
       width = 8.79, height = 7.21)
}
```

PCA is now shelved.
```{r eval=FALSE, include=FALSE}

# temp <- Orig[, c(
#   "Time",
#   "r11", "r12", "r1", "rc", "cc", "rmp", 
#   # "gj", 
#   # "intercept.peak_htk", "slope.peak_htk", "intercept.end_htk", "slope.end_htk", "intercept.peak_a", "slope.peak_a", "intercept.end_a", "slope.end_a", "a.peak.nA", "htk.peak.nA", 
#   # "inter", "Trace", 
#   "Mean.Min.V", "Mean.Max.V", "Mean.Med.V", "Mean.Mean.V", "Mean.Duration", "Mean.On.Duration", "Mean.Duty.Cycle", "Onset.Delay", "P.Onset.Delay", "Mean.AUC", "Min.AUC", "Mean.AUC.mV.S", "Min.AUC.mV.S", "Cor"
# )] %>% 
#   dplyr::filter(Time == 40) %>% 
#   dplyr::select(-Time)
# 
# library(factoextra)
# z <- prcomp(~., data = temp, center = TRUE, scale. = TRUE)
# fviz_screeplot(z, addlabels = TRUE, ylim = c(0, 50))
# fviz_pca_var(z, col.var="contrib",
#              gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
#              repel = TRUE # Avoid text overlapping
#              )
# 
# 
# ## Standardized protocols
# plt.list <- map(list(
#   c("PS.0.High.Amp", "PS.22.High.Amp", "PS.90.HA"),
#   c("PS.22", "PS.45", "PS.0", "PS.90"),
#   c("PS.0.High.Amp", "PS.22.High.Amp", "PS.90.HA", "PS.22", "PS.45", "PS.0", "PS.90")
# ), function(i){
#   temp <- Standard[Standard$Condition %in% i , c(
#     "Time",
#     "r11", "r12", "r1", "rc", "cc", "rmp", 
#     # "gj",
#     # "intercept.peak_htk", "slope.peak_htk", "intercept.end_htk", "slope.end_htk", "intercept.peak_a", "slope.peak_a", "intercept.end_a", "slope.end_a", "a.peak.nA", "htk.peak.nA",
#     # "inter", "Trace", 
#     "Mean.Min.V", "Mean.Max.V", "Mean.Med.V", "Mean.Mean.V", #"Mean.Duration", 
#          "Mean.On.Duration", "Mean.Duty.Cycle", "Onset.Delay", "P.Onset.Delay", "Mean.AUC", "Min.AUC", "Mean.AUC.mV.S", "Min.AUC.mV.S", "Cor"
#   )] %>% 
#     dplyr::filter(Time == 40) %>% 
#     dplyr::select(-Time)
#   
#   z <- prcomp(~., data = temp, center = TRUE, scale. = TRUE)
#   plt.scree <- fviz_screeplot(z, addlabels = TRUE#, ylim = c(0, 50)
#                               )
#   plt.biplt <- fviz_pca_var(z, col.var="contrib",
#                             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
#                             repel = TRUE # Avoid text overlapping
#   )
#   
#   return(list(scree = plt.scree,
#               biplt = plt.biplt))
# })
# 
# 
# plt.list[[1]]$scree
# plt.list[[1]]$biplt
# plt.list[[2]]$scree
# plt.list[[2]]$biplt
# plt.list[[3]]$scree
# plt.list[[3]]$biplt
```

















# Working off of processed data ----
## Functions to move to ./R/ (2)
```{r}
## Shrug ====
shrug <- function(){cat("¯\\_(ツ)_/¯")}

## IV linear ====
iv_linear <- function(input.df = temp,
                             min.mV = -35,
                             max.mV = 5,
                             ch.i = "S2Max",
                             ch.v = "S1Max"){
  # input.df = temp
  # min.mV = -81
  # max.mV = -39
  # ch.i = "S2Max"
  # ch.v = "S1Max"
  
  input.df <- as.data.frame(input.df)
  
        # input.df <- input.df[!is.na(input.df[[ch.v]]), ]
  
  if (nrow(input.df[!is.na(input.df[[ch.v]]), ]) > 1 ){
      input.df <- input.df %>% rename(CH.I = ch.i) %>% rename(CH.V = ch.v)
  
  fm <- lm(CH.I ~ CH.V, input.df[input.df$CH.V >= min.mV & input.df$CH.V <= max.mV, ], na.action = "na.omit")
  
  }
  return(list(intercept = fm$coefficients[[1]],
       slope = fm$coefficients[[2]]))  

}

## mk_filename ====
# write file name from spreadsheet
mk_filename <- function(
  metadata.file = metadata,
  use.row = 1){
  filename <- paste0(
    as.character(
      metadata.file[use.row, "Experiment"]
    ),
    "_",
    paste0(
      rep("0", (4-length(metadata.file[use.row, "Recording"]))), collapse = ""),
    as.character(
      metadata.file[1, "Recording"]
    ),
    ".abf"
  )
  return(filename)
}


## Subtract leak from ihtk protocol
subtract_leak_df <- function(input.df = temp,
                             min.mV = -81,
                             max.mV = -39,
                             ch.i = "S2Max",
                             ch.v = "S1Max"){
  
  # input.df = temp
  # min.mV = -81
  # max.mV = -39
  # ch.i = "S2Max"
  # ch.v = "S1Max"
  
  input.df <- as.data.frame(input.df)
  
        # input.df <- input.df[!is.na(input.df[[ch.v]]), ]
  
  if (nrow(input.df[!is.na(input.df[[ch.v]]), ]) > 1 ){
      input.df <- input.df %>% rename(CH.I = ch.i) %>% rename(CH.V = ch.v)
  
  fm <- lm(CH.I ~ CH.V, input.df[input.df$CH.V >= min.mV & input.df$CH.V <= max.mV, ], na.action = "na.omit")
  
  input.df <- input.df %>% mutate(leak = predict(object = fm, newdata = input.df), na.action = "na.omit")
  input.df <- input.df %>% mutate(leak.sub = CH.I - leak)
  
  # input.df <- input.df %>% rename(ch.i = CH.I) %>% rename(ch.v = CH.V)
  
  names(input.df)[names(input.df) == "CH.I"] <- ch.i
  names(input.df)[names(input.df) == "CH.V"] <- ch.v
  
  
  # input.df %>% select(S1Max, S2Max, leak, leak.sub) %>% gather(type, value, 2:4) %>% ggplot(aes(x = S1Max, y = value, color = type))+geom_point()
  

  }
  return(input.df)  

}

```


See 01Merge*
## Load Data Ephys Data
```{r}
metadata <- read_excel(use.file.path,
                       sheet = "MetadataEphys")  

ia <- read_excel(
use.file.path,
  sheet = "IA"
)

ihtk <- read_excel(
use.file.path,
  sheet = "IHTK"
)

tecc <- read_excel(
use.file.path,
  sheet = "TECC"
)

tevc <- read_excel(
use.file.path,
  sheet = "TEVC"
)
```

# Voltage Clamp K+ Protocols
## IA data 
Add intercept/slope from -35 to 5mV
```{r}
# ia <- ia %>% filter(Condition %in% c("Baseline", "Compensated", "Delayed") &
#                       Pharm %in% c("none", "tea"))

ia <- separate(ia, FileName, c("Experiment", "Recording"), sep = "_") %>% mutate(Recording = as.numeric(Recording))


ia <- right_join(x = 
  select(metadata, #Pharm, 
         Condition, #Notes, 
         In4,   In9, Experiment, Recording),
  y = ia)# %>% filter(Experiment != "0")

temp1 <- ia %>% select(-c(In9, S3Max, S4Max, S3Mean, S4Mean, Signal3, Signal4))
temp2 <- ia %>% select(-c(In4, S1Max, S2Max, S1Mean, S2Mean, Signal1, Signal2))

names(temp2) <- names(temp1)

ia <- full_join(temp1, temp2) %>% mutate(Cell = as.factor(In4))

# ia %>% 
#   # filter(Pharm != "4ap") %>% 
#   ggplot(aes(S1Max, S2Max, color = Cell))+
#   geom_point()+
#   facet_grid(Condition ~ Experiment)+
#   theme_bw()

ia$intercept <- NA %>% as.numeric() 
ia$slope <- NA %>% as.numeric()

ia <- ia %>% mutate(iter.var = paste(Experiment, Cell, Condition, sep =  "_"))
iter.over <- ia$iter.var %>% unique()

walk(1:length(iter.over), function(i){
  print(i)
  temp.df <- ia[ia$iter.var == iter.over[i], ]
  # temp <- select(temp, -c(leak, leak.sub))
  if(length(na.omit(temp.df$S2Max)) >1 &
     length(na.omit(temp.df$S1Max)) >1){
    
    temp.fm <- iv_linear(input.df = temp.df,
                         min.mV = -35,
                         max.mV = 5,
                         ch.i = "S2Max",
                         ch.v = "S1Max")
    if (length(temp.fm) > 0 ){
      ia[ia$iter.var == iter.over[i], "intercept"] <<- temp.fm$intercept
      ia[ia$iter.var == iter.over[i], "slope"] <<- temp.fm$slope    
    }}
})

# ia %>% 
#   ggplot(aes(Condition, intercept))+
#   geom_point()+
#   theme_minimal()
```

## IHTK data (not leak substracted)
```{r}
# ihtk <- ihtk %>% filter(Condition %in% c("Baseline", "Compensated", "Delayed") &
#                       Pharm %in% c("none", "tea"))

ihtk <- separate(ihtk, FileName, c("Experiment", "Recording"), sep = "_") %>% mutate(Recording = as.numeric(Recording))


ihtk <- right_join(x = 
  select(metadata, #Pharm, 
         Condition, #Notes, 
         In4,   In9, Experiment, Recording),
  y = ihtk)# %>% filter(Experiment != "0")

temp1 <- ihtk %>% select(-c(In9, S3Max, S4Max, S3Mean, S4Mean, Signal3, Signal4))
temp2 <- ihtk %>% select(-c(In4, S1Max, S2Max, S1Mean, S2Mean, Signal1, Signal2))

names(temp2) <- names(temp1)

ihtk <- full_join(temp1, temp2) %>% mutate(In4 = as.factor(In4)) %>% rename(Cell = In4)

# ihtk %>% 
#   # filter(Pharm != "4ap") %>% 
#   ggplot(aes(S1Max, S2Max, color = Cell))+
#   geom_point()+
#   facet_grid(Condition ~ Experiment)+
#   theme_bw()
```

```{r}


ihtk <- ihtk %>% filter(Condition %in% c("Baseline", "Compensated", "Delayed"))

ihtk <- ihtk[!is.na(ihtk[["Experiment"]]) & 
         !is.na(ihtk[["Cell"]]) &
         !is.na(ihtk[["Condition"]]), ] 

ihtk <- ihtk %>% 
  mutate(iter.var = paste(Experiment, Cell, Condition, sep =  "_")) %>% 
  mutate(leak = NA) %>% 
  mutate(leak.sub = NA)


iter.over <- ihtk$iter.var %>% unique()



# Add in leak subtracted measure
ihtk$na.action <- NA
walk(1:length(iter.over), function(i){
  print(i)
  temp <- ihtk[ihtk$iter.var == iter.over[i], ]
  temp <- select(temp, -c(leak, leak.sub))
  
  temp <- subtract_leak_df(input.df = temp,
                     min.mV = -81,
                     max.mV = -39,
                     ch.i = "S2Max",
                     ch.v = "S1Max")
  if(nrow(temp)>1){
    # make sure the columns are in the same order
    temp <- temp[, names(ihtk)]
    
    ihtk[ihtk$iter.var == iter.over[i], ] <<- temp      
  }
})

ihtk <- ihtk %>% mutate(leak = as.numeric(leak)) 
ihtk$leak.sub <- ihtk$S2Max - ihtk$leak


# ihtk %>% ggplot()+
#    geom_line(aes(x = S1Max, y = leak, color = Cell), linetype = "dashed")+
#    geom_point(aes(x = S1Max, y = leak.sub, color = Cell))+
#    geom_line(aes(x = S1Max, y = S2Max, color = Cell))+
#   facet_grid(Condition ~ Experiment)+
#   theme_bw()

# ggsave(plot = last_plot(), filename = "IonicExample.tiff", path = here("data", "figures"))

# ihtk %>% 
#   filter(Experiment == "190716") %>% 
#   ggplot()+
#    geom_line(aes(x = S1Max, y = leak, color = Cell), linetype = "dashed")+
#    geom_point(aes(x = S1Max, y = leak.sub, color = Cell))+
#    geom_line(aes(x = S1Max, y = S2Max, color = Cell))+
#   facet_grid(Condition ~ Cell)+
#   theme_bw()
```

Fit Roughly linear portion from IHTK
```{r}
ihtk$intercept <- NA %>% as.numeric() 
ihtk$slope <- NA %>% as.numeric()

walk(1:length(iter.over), function(i){
  print(i)
  temp.df <- ihtk[ihtk$iter.var == iter.over[i], ]
  # temp <- select(temp, -c(leak, leak.sub))
  if(nrow(temp.df) > 1){
    temp.fm <- iv_linear(input.df = temp.df,
                         min.mV = -35,
                         max.mV = 5,
                         ch.i = "S2Max",
                         ch.v = "S1Max")
    if (length(temp.fm) > 0 ){
      ihtk[ihtk$iter.var == iter.over[i], "intercept"] <<- temp.fm$intercept
      ihtk[ihtk$iter.var == iter.over[i], "slope"] <<- temp.fm$slope    
    }}
})


```

```{r}
# ihtk %>% 
#   ggplot(aes(Condition, intercept))+
#   geom_point()+
#   theme_minimal()
# 
# ihtk %>% 
#   ggplot(aes(Condition, slope))+
#   geom_point()+
#   theme_minimal()
```

## Join ephys into combined df
```{r}
temp1 <- ihtk %>% 
  select(#Pharm, 
         Condition, Cell, Experiment, intercept, slope) %>% 
  filter(!duplicated(.)) %>% 
  rename(Ihtk.0 = intercept) %>% 
  rename(Ihtk.Slope = slope)
temp2 <- ia %>% select(#Pharm, 
  Condition, Cell, Experiment, intercept, slope) %>% 
  filter(!duplicated(.)) %>% 
  rename(Ia.0 = intercept) %>% rename(Ia.Slope = slope)

ionic <- full_join(temp1, temp2) %>% 
  filter(Condition %in% c("Baseline", "Compensated", "Delayed")) %>% 
  mutate(Condition = factor(Condition, levels = c("Baseline", "Compensated", "Delayed")))
```

## Save ionic for later use
```{r}
save(ionic, file = here("data", "ionic.rds"))
```

# Voltage Clamp GJ Protocol
```{r}

ThresholdVoltage <- 4

# Keep only those with steps greater than threshold
ThresholdVector <- abs(tevc$R1S1Mean) >= ThresholdVoltage | abs(tevc$R1S3Mean) >= ThresholdVoltage 
tevc <- tevc[ThresholdVector, ]

# Look for the smallest deviation from baseline to find which cell is postsynaptic
# if TRUE then S1 is the presynaptic cell
tevc$S1Pre <- abs(tevc$R1S1Mean) >= abs(tevc$R1S3Mean)
tevc$PreSyn <- ifelse(tevc$S1Pre, tevc$Signal1, tevc$Signal3)

# Drop any rows where this wasn't a bool
tevc <- tevc[!is.na(tevc$S1Pre), ]

# conductance = i_post / delta_mV
# Where S1Pre == T
# c = R1S4Mean / R1S1Mean 
# Otherwise 
# c = R1S2Mean / R1S3Mean
temp <- tevc %>% 
  group_by(FileName, S1Pre) %>% 
  mutate(Ig = ifelse(S1Pre, 
                     abs(R1S4Mean / R1S1Mean), #abs to flip the current being used to prevent mV change into current coming across gj
                     abs(R1S2Mean / R1S3Mean) 
  )
  ) %>% 
  ungroup()

# provide Median observation
temp <- temp %>% 
  select(FileName, S1Pre, R1S1Mean, R1S2Mean, R1S3Mean, R1S4Mean, Ig) %>% 
  group_by(FileName, S1Pre) %>% 
  mutate(MedianIg = median(Ig, na.rm = T)) %>% 
  ungroup()

# Merge back
tevc <- full_join(tevc, temp)

save(tevc, file = here("data", "tevc.rds"))
```

# Current Clamp GJ Protocol
Bennet 1966's resistances:

Apparant Cell resistances:
$$r_{11}=\frac{v_1}{i_1}$$

Transfer resistances:
$$r_{12}=\frac{v_2}{i_1}$$

Membrane resistance
$$r_1= \frac{r_{11}*r_{22} - r_{12}^2}{r_{22} - r_{12}}$$

Coupling resistance
$$r_c = \frac{r_{11}*r_{22} - r_{12}^2}{r_{12}}$$

```{r}
ExperimentNames <- tecc$FileName %>% stringr::str_split(pattern = "_")
ExperimentNames <- transpose(ExperimentNames)[[1]] %>% unlist()

tecc$Experiment <- ExperimentNames
```


```{r}
df = tecc
v1 = "R1S1Mean"#"IN4_mean"
i1 = "R1S3Mean"#"IN7_mean"
v2 = "R1S4Mean"#"IN9_mean"
i2 = "R1S6Mean"#"IN12_mean"
exp = "Experiment"
rec = "FileName"

# Grouping prevents this from working.
df <- ungroup(df)

df <- df %>% mutate(cell = ifelse(abs(R1S3Mean) > abs(R1S6Mean), "a", "b"))

## Set up selection vectors for when i1 (e.g. IN7) is being used to inject current
inj_i1 <- abs(df[[i1]]) > abs(df[[i2]])
inj_i2 <- abs(df[[i1]]) < abs(df[[i2]])
## figure out coupling coef
df[inj_i1, "cc"] <- df[inj_i1, v2] / df[inj_i1, v1] #when inj IN7
df[inj_i2, "cc"] <- df[inj_i2, v1] / df[inj_i2, v2] #when inj IN12
## figure out input resistance ====
df[inj_i1, "r11"] <- df[inj_i1, v1] / df[inj_i1, i1] #when inj IN7
df[inj_i2, "r11"] <- df[inj_i2, v2] / df[inj_i2, i2] #when inj IN12
## figure out transfer resistance ====
df[inj_i1, "r12"] <- df[inj_i1, v2] / df[inj_i1, i1]
df[inj_i2, "r12"] <- df[inj_i2, v1] / df[inj_i2, i2]

## figure out membrane resist and coupling resist for both cells ====
temp <- df %>%
  dplyr::select(
    exp, rec, cell, r11, r12
  ) %>%
  group_by(Experiment, FileName, cell) %>% 
  # mutate(cell = ifelse(inj_i1, "cell1", "cell2")) %>%
  mutate(r11 = median(r11, na.rm = T),
         r12 = median(r12, na.rm = T)) %>% 
  distinct() %>% 
  ungroup() %>% 
  pivot_wider(names_from = cell,
              values_from = c("r11", "r12")
  ) %>%
  mutate(r1_a = ((r11_a*r11_b) - (r12_a^2)) / (r11_b - r12_a)) %>%
  mutate(r1_b = ((r11_b*r11_a) - (r12_b^2)) / (r11_a - r12_b)) %>%
  mutate(rc_a = ((r11_a*r11_b) - (r12_a^2)) / (r12_a)) %>%
  mutate(rc_b = ((r11_b*r11_a) - (r12_b^2)) / (r12_b)) %>%
  pivot_longer(
    -c(exp, rec),
    names_to = c(".value", "cell"),
    names_sep = "_",
    values_drop_na = TRUE
  )

# collapse df to medians
df <- df[, c(
  "Experiment", "cell", 
  "FileName", 
  # "Trace", "TraceStart", 
  "Signal1", "Signal2", "Signal3", "Signal4", "Signal5", "Signal6", 
  # "Region1", "StartTime", "EndTime", 
  "R1S1Mean", "R1S2Mean", "R1S3Mean", "R1S4Mean", "R1S5Mean", "R1S6Mean", 
  "R1S1Baseline", "R1S2Baseline", "R1S3Baseline", "R1S4Baseline", "R1S5Baseline", "R1S6Baseline", 
  # "FilePath", 
  "cc"#, 
  # "r11", "r12"
)] %>% 
  group_by(Experiment, cell, FileName) %>% 
  mutate(R1S1Mean = median(R1S1Mean, na.rm = T),
         R1S2Mean = median(R1S2Mean, na.rm = T),
         R1S3Mean = median(R1S3Mean, na.rm = T),
         R1S4Mean = median(R1S4Mean, na.rm = T),
         R1S5Mean = median(R1S5Mean, na.rm = T),
         R1S6Mean = median(R1S6Mean, na.rm = T),
         
         R1S1Baseline = median(R1S1Baseline, na.rm = T),
         R1S2Baseline = median(R1S2Baseline, na.rm = T),
         R1S3Baseline = median(R1S3Baseline, na.rm = T),
         R1S4Baseline = median(R1S4Baseline, na.rm = T),
         R1S5Baseline = median(R1S5Baseline, na.rm = T),
         R1S6Baseline = median(R1S6Baseline, na.rm = T),
         
         cc = median(cc, na.rm = T),
  ) %>% 
  distinct() %>% 
  ungroup()

# Merge
df <- full_join(df, temp) %>% dplyr::select(-cell)

tecc <- df
```

```{r}
save(tecc, file = here("data", "tecc.rds"))
```


# Molecular Data

## Read in Brian's Data
```{r}
# load all of brian's cells
BriansCells <- list.files(here("inst", "extdata", "BriansCells"))
BriansCells <- BriansCells[!(BriansCells == "All.CSV")]

BriansDfs <- map(BriansCells, function(i){
  temp <- read.csv(here("inst", "extdata", "BriansCells", i))
  names(temp) <- janitor::make_clean_names(names(temp), case = "upper_camel")
  temp$Condition <- i
  temp$Source <- "Brian"
  
  return(temp)
})

BriansDf <- do.call(rbind, BriansDfs)

BriansDf$Condition <- BriansDf$Condition %>% str_remove(pattern = ".CSV")

BriansDf$Time <- ifelse(str_detect(BriansDf$Condition, pattern = "Control") & !(str_detect(BriansDf$Condition, pattern = "24")), "Baseline",
                        ifelse(str_detect(BriansDf$Condition, pattern = "Acute"), "Compensated",
                               ifelse(str_detect(BriansDf$Condition, pattern = "24"), "Delayed", "NotFound")
                               )
                        )

BriansDf$Pharm <- ifelse(str_detect(BriansDf$Condition, pattern = "Control"), "None",
                        ifelse(str_detect(BriansDf$Condition, pattern = "TEA"), "TEA",
                               ifelse(str_detect(BriansDf$Condition, pattern = "AP"), "AP", 
                                      ifelse(str_detect(BriansDf$Condition, pattern = "TTX"), "TTX", "NotFound")
                                      )
                               )
                        )

BriansDf <- BriansDf[, names(BriansDf)[!(names(BriansDf) %in% c("Condition"))]]

BriansDf <- BriansDf %>% select(-Treatment)

BriansMetadataCols <- c("Source", "Pharm", "Time", "Cell")
BriansDf <- BriansDf[, c(BriansMetadataCols, names(BriansDf)[!(names(BriansDf) %in% BriansMetadataCols)]) ]


# df <- data.frame()
# walk(BriansCells, function(i){
#   df <<- rbind(df, read.csv(here("inst", "extdata", "BriansCells",i)))
# })
# 
# df <- df %>% mutate(Pharm = "") %>% mutate(Condition = "")
# 
# update.df.labels <- data.frame(stringsAsFactors=FALSE,
#                                Treatment = c("4AP24h", "Control", "24h-CONTROL", "TEA-24h", "TEA-Acute",
#                                              "TTX-24h"),
#                                Pharm = c("AP", "none", "none", "tea", "tea", "ttx"),
#                                Condition = c("Delayed", "Baseline", "Delayed", "Delayed", "Compensated",
#                                              "Delayed")
# )
# 
# walk(1:nrow(update.df.labels), function(i){
#   up.t <- update.df.labels[i, "Treatment"]
#   up.p <- update.df.labels[i, "Pharm"]
#   up.c <- update.df.labels[i, "Condition"]
#   
#   BriansDf[BriansDf$TREATMENT == up.t, "Pharm"] <<- up.p
#   BriansDf[BriansDf$TREATMENT == up.t, "Condition"] <<- up.c
# })
# 
# df <- df %>% rename(UID = CELL) %>% select(-TREATMENT)
# df <- as_tibble(df)
# # mutate(var = replace(var, var != "Candy", "Not Candy"))
```
## Read in data paired with ephys
```{r}
TEAOverTime <- readxl::read_excel(here("inst", "extdata", "LCTEAhr0hr1hr24.xlsx")) %>% janitor::clean_names(case = "upper_camel")

TEAOverTime$Time <- ifelse(TEAOverTime$Tea == 0, "Baseline", 
                           ifelse(TEAOverTime$Tea == 1, "Compensated", 
                                  ifelse(TEAOverTime$Tea == 24, "Delayed", "NotFound")))

TEAOverTime$Pharm <- "TEA"
TEAOverTime$Source <- "Daniel"

TEAOverTime <- TEAOverTime[, names(TEAOverTime)[!(names(TEAOverTime) %in% c("Tea"))]]

MetadataCols <- c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell")
TEAOverTime <- TEAOverTime[, c(MetadataCols, names(TEAOverTime)[!(names(TEAOverTime) %in% MetadataCols)]) ]
```

```{r}
# Make everything lower to ensure easy merging.
names(TEAOverTime)[!(names(TEAOverTime) %in% c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell"))] <- tolower(names(TEAOverTime)[!(names(TEAOverTime) %in% c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell"))])

names(BriansDf)[!(names(BriansDf) %in% c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell"))] <- tolower(names(BriansDf)[!(names(BriansDf) %in% c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell"))])






mrna <- full_join(TEAOverTime, BriansDf)
```

Rename gene names so they're consistent and easy to lookup with `./inst/extdata/mRNAInfo.xlsx`
```{r}
mRNAInfo <- readxl::read_excel(here("inst", "extdata", "mRNAInfo.xlsx")) # tables from Northcutt 2016 and annotations
ToCorrect <- names(mrna)[!(names(mrna) %in% c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell"))]
# ToCorrect <- tolower(ToCorrect)

# Get the names InData and the corresponding output names
SwapNames <- mRNAInfo[mRNAInfo$InDataLower %in% ToCorrect, c("InDataLower", "RGeneName")]
# SwapNames$InData <- tolower(SwapNames$InData)

for (i in 1:nrow(SwapNames)){
  ToCorrect[ToCorrect == as.character(SwapNames[i, "InDataLower"])] <- as.character(SwapNames[i, "RGeneName"])  
}

names(mrna) <- c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell", ToCorrect)
```


```{r}
save(mrna, file = here("data", "mrna.rds"))
```





#End
