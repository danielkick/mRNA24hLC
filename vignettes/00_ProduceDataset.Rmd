---
title: "Produce Dataset"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
library(here)
library(tidyverse)
library(janitor)

library(zoo)
library(readABF)

library(broom)
library(minpack.lm) # getting Tau
library(patchwork)
library(ggsci)
library(cowplot)
library(patchwork)

library(gdata) # for humanReadable

library(minpack.lm) # for use in fit_tau_1term_exp()

theme_set(ggplot2::theme_minimal())


library(devtools)
devtools::load_all()
```

## Forward 
This file represents the full preparation of data. Ideally, where we pull processed data (e.g. where I've manually extraced values in clamp fit) will ultimately be replaced with automated, repeatable, and auditable processing. Auditing will be accomplished by including and option to write graphs of the input/output. 

```{r}
# TODO replace manual processing with automatic
# TODO Generate audit output
# TODO edit metadata file so as to allow for specification of traces or regions of traces to be excluded from a file (e.g. drop a segment with loss of voltage clamp)
```

## Build metadata

```{r global params}
use.file.path <- here("inst", "extdata", "ManualDataEphys02.xlsx")

abf_dir_path <- "D:/0000_Traces_mRNA24hLC/"

force_process_ABF <- c("000000_0000.abf")
```

# Working off of non-processed data ----

## Find all the relevant files
```{r}
metadata <- read_excel(use.file.path, sheet = "MetadataEphys")  
# update_type_names <- as_tibble(t(matrix(
#   c("htk", "htk", # ion
#     "a", "a",
#     "htkc", "htkc",
#     "ac", "ac",
#     
#     "tevc", "gjvc", # gj, Rs
#     "igj", "gjcc",
#     "igj_50", "gjcc",
#     
#     "fi_50", "fi", # excitability
#     "fi", "fi",
#     "epsp", "epsp",
#     "epsp_50", "epsp",
#     
#     "gj", "Unknown" #FIXME what are these?
#   ), nrow = 2)))
# names(update_type_names) <- c("InFile", "NewType")
```

## Check on hand abfs
```{r}
# Check for missing files relative to the abf directory

# Find all the traces specified in the metadata file (i.e. where type is not NA) and check to see if they exist in the `abf_dir`

absent_traces <- metadata[!is.na(metadata$Type), ]
absent_traces$Exists <- F

abf_dir <- list.files(abf_dir_path)
for (i in seq(1, nrow(absent_traces))){
  # make the file name
  num_zeros <- 4-nchar(absent_traces[i, "Recording"])
  num_zeros <- case_when(num_zeros == 0 ~ "",
                         num_zeros == 1 ~ "0",
                         num_zeros == 2 ~ "00",
                         num_zeros == 3 ~ "000")
  
  abf_name <- paste(as.character(absent_traces[i, "Experiment"]),
                    paste0(num_zeros, as.character(absent_traces[i, "Recording"]), ".abf"), 
                    sep = "_")
  # check if it exists in the dir
  absent_traces[i, "Exists"] <- abf_name %in% abf_dir
  
  # print(abf_name)
}

absent_traces_to_find <- absent_traces %>% 
  filter(Exists == F) %>% 
  mutate(RecordingLeadZeros = case_when((4 - nchar(Recording)) == 0 ~ "",
                                        (4 - nchar(Recording)) == 1 ~ "0",
                                        (4 - nchar(Recording)) == 2 ~ "00",
                                        (4 - nchar(Recording)) == 3 ~ "000")) %>% 
  mutate(FileName = paste0(Experiment, "_", RecordingLeadZeros, Recording, ".abf"))
```


Finding missing ABFs on the shared drive w/o Microsoft's search
```{r}
# Indexing all the ABFs in my directory on the shared drive is time consumming (~55 minutes over the VPN). It should only be done when an index doesn't exist already of if there's reason to beleave the index is no longer accurate. 
if (!file.exists(here("inst", "extdata", "shared_drive_abf_index.csv"))){
  start_loc <- "S:/Data_Daniel"
  
  tic <- Sys.time()
  all_abfs <- list.files("S:/Data_Daniel", "*.abf", recursive = T)
  toc <- Sys.time()
  print(toc - tic)
  
  write.csv(as.data.frame(all_abfs), file = here("inst", "extdata", "shared_drive_abf_index.csv"))
  rm(list = "all_abfs")
} 
all_abfs_on_shared_drive <- read.csv(here("inst", "extdata", "shared_drive_abf_index.csv"))
```


```{r}
all_abfs_on_shared_drive <- all_abfs_on_shared_drive %>% 
  as_tibble() %>% 
  mutate(all_abfs = as.character(all_abfs))

broken_path <- str_split(all_abfs_on_shared_drive$all_abfs, pattern = "/")

all_abfs_on_shared_drive$FileName <- map_chr(
  seq_along(broken_path), function(i){
  broken_path[[i]][[length(broken_path[[i]])]]
})


# if there's a match pull the path
absent_traces_to_find$PathOnShared <- NA

for (i in 1:nrow(absent_traces_to_find)){
  if(as.character(absent_traces_to_find[i, "FileName"]) %in% all_abfs_on_shared_drive$FileName){
    # get path
    absent_traces_to_find[i, "PathOnShared"] <- all_abfs_on_shared_drive[all_abfs_on_shared_drive$FileName == as.character(absent_traces_to_find[i, "FileName"]), "all_abfs"]

  } else {
    absent_traces_to_find[i, "PathOnShared"] <- NA
  }
}

# move from server
absent_traces_to_find$moved <- F
# Check for file's existence, if it's there move it and tag it as moved.
for (i in 1:nrow(absent_traces_to_find)){
  if(!is.na(absent_traces_to_find[i, "PathOnShared"])){
    file_to_move <- paste0("S:/Data_Daniel", "/", as.character(absent_traces_to_find[i, "PathOnShared"]))
    
    if (file.exists(file_to_move)){
      file.copy(
        from = file_to_move,
        to = paste0(
          abf_dir_path,
          absent_traces_to_find[i, "FileName"]  
        )
      )
      
      absent_traces_to_find[i, "moved"]  <- T
    }
  }
}

# After everything's moved, manually search for the rest. 

manually_find <- absent_traces_to_find %>% 
  filter(moved == F) %>% 
  select(Experiment, Page, Recording, Type, TEA, Condition, FileName)
write.csv(manually_find, file = here("data", "manually_find_ABFs.csv"))


# Can't seem to find experiment 190917a
# looking at manually processed data I don't see any evidence of it. Possibly it didn't get moved to the shared drive? 
#FIXME go and check the lab computer to make sure the missing file isn't there. 
metadata <- metadata[metadata$Experiment != "190917a", ]
```

```{r depricated}
# 
# 
# abf_names <- str_extract_all(all_abfs_on_shared_drive$all_abfs, "[[^/]]*[[:punct:]]abf$")
# 
# all_abfs_on_shared_drive$abf_names <- abf_names
# 
# 
# 
# # lapply(mtcars, function(x){x[length(x)]})
# 
# 
# i=1
# as.character(absent_traces_to_find[i, "FileName"]) %in% unlist(all_abfs_on_shared_drive$abf_names)
# 
# 
# # > file_groups
# #    Experiment       Group
# # 1      190924    Baseline
# # 2     190924a    Baseline
# # 3      190926    Baseline
# # 4      190927    Baseline
# # 5     190927a    Baseline
# # 6      190930    Baseline
# # 7     190930a    Baseline
# # 8     190808a Compensated
# # 9      190830 Compensated
# # 10     190904 Compensated
# # 11     191001 Compensated
# # 12     191004 Compensated
# # 13     190903     Delayed
# # 14     190905     Delayed
# # 15     190906     Delayed
# # 16     190907     Delayed
# # 17     190915     Delayed
# # 18     190917     Delayed
# # 19     190918     Delayed
# 
# 
# abf_names <- str_extract_all(all_abfs_on_shared_drive$all_abfs, "[[^/]]*[[:punct:]]abf$")
# 
# all_abfs_on_shared_drive$abf_names <- abf_names
# 
# times_matched <- unlist(map(seq(1, nrow(all_abfs_on_shared_drive)), function(i){
#   # if it matches at least once the sum will be >0. It should match at most once.
#   times.matched <- sum(unlist(map(file_groups$Experiment, function(prefix){
#     str_detect(all_abfs_on_shared_drive$abf_names[[i]], paste0(as.character(prefix), "_")) # adding a terminal _ to the search string will prevent 000000a from matching to both 000000 and itself.
#   })))
# 
#   return(times.matched)
# }))
# 
# all_abfs_on_shared_drive$times_matched <- times_matched
# 
# # Looks like it's working as expected
# if (max(times_matched) > 1){
#   all_abfs_on_shared_drive[all_abfs_on_shared_drive$times_matched == max(times_matched), ]
# }
# 
# # matches
# all_abfs_match <- all_abfs_on_shared_drive[all_abfs_on_shared_drive$times_matched == 1, ]
# 
# all_abfs_match$size  <- NA
# all_abfs_match$mtime <- as.POSIXct(NA)
# all_abfs_match$ctime <- as.POSIXct(NA)
# all_abfs_match$atime <- as.POSIXct(NA)
# 
# for (i in seq(1, nrow(all_abfs_match))){
#   current_info <- file.info(paste(start_loc, all_abfs_match[i, "all_abfs"], sep = "/") )
# 
#   all_abfs_match[i, "size"]  <- current_info$size
#   all_abfs_match[i, "mtime"] <- current_info$mtime # file modification
#   all_abfs_match[i, "ctime"] <- current_info$ctime # last status change
#   all_abfs_match[i, "atime"] <- current_info$atime # last access time
# }
# 
# 
# all_abfs_match$abf_names <- all_abfs_match$abf_names %>% unlist()
# 
# 
# # find duplicated abfs
# dupe_abfs <- all_abfs_match %>%
#   select(abf_names) %>%
#   group_by(abf_names) %>%
#   tally() %>%
#   filter(n > 1)
# 
# all_abfs_match$keep <- F
# # Keep all non duplicates
# all_abfs_match[!(all_abfs_match$abf_names %in% as.character(dupe_abfs$abf_names)), "keep"] <- T
# 
# for (i in seq(1, nrow(dupe_abfs))){
#   # if same size, keep oldest
#   if (length( unique( all_abfs_match[all_abfs_match$abf_names == as.character(dupe_abfs[i, "abf_names"]), "size"] ) ) == 1){
#     # unless they're the same, then keep the first.
#     if (length( unique(all_abfs_match[all_abfs_match$abf_names == as.character(dupe_abfs[i, "abf_names"]), "mtime"]) ) == 1){
#       all_abfs_match[all_abfs_match$abf_names == as.character(dupe_abfs[i, "abf_names"]), "keep"][1] <- T
#     } else {
#       warning(paste("Dupe", as.character(i), "has multiple times! Additional logic needed!"))
#       #TODO
#     }
#   } else {
#       warning(paste("Dupe", as.character(i), "has unequal file sizes! Additional logic needed!"))
#   }
# }
# 
# 
# target_abfs <- all_abfs_match[all_abfs_match$keep == T & all_abfs_match$size < 13000000, ]
# # install.packages("gdata")
# target_abfs$size %>% sum() %>% gdata::humanReadable()
# 
# 
# local_abfs <- list.files("C:/Users/Daniel/Documents/Trace_Holding/", pattern = ".abf")
# target_abfs <- target_abfs[!(target_abfs$abf_names %in% local_abfs), ]
# 
# 
# # Copy
# for (i in seq(1, nrow(target_abfs))){
#   temp_path <- paste(start_loc, as.character(target_abfs[i, "all_abfs"]), sep = "/")
#   if (file.exists(temp_path)){
#     file.copy(from = temp_path,
#               to = "C:/Users/Daniel/Documents/Trace_Holding/")
#   } else {
#     warning(paste("Item", as.character(i), "does not exist!"))
#   }
# }
# 
```


## Standard Processing

```{r}
metadata <- metadata %>% 
  mutate(ABFType = case_when(Type %in% c("tevc") ~ "gjvc",
                            Type %in% c("igj","igj_50", "gj") ~ "gjcc",
                            Type %in% c("epsp", "epsp_50") ~ "epsp",
                            Type %in% c("fi_50", "fi") ~ "fi"))

abfs_to_process <- metadata %>% 
  filter(ABFType %in% c("gjvc", "gjcc", "epsp", "fi")) %>% 
  filter(Condition %in% c("Baseline", "Compensated", "Delayed"))

# make expected file names
abfs_to_process <- abfs_to_process %>% 
  mutate(num_zeros = str_length(Recording)) %>% 
  mutate(num_zeros = ifelse(num_zeros == 1, "000", 
                            ifelse(num_zeros == 2, "00", 
                                   ifelse(num_zeros == 3, "0", NA)))) %>% 
  mutate(File = paste0(Experiment, "_", num_zeros, as.character(Recording), ".abf" )) %>% 
  select(-num_zeros)

```


```{r}
# Many experiments with duplicate recordings
abfs_to_process %>% 
  select(Experiment, ABFType, In4, In9, File) %>% 
  gather(key = "Channel", value = "Cell", c("In4", "In9")) %>% 
  group_by(Experiment, Cell, ABFType) %>% 
  tally()

abfs_to_process <- abfs_to_process %>% 
  select(Experiment, ABFType, In4, In9, File) %>% 
  gather(key = "Channel", value = "Cell", c("In4", "In9")) %>% 
  mutate(Processed = F)





# # let's start with one experiment
# # arrange so that gjvc/gjcc are on top.
# abfs_one_exp <- abfs_to_process %>% 
#   filter(Experiment == "190808a") %>% #FIXME 
#   arrange(desc(ABFType), File)
# 
# abfs_one_ABF <- abfs_one_exp[abfs_one_exp$File == "190808a_0018.abf", ]

# current_file <- as.character(abfs_one_ABF[1, "File"])
# current_ABFType <- as.character(abfs_one_ABF[1, "ABFType"])

# Added cols for each 
#Ig   R1c
#"CC"          "R1"          "R11"         "R12"         "Rc"          "Tau_est"     "Tau_std.err" "Vrest"





```  

Process gjvcs
```{r}
tictoc::tic()

process_these_abfs <- abfs_to_process %>% filter(ABFType == "gjvc")

unique_abfs <- unique(process_these_abfs$File)


# unique_abfs[i]

# inelegant, but functional. 
unique_abfs <- unique_abfs[!(unique_abfs %in% c(
  "190903_0027.abf",
  
  "190904_0017.abf", #lm.fit
  "190904_0027.abf", #lm.fit
  
  "190906_0031.abf",
  "190906_0041.abf",
  
  "190915_0023.abf"
))]

# FIXME it seems that "190903_0027.abf" is being run even though it should be rejected\
 # Error in lm.fit(x, y, offset = offset, singular.ok = singular.ok, ...) : 
 #  0 (non-NA) cases 

for (i in seq_along(unique_abfs)){
  print(i)
  # process_these_abfs[process_these_abfs$File == unique_abfs[i], ]

  current_file <- as.character(unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], "File"])[1])
  ## Should we process the current ABF? ====
  current_trace <- check_abf_expected(
    exempt_ABF = force_process_ABF, 
    dir_path = abf_dir_path,
    file_name = current_file,
    file_type = as.character(unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], "ABFType"])[1])
  )
  
  
  if (current_trace$process){
    current_trace <- current_trace$trace
    
    
    out <- process_gjvc_trace(trace = current_trace)
    

          process_these_abfs[process_these_abfs$File == current_file & process_these_abfs$Channel == "In4", "Ig"] <-  out$df[1, "In4_to_In9"]
          process_these_abfs[process_these_abfs$File == current_file & process_these_abfs$Channel == "In9", "Ig"] <-  out$df[1, "In9_to_In4"]
          process_these_abfs[process_these_abfs$File == current_file & process_these_abfs$Channel == "In4", "R1c"] <- out$df[1, "In4_R1c"]
          process_these_abfs[process_these_abfs$File == current_file & process_these_abfs$Channel == "In9", "R1c"] <- out$df[1, "In9_R1c"]
          
          # Save for review: ####
          save_plot(here("data", "data_audits", "gjvc", paste(str_remove(current_file, ".abf"), "gjvc", "trace.pdf", sep = "-")),
                    out$diagnostic_plots$trace, base_height = 7, base_width = 10)
          
          save_plot(here("data", "data_audits", "gjvc", paste(str_remove(current_file, ".abf"), "gjvc", "fit.pdf", sep = "-")),
                    out$diagnostic_plots$fit, base_height = 7, base_width = 10)   
          
          # write.csv(out$df,
          #           here("data", "data_audits", paste(str_remove(input_file, ".abf"), "gjvc", "df.csv", sep = "-"))          )

    
  } 
}


tictoc::toc()

# merge back
abfs_to_process <- full_join(abfs_to_process, process_these_abfs)

```



Process gjccs
```{r}
tictoc::tic()

process_these_abfs <- abfs_to_process %>% filter(ABFType == "gjcc")

unique_abfs <- unique(process_these_abfs$File)

# inelegant, but functional. 
unique_abfs <- unique_abfs[!(unique_abfs %in% c(
"190830_0033.abf",
"190905_0018.abf",
"190906_0032.abf",
"190906_0050.abf",
 "190907_0014.abf",
"190918_0029.abf",
"190924_0021.abf",
"190924_0036.abf",
"190924_0037.abf",
"190926_0016.abf",
"190927a_0014.abf",
"190930_0012.abf",
"191001_0016.abf",
"191001_0017.abf"
 # Error in UseMethod("rename_") : 
 #  no applicable method for 'rename_' applied to an object of class "NULL" 
))]


# unique_abfs <- "191004_0027.abf"
# process_these_abfs <- filter(process_these_abfs, File == "191004_0027.abf") 

# Add cols to fill
process_these_abfs <- full_join(select(process_these_abfs, -Sweep), 
                                expand.grid(Experiment = process_these_abfs$Experiment, 
                                            Sweep = 1:5,
                                            CC = NA,
                                            R1 = NA,
                                            R11 = NA,
                                            R12 = NA,
                                            Rc = NA,
                                            Tau_est = NA,
                                            Tau_std.err = NA,
                                            Vrest = NA))



for (i in seq_along(unique_abfs)){
  print(i)
  # process_these_abfs[process_these_abfs$File == unique_abfs[i], ]

  current_file <- as.character(unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], "File"])[1])
  ## Should we process the current ABF? ====
  current_trace <- check_abf_expected(
    exempt_ABF = force_process_ABF, 
    dir_path = abf_dir_path,
    file_name = current_file,
    file_type = as.character(unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], "ABFType"])[1])
  )
  
  
  if (current_trace$process){
    current_trace <- current_trace$trace
    
    
    out <- process_gjcc_trace(trace = current_trace)
    
    out_df <- out$df 
    out_df <- out_df %>% 
      gather("key", "value", names(out_df)[names(out_df) != "Sweep"]) %>% 
      mutate(key = str_replace_all(key, "In4_", replacement = "In4-"),
             key = str_replace_all(key, "In9_", replacement = "In9-")) %>% 
      separate(col = key, sep = "-", into = c("Ch", "DV")) %>% 
      spread(key = "DV", value = "value") %>% 
      mutate(File = current_file,
             Sweep = as.numeric(Sweep)) %>% 
      rename(Channel = Ch)
    
    
    process_these_abfs <- full_join(process_these_abfs, out_df)

    # row_ids <- out_df %>% select(Sweep, Channel, File) %>% distinct()
    # # inefficient but functional -- merging isn't working properly
    # for (j in seq(1, nrow(row_ids))){
    #   t_sw <- unlist(row_ids[j, "Sweep"])
    #   t_ch <- unlist(row_ids[j, "Channel"])
    #   t_fl <- unlist(row_ids[j, "File"])
    #   
    #   for (param in c("CC", "R1", "R11", "R12", "Rc", "Tau_est", "Tau_std.err", "Vrest")){
    #     process_these_abfs[process_these_abfs$File == t_fl & process_these_abfs$Channel == t_ch & process_these_abfs$Sweep == t_sw, param] <- unlist(out_df[out_df$File == t_fl & out_df$Channel == t_ch & out_df$Sweep == t_sw, param])
    #   }
    # }
    
    
    # Save for review:
    # Estimates of Tau look poor.
    save_plot(here("data", "data_audits", "gjcc", paste(str_remove(current_file, ".abf"), "gjcc", "trace.pdf", sep = "-")),
              out$diagnostic_plots$trace, base_height = 7, base_width = 10)
    
    save_plot(here("data", "data_audits", "gjcc", paste(str_remove(current_file, ".abf"), "gjcc", "segment.pdf", sep = "-")),
              out$diagnostic_plots$segment, base_height = 7, base_width = 10)
    
    save_plot(here("data", "data_audits", "gjcc", paste(str_remove(current_file, ".abf"), "gjcc", "fit_in4.pdf", sep = "-")),
              out$diagnostic_plots$fit_In4, base_height = 7, base_width = 10)
    
    save_plot(here("data", "data_audits", "gjcc", paste(str_remove(current_file, ".abf"), "gjcc", "fit_in9.pdf", sep = "-")),
              out$diagnostic_plots$fit_In9, base_height = 7, base_width = 10)
    
    
         

    
  } 
}

process_these_abfs <- distinct(process_these_abfs) %>% filter(!is.na(R11))
tictoc::toc()



# abfs_to_process <- full_join(abfs_to_process, 
#           process_these_abfs) 

# full_join(abfs_to_process, 
#           process_these_abfs) 
# 
# process_these_abfs[is.na(process_these_abfs$Experiment), ]
# 
# 
# t1 <- abfs_to_process %>% filter(File == "190808a_0019.abf")
# t2 <- process_these_abfs %>% filter(File == "190808a_0019.abf")
# 
# 
# full_join(t1, 
#           select(t2, 
#                  File, Channel, Sweep, CC, R1, R11, R12, Rc, Tau_est, Tau_std.err, Vrest)
#           ) %>% tail()



abfs_to_process <- full_join(
  abfs_to_process, 
  select(process_these_abfs, 
         File, Channel, Sweep, CC, R1, R11, R12, Rc, Tau_est, Tau_std.err, Vrest)
          )
# merge back
# abfs_to_process <- full_join(abfs_to_process, mutate(, Sweep = as.character(Sweep)))

```


### Backup Point
```{r}
save.image(file='myEnvironment.RData')
load('myEnvironment.RData')
```


#### Data review:

gjcc seems to predict bigger junctional conductance, R1 than gjvc would. 
```{r}
# abfs_to_process %>% 
abfs_to_process %>% 
  group_by(Experiment, Cell) %>% 
  mutate(Ig = median(Ig, na.rm = T),
         R1c = median(R1c, na.rm = T)) %>% #tail()
  ggplot(aes(x = Rc^-1, y = abs(Ig)))+
  geom_abline(slope = 1, intercept = 0, color = 'firebrick')+
  # geom_line(data = data.frame(x = seq(1, 50, length.out = 100), y = seq(1, 50, length.out = 100)),
  #                              aes(x=x,y=y), color = "firebrick")+
  geom_point()
  # coord_cartesian(x = c(0, 100))+
  # scale_x_log10()



abfs_to_process %>% 
  group_by(Experiment, Cell) %>% 
  mutate(Ig = median(Ig, na.rm = T),
         R1c = median(R1c, na.rm = T)) %>% #tail()
  unite(uid, Experiment, Cell) %>% 
  ggplot(aes(x = R1, y = R1c, group = uid))+
  # geom_line()+
  geom_point()+
  # geom_abline(slope = 1, intercept = 0, color = 'firebrick')+
  geom_line(data = data.frame(x = seq(1, 13, length.out = 100), 
                              y = seq(1, 13, length.out = 100),
                              uid = "a"),
  aes(x=x,y=y), color = "firebrick")+
  
  scale_x_log10()
  # coord_cartesian(x = c(0, 100))
```



```{r}
# DVs <- c("Ig", "R1c", "CC", "R1", "R11", "R12", "Rc", "Tau_est", "Tau_std.err", "Vrest")
# 
# 
# abfs_medians <- abfs_to_process
# 
# 
# abfs_to_process %>% 
#   select(-Processed) %>% 
#   group_by(Experiment, Cell) %>% 
#   mutate_at(DVs, median, na.rm = T)
# 
# 
# # Experiment is missing from a lot of the files
# # abfs_medians$Experiment <- unlist(transpose(str_split(abfs_medians$File, pattern = "_"))[1])
# 
# # abfs_medians <- abfs_medians %>% 
# #   ungroup() %>% 
# #   select(-Sweep, -ABFType, -Channel, -Processed) %>% 
# #   group_by(Experiment, File, Cell) %>%
# #   mutate_at(DVs, median, na.rm=T) %>%
# #   distinct() %>%
# #   ungroup() %>%
# #   select(-File) %>%
# #   group_by(Experiment, Cell) %>%
# #   mutate_at(DVs, median, na.rm=T) %>%
# #   ungroup() %>%
# #   distinct()
# 
# 
# abfs_medians %>% View
#   

#TODO what is the distance between the automatically and manualy measured values?  
```


```{r}
#TODO Add in manually measured taus for each cell with unreasonable data. 


abfs_to_process

```



```{r}
#FIXME make sure all the inputs are clean before batch processing epsp/fi

abfs_to_process
```

Repeat pattern for epsp

```{r}
tictoc::tic()

process_these_abfs <- abfs_to_process %>% filter(ABFType == "epsp")

# unique_abfs <- unique(process_these_abfs$File)
# 
# # inelegant, but functional. 
# unique_abfs <- unique_abfs[!(unique_abfs %in% c(
# 
# ))]



#FIXME all of the abfs should have complete information. 190830 has cell == NA. 
all_cell_params <- abfs_to_process[abs(abfs_to_process$Tau_est) < 60 & abs(abfs_to_process$Tau_est) > 15 , ] %>% 
  filter(!is.na(Tau_est)) %>% 
  group_by(Experiment, Cell) %>% 
  summarise(
    Experiment = Experiment,
    Cell = Cell,
    Channel = Channel,
    Rin = median(R11, na.rm = T),
    Tau = median(Tau_est, na.rm = T)) 

all_cell_params <- all_cell_params %>% 
  ungroup() %>%
  filter(!is.na(Experiment) & !is.na(Cell)) %>% 
  distinct()
  

# unique_abfs <- "190808a_0014.abf"
unique_abfs <- process_these_abfs[process_these_abfs$Experiment %in% all_cell_params$Experiment, ]$File




# current_cell_params
# 
#   
#   
# current_cell_params <- filter(abfs_to_process, Experiment == "190808a", Cell == 4) %>% #FIXME
#   summarise(
#     Experiment = Experiment,
#     Cell = Cell,
#     Channel = Channel,
#     Rin = median(R11, na.rm = T),
#     Tau = median(Tau_est, na.rm = T)) %>% 
#   distinct()

# # A tibble: 1 x 5
#   Experiment  Cell Channel   Rin   Tau
#   <chr>      <dbl> <chr>   <dbl> <dbl>
# 1 190808a        4 In4      14.3 -11.8


# is that didn't work 5, 6, 7

# [1] 7
# Error in names(input.df) <- c("Time", "Inj") : 
#   attempt to set an attribute on NULL
# In addition: Warning message:
#  Error in names(input.df) <- c("Time", "Inj") : 
#   attempt to set an attribute on NULL 

#FIXME only In4 seems to be processed?
for (i in seq(8, 34)){#seq_along(unique_abfs)){
  print(i)
  
  current_file <- as.character(unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], "File"])[1])
  ## Should we process the current ABF? ====
  current_trace <- check_abf_expected(
    exempt_ABF = force_process_ABF,
    dir_path = abf_dir_path,
    file_name = current_file,
    file_type = as.character(unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], "ABFType"])[1])
  )
  
  if (current_trace$process){
  # handle cells sequentially
  unique_cells <- unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], ]$Cell)
  
  for (j in seq_along(unique_cells)){
    current_cell <- unique_cells[j]
    current_cell_params <- all_cell_params[all_cell_params$Experiment == unlist(str_split(current_file, pattern = "_"))[1]&
                                             all_cell_params$Cell == unique_cells[j], ] %>% 
      distinct()
    
    if(nrow(current_cell_params) > 1){
      warning("current_cell_params contains more than one row! Retaining only the first row.")
      current_cell_params <- current_cell_params[1, ]
    }
    
    if (nrow(current_cell_params)==1){ # if there are no acceptable parameters, current_cell_params will be nrow == 0 
      
        current_trace <- current_trace$trace
        
        if (unlist(current_cell_params[, "Channel"]) == "In4"){
          out <- predict_epsp_responses(trace = current_trace,
                                        tau = abs(as.numeric(unlist(current_cell_params[, "Tau"]))),
                                        rin = as.numeric(unlist(current_cell_params[, "Rin"])),
                                        v_ch = "In4",
                                        i_ch = "In7")
          
          # Save for review:
          saveRDS(current_trace[, c("In4", "In7", "Sweep", "Time")], 
                  here("data", "predicted_voltage", paste(
                    str_remove(current_file, ".abf"), "epsp", "In4", "actual_v.rds", sep = "-")))
          
          saveRDS(out$predictions, 
                  here("data", "predicted_voltage", paste(
                    str_remove(current_file, ".abf"), "epsp", "In4", "predict_v.rds", sep = "-")))
          
          
          
          
          save_plot(here("data", "data_audits", "epsp", paste(
            str_remove(current_file, ".abf"), "epsp", "In4", "segment.pdf", sep = "-")),
            out$diagnostic_plots$trace, base_height = 7, base_width = 10)
          
          
        } else if (unlist(current_cell_params[, "Channel"]) == "In9"){
          out <- predict_epsp_responses(trace = current_trace,
                                        tau = abs(as.numeric(unlist(current_cell_params[, "Tau"]))),
                                        rin = as.numeric(unlist(current_cell_params[, "Rin"])),
                                        v_ch = "In9",
                                        i_ch = "In12")
          
          # Save for review:
          saveRDS(current_trace[, c("In9", "In12", "Sweep", "Time")], 
                  here("data", "predicted_voltage", paste(
                    str_remove(current_file, ".abf"), "epsp", "In9", "actual_v.rds", sep = "-")))
          
          saveRDS(out$predictions, 
                  here("data", "predicted_voltage", paste(
                    str_remove(current_trace, ".abf"), "epsp", "In9", "predict_v.rds", sep = "-")))
          
          save_plot(here("data", "data_audits", "epsp", paste(
            str_remove(current_trace, ".abf"), "epsp", "In9", "segment.pdf", sep = "-")),
            out$diagnostic_plots$trace, base_height = 7, base_width = 10)
        }
      }
    }
  }
}

tictoc::toc()

# for (i in seq_along(unique_abfs)){
#   print(i)
#   # process_these_abfs[process_these_abfs$File == unique_abfs[i], ]
# 
#   current_file <- as.character(unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], "File"])[1])
#   ## Should we process the current ABF? ====
#   current_trace <- check_abf_expected(
#     exempt_ABF = force_process_ABF, 
#     dir_path = abf_dir_path,
#     file_name = current_file,
#     file_type = as.character(unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], "ABFType"])[1])
#   )
#   
#   
#   if (current_trace$process){
#     current_trace <- current_trace$trace
#     
#     
#     out <- process_gjcc_trace(trace = current_trace)
#     
#     out_df <- out$df 
#     out_df <- out_df %>% 
#       gather("key", "value", names(out_df)[names(out_df) != "Sweep"]) %>% 
#       mutate(key = str_replace_all(key, "In4_", replacement = "In4-"),
#              key = str_replace_all(key, "In9_", replacement = "In9-")) %>% 
#       separate(col = key, sep = "-", into = c("Ch", "DV")) %>% 
#       spread(key = "DV", value = "value") %>% 
#       mutate(File = current_file,
#              Sweep = as.numeric(Sweep)) %>% 
#       rename(Channel = Ch)
#     
#     
#     process_these_abfs <- full_join(process_these_abfs, out_df)
# 
#     
#     
#     
#     # Save for review:
#     # Estimates of Tau look poor.
#     save_plot(here("data", "data_audits", "gjcc", paste(str_remove(current_file, ".abf"), "gjcc", "trace.pdf", sep = "-")),
#               out$diagnostic_plots$trace, base_height = 7, base_width = 10)
#     
#     save_plot(here("data", "data_audits", "gjcc", paste(str_remove(current_file, ".abf"), "gjcc", "segment.pdf", sep = "-")),
#               out$diagnostic_plots$segment, base_height = 7, base_width = 10)
#     
#     save_plot(here("data", "data_audits", "gjcc", paste(str_remove(current_file, ".abf"), "gjcc", "fit_in4.pdf", sep = "-")),
#               out$diagnostic_plots$fit_In4, base_height = 7, base_width = 10)
#     
#     save_plot(here("data", "data_audits", "gjcc", paste(str_remove(current_file, ".abf"), "gjcc", "fit_in9.pdf", sep = "-")),
#               out$diagnostic_plots$fit_In9, base_height = 7, base_width = 10)
#     
#     
#          
# 
#     
#   } 
# }
# 
# process_these_abfs <- distinct(process_these_abfs) %>% filter(!is.na(R11))
# tictoc::toc()
# 
# 
# 
# # abfs_to_process <- full_join(abfs_to_process, 
# #           process_these_abfs) 
# 
# full_join(abfs_to_process, 
#           process_these_abfs) 
# 
# process_these_abfs[is.na(process_these_abfs$Experiment), ]
# 
# 
# t1 <- abfs_to_process %>% filter(File == "190808a_0019.abf")
# t2 <- process_these_abfs %>% filter(File == "190808a_0019.abf")
# 
# 
# full_join(t1, 
#           select(t2, 
#                  File, Channel, Sweep, CC, R1, R11, R12, Rc, Tau_est, Tau_std.err, Vrest)
#           ) %>% tail()
# 
# 
# 
# abfs_to_process <- full_join(
#   abfs_to_process, 
#   select(process_these_abfs, 
#          File, Channel, Sweep, CC, R1, R11, R12, Rc, Tau_est, Tau_std.err, Vrest)
#           )
# # merge back
# # abfs_to_process <- full_join(abfs_to_process, mutate(, Sweep = as.character(Sweep)))

```


workspace -- getting metrics from epsp
```{r}
# read in trace
brian2_trace_files <- list.files(here("data", "predicted_voltage"))

brian2_trace_sets <- brian2_trace_files %>% 
  str_remove(pattern = "-actual_v.rds") %>% 
  str_remove(pattern = "-predict_v.rds") %>% 
  unique()

i=1 #FIXME for i in seq all sets
brian2_read_in <- brian2_trace_files[str_detect(brian2_trace_files, brian2_trace_sets[i])]


temp <- map(brian2_read_in, function(read_file){
  temp_predict <- readRDS(here("data", "predicted_voltage", read_file))
  
  if(str_detect(read_file, pattern = "predict_v")){
  #consolidate into one df
  for (j in seq(1, length(temp_predict))){
    temp_predict[[j]]$Sweep <- j
  }
  temp_predict <- do.call(rbind, temp_predict)
  }
  return(temp_predict)
})

names(temp) <- brian2_read_in

temp_a <- temp[str_detect(names(temp), pattern = "actual_v")][[1]]
temp_p <- temp[str_detect(names(temp), pattern = "predict_v")][[1]] %>% as.data.frame() %>% as_tibble()
temp_a$nrow <- seq(1, nrow(temp_a))
temp_p$nrow <- seq(1, nrow(temp_p))
temp_a$Sweep <- as.character(temp_a$Sweep)
temp_p$Sweep <- as.character(temp_p$Sweep)

temp <- full_join(temp_a, select(temp_p, -Time)) %>% select(-nrow)




downsample_data(temp, len = 10000) %>% 
# temp %>% 
  mutate(predicted = predicted - offset) %>% 
  mutate(difference = In4-predicted) %>% 
  ggplot(aes(x = Time))+
  geom_ribbon(aes(ymin=In4, ymax=predicted), fill = "cornflowerblue")+
  geom_line(aes(y=In4), color = "black")+
  geom_line(aes(y=predicted), color = "cornflowerblue", alpha = 0.3)+
  # geom_line(aes(y=difference-offset), color = "purple")+
  facet_grid(Sweep~.)


temp_part1 <- temp %>% 
  mutate(predicted = predicted - offset) %>% 
  mutate(difference = In4-predicted) %>% 
  gather(Key, mV, c("In4", "predicted", "difference")) %>% 
  group_by(Key, Sweep) %>% 
# Min Voltage
  mutate(Min.V = min(mV, na.rm = T)) %>%
  # Baseline voltage
  # Defining as average of the lowest 20% of points
  mutate(Use.in.Base = quantile(mV, probs = .2, na.rm = T)) %>%
  mutate(Use.in.Base = ifelse(mV <= Use.in.Base,
    mV,
    NA
  )) %>%
  mutate(Use.in.Base = mean(Use.in.Base, na.rm = T)) %>%
  # Max voltage
  mutate(Max.V = max(mV, na.rm = T)) %>%
  # Median Voltage
  mutate(Med.V = median(mV, na.rm = T)) %>%
  # Mean Voltage
  mutate(Mean.V = mean(mV, na.rm = T)) %>%
    # # Duration
    # mutate(Max.Time = max(Time, na.rm = T)) %>% 
  # AUC
  # Using Min.V
  mutate(AUC = (mV - Min.V))


# AUC
# Median mV
# Mean mV
# Stimulus correlation
# Max mV

calculated_metrics <- c("Min.V", "Use.in.Base", "Max.V", "Med.V", "Mean.V", "AUC")

temp_part1 <- temp_part1 %>% 
  ungroup() %>% 
  select(-In7, -Time, -offset, -mV) %>% 
  group_by(Key) %>% 
  mutate_at(
    calculated_metrics, 
    median, na.rm =T) %>% 
  distinct() %>% 
  ungroup() 

temp_part1 %>% 
  pivot_longer(cols = calculated_metrics, names_to = "key", values_to = "value") %>% 
  ggplot(aes(key, value, color = Key))+
  geom_point()



distinct(temp_part2)
```

(epsp) How could we slice up the trace? 
```{r}
# ## Here's the stimulus used in the protocol ====
# # sweep duration should be 19.687 seconds
# epsp_stim <- readABF_as_matrix(here("inst", "extdata", "epsp_stim_files", "08 current injection.abf"),
#                   channels = "Axo1I2")
# epsp_stim <- as_tibble(epsp_stim) %>%
#   mutate(Time = Time - min(Time, na.rm = T)) %>%
#   rename(Stim = Axo1I2)
# 
# 
# shading_annotations <- data.frame(
#   starts = c(0.40,
#              4.87,
#              10.74,
#              16.74),
#   next_start = c(4.87,
#                  10.74,
#                  16.74,
#                  19.685),
#   equal_len = c(0.40,
#                 4.87,
#                 10.74,
#                 16.74) + 2.945,
#   on_end = c(2,
#              6.17,
#              12.54, 
#              18.5),
#   equal_on = c(0.40,
#                4.87,
#                10.74,
#                16.74) + 1.30
# )
# 
# ggplot()+
#   geom_vline(xintercept = c(shading_annotations$starts, shading_annotations$equal_len, shading_annotations$next_start, shading_annotations$equal_on), color = "gray")+
#     geom_path(data = epsp_stim, aes(Time, Stim+1.5))+
#   geom_rect(data = shading_annotations, aes(xmin = starts, xmax = next_start, ymin = 0, ymax = 0.5), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[1], color = RColorBrewer::brewer.pal(3, "Set1")[1])+
#   geom_rect(data = shading_annotations, aes(xmin = starts, xmax = equal_len, ymin = -0.5, ymax = 0), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[1], color = RColorBrewer::brewer.pal(3, "Set1")[1])+
#   geom_rect(data = shading_annotations, aes(xmin = starts, xmax = on_end, ymin = -1, ymax = -0.5), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[2], color = RColorBrewer::brewer.pal(3, "Set1")[2])+
#   geom_rect(data = shading_annotations, aes(xmin = starts, xmax = equal_on, ymin = -1.5, ymax = -1), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[2], color = RColorBrewer::brewer.pal(3, "Set1")[2])+
#   theme_classic()+
#   geom_vline(xintercept = 12.54)+
#   ylim(-1.5, 9.5)+
#   labs(title = "Ways to Segement EPSP Stim")
```


Placeholder for fi
```{r}
#TODO
```







## Check vs metadata


