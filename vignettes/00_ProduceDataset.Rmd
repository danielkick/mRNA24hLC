---
title: "Produce Dataset"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(here)
library(readxl)
library(tidyverse)
library(janitor)
library(readABF)

library(zoo)
library(broom)
library(gdata) # for humanReadable, used in checking the files are the expected size
library(minpack.lm) # for use in fit_tau_1term_exp() to get Tau

library(ggsci)
library(cowplot)
library(patchwork)
theme_set(ggplot2::theme_minimal())

library(devtools)
devtools::load_all()
```

## Forward 
This file represents the full preparation of data. Ideally, where we pull processed data (e.g. where I've manually extraced values in clamp fit) will ultimately be replaced with automated, repeatable, and auditable processing. Auditing will be accomplished by including and option to write graphs of the input/output. 

```{r}
# TODO replace manual processing with automatic
# TODO Generate audit output
# TODO edit metadata file so as to allow for specification of traces or regions of traces to be excluded from a file (e.g. drop a segment with loss of voltage clamp)
```

## Build metadata

```{r global params}
use.file.path <- here("inst", "extdata", "ManualDataEphys02.xlsx")

abf_dir_path <- "D:/0000_Traces_mRNA24hLC/"

force_process_ABF <- c("000000_0000.abf")
```

# Working off of non-processed data ----

## Find all the relevant files
```{r}
metadata <- read_excel(use.file.path, sheet = "MetadataEphys")  
# update_type_names <- as_tibble(t(matrix(
#   c("htk", "htk", # ion
#     "a", "a",
#     "htkc", "htkc",
#     "ac", "ac",
#     
#     "tevc", "gjvc", # gj, Rs
#     "igj", "gjcc",
#     "igj_50", "gjcc",
#     
#     "fi_50", "fi", # excitability
#     "fi", "fi",
#     "epsp", "epsp",
#     "epsp_50", "epsp",
#     
#     "gj", "Unknown" #FIXME what are these?
#   ), nrow = 2)))
# names(update_type_names) <- c("InFile", "NewType")
```

## Check on hand abfs
```{r}
# Check for missing files relative to the abf directory

# Find all the traces specified in the metadata file (i.e. where type is not NA) and check to see if they exist in the `abf_dir`

absent_traces <- metadata[!is.na(metadata$Type), ]
absent_traces$Exists <- F

abf_dir <- list.files(abf_dir_path)
for (i in seq(1, nrow(absent_traces))){
  # make the file name
  num_zeros <- 4-nchar(absent_traces[i, "Recording"])
  num_zeros <- case_when(num_zeros == 0 ~ "",
                         num_zeros == 1 ~ "0",
                         num_zeros == 2 ~ "00",
                         num_zeros == 3 ~ "000")
  
  abf_name <- paste(as.character(absent_traces[i, "Experiment"]),
                    paste0(num_zeros, as.character(absent_traces[i, "Recording"]), ".abf"), 
                    sep = "_")
  # check if it exists in the dir
  absent_traces[i, "Exists"] <- abf_name %in% abf_dir
  
  # print(abf_name)
}

absent_traces_to_find <- absent_traces %>% 
  filter(Exists == F) %>% 
  mutate(RecordingLeadZeros = case_when((4 - nchar(Recording)) == 0 ~ "",
                                        (4 - nchar(Recording)) == 1 ~ "0",
                                        (4 - nchar(Recording)) == 2 ~ "00",
                                        (4 - nchar(Recording)) == 3 ~ "000")) %>% 
  mutate(FileName = paste0(Experiment, "_", RecordingLeadZeros, Recording, ".abf"))
```


## Finding missing ABFs on the shared drive w/o Microsoft's search
```{r}
# Indexing all the ABFs in my directory on the shared drive is time consumming (~55 minutes over the VPN). It should only be done when an index doesn't exist already of if there's reason to beleave the index is no longer accurate. 
if (!file.exists(here("inst", "extdata", "shared_drive_abf_index.csv"))){
  start_loc <- "S:/Data_Daniel"
  
  tic <- Sys.time()
  all_abfs <- list.files("S:/Data_Daniel", "*.abf", recursive = T)
  toc <- Sys.time()
  print(toc - tic)
  
  write.csv(as.data.frame(all_abfs), file = here("inst", "extdata", "shared_drive_abf_index.csv"))
  rm(list = "all_abfs")
} 
all_abfs_on_shared_drive <- read.csv(here("inst", "extdata", "shared_drive_abf_index.csv"))
```


```{r}
all_abfs_on_shared_drive <- all_abfs_on_shared_drive %>% 
  as_tibble() %>% 
  mutate(all_abfs = as.character(all_abfs))

broken_path <- str_split(all_abfs_on_shared_drive$all_abfs, pattern = "/")

all_abfs_on_shared_drive$FileName <- map_chr(
  seq_along(broken_path), function(i){
  broken_path[[i]][[length(broken_path[[i]])]]
})


# if there's a match pull the path
absent_traces_to_find$PathOnShared <- NA

for (i in 1:nrow(absent_traces_to_find)){
  if(as.character(absent_traces_to_find[i, "FileName"]) %in% all_abfs_on_shared_drive$FileName){
    # get path
    absent_traces_to_find[i, "PathOnShared"] <- all_abfs_on_shared_drive[all_abfs_on_shared_drive$FileName == as.character(absent_traces_to_find[i, "FileName"]), "all_abfs"]

  } else {
    absent_traces_to_find[i, "PathOnShared"] <- NA
  }
}

# move from server
absent_traces_to_find$moved <- F
# Check for file's existence, if it's there move it and tag it as moved.
for (i in 1:nrow(absent_traces_to_find)){
  if(!is.na(absent_traces_to_find[i, "PathOnShared"])){
    file_to_move <- paste0("S:/Data_Daniel", "/", as.character(absent_traces_to_find[i, "PathOnShared"]))
    
    if (file.exists(file_to_move)){
      file.copy(
        from = file_to_move,
        to = paste0(
          abf_dir_path,
          absent_traces_to_find[i, "FileName"]  
        )
      )
      
      absent_traces_to_find[i, "moved"]  <- T
    }
  }
}

# After everything's moved, manually search for the rest. 

manually_find <- absent_traces_to_find %>% 
  filter(moved == F) %>% 
  select(Experiment, Page, Recording, Type, TEA, Condition, FileName)
write.csv(manually_find, file = here("data", "manually_find_ABFs.csv"))


# Can't seem to find experiment 190917a
# looking at manually processed data I don't see any evidence of it. Possibly it didn't get moved to the shared drive? 
#FIXME go and check the lab computer to make sure the missing file isn't there. 
metadata <- metadata[metadata$Experiment != "190917a", ]
```

```{r depricated}
# 
# 
# abf_names <- str_extract_all(all_abfs_on_shared_drive$all_abfs, "[[^/]]*[[:punct:]]abf$")
# 
# all_abfs_on_shared_drive$abf_names <- abf_names
# 
# 
# 
# # lapply(mtcars, function(x){x[length(x)]})
# 
# 
# i=1
# as.character(absent_traces_to_find[i, "FileName"]) %in% unlist(all_abfs_on_shared_drive$abf_names)
# 
# 
# # > file_groups
# #    Experiment       Group
# # 1      190924    Baseline
# # 2     190924a    Baseline
# # 3      190926    Baseline
# # 4      190927    Baseline
# # 5     190927a    Baseline
# # 6      190930    Baseline
# # 7     190930a    Baseline
# # 8     190808a Compensated
# # 9      190830 Compensated
# # 10     190904 Compensated
# # 11     191001 Compensated
# # 12     191004 Compensated
# # 13     190903     Delayed
# # 14     190905     Delayed
# # 15     190906     Delayed
# # 16     190907     Delayed
# # 17     190915     Delayed
# # 18     190917     Delayed
# # 19     190918     Delayed
# 
# 
# abf_names <- str_extract_all(all_abfs_on_shared_drive$all_abfs, "[[^/]]*[[:punct:]]abf$")
# 
# all_abfs_on_shared_drive$abf_names <- abf_names
# 
# times_matched <- unlist(map(seq(1, nrow(all_abfs_on_shared_drive)), function(i){
#   # if it matches at least once the sum will be >0. It should match at most once.
#   times.matched <- sum(unlist(map(file_groups$Experiment, function(prefix){
#     str_detect(all_abfs_on_shared_drive$abf_names[[i]], paste0(as.character(prefix), "_")) # adding a terminal _ to the search string will prevent 000000a from matching to both 000000 and itself.
#   })))
# 
#   return(times.matched)
# }))
# 
# all_abfs_on_shared_drive$times_matched <- times_matched
# 
# # Looks like it's working as expected
# if (max(times_matched) > 1){
#   all_abfs_on_shared_drive[all_abfs_on_shared_drive$times_matched == max(times_matched), ]
# }
# 
# # matches
# all_abfs_match <- all_abfs_on_shared_drive[all_abfs_on_shared_drive$times_matched == 1, ]
# 
# all_abfs_match$size  <- NA
# all_abfs_match$mtime <- as.POSIXct(NA)
# all_abfs_match$ctime <- as.POSIXct(NA)
# all_abfs_match$atime <- as.POSIXct(NA)
# 
# for (i in seq(1, nrow(all_abfs_match))){
#   current_info <- file.info(paste(start_loc, all_abfs_match[i, "all_abfs"], sep = "/") )
# 
#   all_abfs_match[i, "size"]  <- current_info$size
#   all_abfs_match[i, "mtime"] <- current_info$mtime # file modification
#   all_abfs_match[i, "ctime"] <- current_info$ctime # last status change
#   all_abfs_match[i, "atime"] <- current_info$atime # last access time
# }
# 
# 
# all_abfs_match$abf_names <- all_abfs_match$abf_names %>% unlist()
# 
# 
# # find duplicated abfs
# dupe_abfs <- all_abfs_match %>%
#   select(abf_names) %>%
#   group_by(abf_names) %>%
#   tally() %>%
#   filter(n > 1)
# 
# all_abfs_match$keep <- F
# # Keep all non duplicates
# all_abfs_match[!(all_abfs_match$abf_names %in% as.character(dupe_abfs$abf_names)), "keep"] <- T
# 
# for (i in seq(1, nrow(dupe_abfs))){
#   # if same size, keep oldest
#   if (length( unique( all_abfs_match[all_abfs_match$abf_names == as.character(dupe_abfs[i, "abf_names"]), "size"] ) ) == 1){
#     # unless they're the same, then keep the first.
#     if (length( unique(all_abfs_match[all_abfs_match$abf_names == as.character(dupe_abfs[i, "abf_names"]), "mtime"]) ) == 1){
#       all_abfs_match[all_abfs_match$abf_names == as.character(dupe_abfs[i, "abf_names"]), "keep"][1] <- T
#     } else {
#       warning(paste("Dupe", as.character(i), "has multiple times! Additional logic needed!"))
#       #TODO
#     }
#   } else {
#       warning(paste("Dupe", as.character(i), "has unequal file sizes! Additional logic needed!"))
#   }
# }
# 
# 
# target_abfs <- all_abfs_match[all_abfs_match$keep == T & all_abfs_match$size < 13000000, ]
# # install.packages("gdata")
# target_abfs$size %>% sum() %>% gdata::humanReadable()
# 
# 
# local_abfs <- list.files("C:/Users/Daniel/Documents/Trace_Holding/", pattern = ".abf")
# target_abfs <- target_abfs[!(target_abfs$abf_names %in% local_abfs), ]
# 
# 
# # Copy
# for (i in seq(1, nrow(target_abfs))){
#   temp_path <- paste(start_loc, as.character(target_abfs[i, "all_abfs"]), sep = "/")
#   if (file.exists(temp_path)){
#     file.copy(from = temp_path,
#               to = "C:/Users/Daniel/Documents/Trace_Holding/")
#   } else {
#     warning(paste("Item", as.character(i), "does not exist!"))
#   }
# }
# 
```


## Automated processing of passive properties

```{r}
metadata <- metadata %>% 
  mutate(ABFType = case_when(Type %in% c("tevc") ~ "gjvc",
                            Type %in% c("igj","igj_50", "gj") ~ "gjcc",
                            Type %in% c("epsp", "epsp_50") ~ "epsp",
                            Type %in% c("fi_50", "fi") ~ "fi"))

abfs_to_process <- metadata %>% 
  filter(ABFType %in% c("gjvc", "gjcc", "epsp", "fi")) %>% 
  filter(Condition %in% c("Baseline", "Compensated", "Delayed"))

# make expected file names
abfs_to_process <- abfs_to_process %>% 
  mutate(num_zeros = str_length(Recording)) %>% 
  mutate(num_zeros = ifelse(num_zeros == 1, "000", 
                            ifelse(num_zeros == 2, "00", 
                                   ifelse(num_zeros == 3, "0", NA)))) %>% 
  mutate(File = paste0(Experiment, "_", num_zeros, as.character(Recording), ".abf" )) %>% 
  select(-num_zeros)

```


```{r}
# Many experiments with duplicate recordings
abfs_to_process %>% 
  select(Experiment, ABFType, In4, In9, File) %>% 
  gather(key = "Channel", value = "Cell", c("In4", "In9")) %>% 
  group_by(Experiment, Cell, ABFType) %>% 
  tally()

abfs_to_process <- abfs_to_process %>% 
  select(Experiment, ABFType, In4, In9, File) %>% 
  gather(key = "Channel", value = "Cell", c("In4", "In9")) %>% 
  mutate(Processed = F)





# # let's start with one experiment
# # arrange so that gjvc/gjcc are on top.
# abfs_one_exp <- abfs_to_process %>% 
#   filter(Experiment == "190808a") %>% #FIXME 
#   arrange(desc(ABFType), File)
# 
# abfs_one_ABF <- abfs_one_exp[abfs_one_exp$File == "190808a_0018.abf", ]

# current_file <- as.character(abfs_one_ABF[1, "File"])
# current_ABFType <- as.character(abfs_one_ABF[1, "ABFType"])

# Added cols for each 
#Ig   R1c
#"CC"          "R1"          "R11"         "R12"         "Rc"          "Tau_est"     "Tau_std.err" "Vrest"





```  

Process gjvcs
```{r}
tictoc::tic()

process_these_abfs <- abfs_to_process %>% filter(ABFType == "gjvc")

unique_abfs <- unique(process_these_abfs$File)


# unique_abfs[i]

# inelegant, but functional. 
unique_abfs <- unique_abfs[!(unique_abfs %in% c(
  "190903_0027.abf",
  
  "190904_0017.abf", #lm.fit
  "190904_0027.abf", #lm.fit
  
  "190906_0031.abf",
  "190906_0041.abf",
  
  "190915_0023.abf"
))]

# FIXME it seems that "190903_0027.abf" is being run even though it should be rejected\
 # Error in lm.fit(x, y, offset = offset, singular.ok = singular.ok, ...) : 
 #  0 (non-NA) cases 

for (i in seq_along(unique_abfs)){
  print(i)
  # process_these_abfs[process_these_abfs$File == unique_abfs[i], ]

  current_file <- as.character(unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], "File"])[1])
  ## Should we process the current ABF? ====
  current_trace <- check_abf_expected(
    exempt_ABF = force_process_ABF, 
    dir_path = abf_dir_path,
    file_name = current_file,
    file_type = as.character(unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], "ABFType"])[1])
  )
  
  
  if (current_trace$process){
    current_trace <- current_trace$trace
    
    
    out <- process_gjvc_trace(trace = current_trace)
    

          process_these_abfs[process_these_abfs$File == current_file & process_these_abfs$Channel == "In4", "Ig"] <-  out$df[1, "In4_to_In9"]
          process_these_abfs[process_these_abfs$File == current_file & process_these_abfs$Channel == "In9", "Ig"] <-  out$df[1, "In9_to_In4"]
          process_these_abfs[process_these_abfs$File == current_file & process_these_abfs$Channel == "In4", "R1c"] <- out$df[1, "In4_R1c"]
          process_these_abfs[process_these_abfs$File == current_file & process_these_abfs$Channel == "In9", "R1c"] <- out$df[1, "In9_R1c"]
          
          # Save for review: ####
          save_plot(here("data", "data_audits", "gjvc", paste(str_remove(current_file, ".abf"), "gjvc", "trace.pdf", sep = "-")),
                    out$diagnostic_plots$trace, base_height = 7, base_width = 10)
          
          save_plot(here("data", "data_audits", "gjvc", paste(str_remove(current_file, ".abf"), "gjvc", "fit.pdf", sep = "-")),
                    out$diagnostic_plots$fit, base_height = 7, base_width = 10)   
          
          # write.csv(out$df,
          #           here("data", "data_audits", paste(str_remove(input_file, ".abf"), "gjvc", "df.csv", sep = "-"))          )

    
  } 
}


tictoc::toc()

# merge back
abfs_to_process <- full_join(abfs_to_process, process_these_abfs)

```



Process gjccs
```{r}
tictoc::tic()

process_these_abfs <- abfs_to_process %>% filter(ABFType == "gjcc")

unique_abfs <- unique(process_these_abfs$File)

# inelegant, but functional. 
unique_abfs <- unique_abfs[!(unique_abfs %in% c(
"190830_0033.abf",
"190905_0018.abf",
"190906_0032.abf",
"190906_0050.abf",
 "190907_0014.abf",
"190918_0029.abf",
"190924_0021.abf",
"190924_0036.abf",
"190924_0037.abf",
"190926_0016.abf",
"190927a_0014.abf",
"190930_0012.abf",
"191001_0016.abf",
"191001_0017.abf"
 # Error in UseMethod("rename_") : 
 #  no applicable method for 'rename_' applied to an object of class "NULL" 
))]


# unique_abfs <- "191004_0027.abf"
# process_these_abfs <- filter(process_these_abfs, File == "191004_0027.abf") 

# Add cols to fill
process_these_abfs <- full_join(select(process_these_abfs, -Sweep), 
                                expand.grid(Experiment = process_these_abfs$Experiment, 
                                            Sweep = 1:5,
                                            CC = NA,
                                            R1 = NA,
                                            R11 = NA,
                                            R12 = NA,
                                            Rc = NA,
                                            Tau_est = NA,
                                            Tau_std.err = NA,
                                            Vrest = NA))



for (i in seq_along(unique_abfs)){
  print(i)
  # process_these_abfs[process_these_abfs$File == unique_abfs[i], ]

  current_file <- as.character(unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], "File"])[1])
  ## Should we process the current ABF? ====
  current_trace <- check_abf_expected(
    exempt_ABF = force_process_ABF, 
    dir_path = abf_dir_path,
    file_name = current_file,
    file_type = as.character(unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], "ABFType"])[1])
  )
  
  
  if (current_trace$process){
    current_trace <- current_trace$trace
    
    
    out <- process_gjcc_trace(trace = current_trace)
    
    out_df <- out$df 
    out_df <- out_df %>% 
      gather("key", "value", names(out_df)[names(out_df) != "Sweep"]) %>% 
      mutate(key = str_replace_all(key, "In4_", replacement = "In4-"),
             key = str_replace_all(key, "In9_", replacement = "In9-")) %>% 
      separate(col = key, sep = "-", into = c("Ch", "DV")) %>% 
      spread(key = "DV", value = "value") %>% 
      mutate(File = current_file,
             Sweep = as.numeric(Sweep)) %>% 
      rename(Channel = Ch)
    
    
    process_these_abfs <- full_join(process_these_abfs, out_df)

    # row_ids <- out_df %>% select(Sweep, Channel, File) %>% distinct()
    # # inefficient but functional -- merging isn't working properly
    # for (j in seq(1, nrow(row_ids))){
    #   t_sw <- unlist(row_ids[j, "Sweep"])
    #   t_ch <- unlist(row_ids[j, "Channel"])
    #   t_fl <- unlist(row_ids[j, "File"])
    #   
    #   for (param in c("CC", "R1", "R11", "R12", "Rc", "Tau_est", "Tau_std.err", "Vrest")){
    #     process_these_abfs[process_these_abfs$File == t_fl & process_these_abfs$Channel == t_ch & process_these_abfs$Sweep == t_sw, param] <- unlist(out_df[out_df$File == t_fl & out_df$Channel == t_ch & out_df$Sweep == t_sw, param])
    #   }
    # }
    
    
    # Save for review:
    # Estimates of Tau look poor.
    save_plot(here("data", "data_audits", "gjcc", paste(str_remove(current_file, ".abf"), "gjcc", "trace.pdf", sep = "-")),
              out$diagnostic_plots$trace, base_height = 7, base_width = 10)
    
    save_plot(here("data", "data_audits", "gjcc", paste(str_remove(current_file, ".abf"), "gjcc", "segment.pdf", sep = "-")),
              out$diagnostic_plots$segment, base_height = 7, base_width = 10)
    
    save_plot(here("data", "data_audits", "gjcc", paste(str_remove(current_file, ".abf"), "gjcc", "fit_in4.pdf", sep = "-")),
              out$diagnostic_plots$fit_In4, base_height = 7, base_width = 10)
    
    save_plot(here("data", "data_audits", "gjcc", paste(str_remove(current_file, ".abf"), "gjcc", "fit_in9.pdf", sep = "-")),
              out$diagnostic_plots$fit_In9, base_height = 7, base_width = 10)
    
    
         

    
  } 
}

process_these_abfs <- distinct(process_these_abfs) %>% filter(!is.na(R11))
tictoc::toc()



# abfs_to_process <- full_join(abfs_to_process, 
#           process_these_abfs) 

# full_join(abfs_to_process, 
#           process_these_abfs) 
# 
# process_these_abfs[is.na(process_these_abfs$Experiment), ]
# 
# 
# t1 <- abfs_to_process %>% filter(File == "190808a_0019.abf")
# t2 <- process_these_abfs %>% filter(File == "190808a_0019.abf")
# 
# 
# full_join(t1, 
#           select(t2, 
#                  File, Channel, Sweep, CC, R1, R11, R12, Rc, Tau_est, Tau_std.err, Vrest)
#           ) %>% tail()



abfs_to_process <- full_join(
  abfs_to_process, 
  select(process_these_abfs, 
         File, Channel, Sweep, CC, R1, R11, R12, Rc, Tau_est, Tau_std.err, Vrest)
          )
# merge back
# abfs_to_process <- full_join(abfs_to_process, mutate(, Sweep = as.character(Sweep)))

```


### Backup Point
```{r}
save.image(file='myEnvironment.RData')
load('myEnvironment.RData')
```


#### Data review:

gjcc seems to predict bigger junctional conductance, R1 than gjvc would. 
```{r}
# abfs_to_process %>% 
abfs_to_process %>% 
  group_by(Experiment, Cell) %>% 
  mutate(Ig = median(Ig, na.rm = T),
         R1c = median(R1c, na.rm = T)) %>% #tail()
  ggplot(aes(x = Rc^-1, y = abs(Ig)))+
  geom_abline(slope = 1, intercept = 0, color = 'firebrick')+
  # geom_line(data = data.frame(x = seq(1, 50, length.out = 100), y = seq(1, 50, length.out = 100)),
  #                              aes(x=x,y=y), color = "firebrick")+
  geom_point()
  # coord_cartesian(x = c(0, 100))+
  # scale_x_log10()



abfs_to_process %>% 
  group_by(Experiment, Cell) %>% 
  mutate(Ig = median(Ig, na.rm = T),
         R1c = median(R1c, na.rm = T)) %>% #tail()
  unite(uid, Experiment, Cell) %>% 
  ggplot(aes(x = R1, y = R1c, group = uid))+
  # geom_line()+
  geom_point()+
  # geom_abline(slope = 1, intercept = 0, color = 'firebrick')+
  geom_line(data = data.frame(x = seq(1, 13, length.out = 100), 
                              y = seq(1, 13, length.out = 100),
                              uid = "a"),
  aes(x=x,y=y), color = "firebrick")+
  
  scale_x_log10()
  # coord_cartesian(x = c(0, 100))
```



```{r}
# DVs <- c("Ig", "R1c", "CC", "R1", "R11", "R12", "Rc", "Tau_est", "Tau_std.err", "Vrest")
# 
# 
# abfs_medians <- abfs_to_process
# 
# 
# abfs_to_process %>% 
#   select(-Processed) %>% 
#   group_by(Experiment, Cell) %>% 
#   mutate_at(DVs, median, na.rm = T)
# 
# 
# # Experiment is missing from a lot of the files
# # abfs_medians$Experiment <- unlist(transpose(str_split(abfs_medians$File, pattern = "_"))[1])
# 
# # abfs_medians <- abfs_medians %>% 
# #   ungroup() %>% 
# #   select(-Sweep, -ABFType, -Channel, -Processed) %>% 
# #   group_by(Experiment, File, Cell) %>%
# #   mutate_at(DVs, median, na.rm=T) %>%
# #   distinct() %>%
# #   ungroup() %>%
# #   select(-File) %>%
# #   group_by(Experiment, Cell) %>%
# #   mutate_at(DVs, median, na.rm=T) %>%
# #   ungroup() %>%
# #   distinct()
# 
# 
# abfs_medians %>% View
#   

#TODO what is the distance between the automatically and manualy measured values?  
```


```{r}
#TODO Add in manually measured taus for each cell with unreasonable data. 


abfs_to_process

```



```{r}
#FIXME make sure all the inputs are clean before batch processing epsp/fi

abfs_to_process
```

Repeat pattern for epsp

```{r}
tictoc::tic()

process_these_abfs <- abfs_to_process %>% filter(ABFType == "epsp")

# unique_abfs <- unique(process_these_abfs$File)
# 
# # inelegant, but functional. 
# unique_abfs <- unique_abfs[!(unique_abfs %in% c(
# 
# ))]



#FIXME all of the abfs should have complete information. 190830 has cell == NA. 
all_cell_params <- abfs_to_process[abs(abfs_to_process$Tau_est) < 60 & abs(abfs_to_process$Tau_est) > 15 , ] %>% 
  filter(!is.na(Tau_est)) %>% 
  group_by(Experiment, Cell) %>% 
  summarise(
    Experiment = Experiment,
    Cell = Cell,
    Channel = Channel,
    Rin = median(R11, na.rm = T),
    Tau = median(Tau_est, na.rm = T)) 

all_cell_params <- all_cell_params %>% 
  ungroup() %>%
  filter(!is.na(Experiment) & !is.na(Cell)) %>% 
  distinct()
  

# unique_abfs <- "190808a_0014.abf"
unique_abfs <- process_these_abfs[process_these_abfs$Experiment %in% all_cell_params$Experiment, ]$File




# current_cell_params
# 
#   
#   
# current_cell_params <- filter(abfs_to_process, Experiment == "190808a", Cell == 4) %>% #FIXME
#   summarise(
#     Experiment = Experiment,
#     Cell = Cell,
#     Channel = Channel,
#     Rin = median(R11, na.rm = T),
#     Tau = median(Tau_est, na.rm = T)) %>% 
#   distinct()

# # A tibble: 1 x 5
#   Experiment  Cell Channel   Rin   Tau
#   <chr>      <dbl> <chr>   <dbl> <dbl>
# 1 190808a        4 In4      14.3 -11.8


# is that didn't work 5, 6, 7

# [1] 7
# Error in names(input.df) <- c("Time", "Inj") : 
#   attempt to set an attribute on NULL
# In addition: Warning message:
#  Error in names(input.df) <- c("Time", "Inj") : 
#   attempt to set an attribute on NULL 

#FIXME only In4 seems to be processed?
for (i in seq(8, 34)){#seq_along(unique_abfs)){
  print(i)
  
  current_file <- as.character(unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], "File"])[1])
  ## Should we process the current ABF? ====
  current_trace <- check_abf_expected(
    exempt_ABF = force_process_ABF,
    dir_path = abf_dir_path,
    file_name = current_file,
    file_type = as.character(unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], "ABFType"])[1])
  )
  
  if (current_trace$process){
  # handle cells sequentially
  unique_cells <- unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], ]$Cell)
  
  for (j in seq_along(unique_cells)){
    current_cell <- unique_cells[j]
    current_cell_params <- all_cell_params[all_cell_params$Experiment == unlist(str_split(current_file, pattern = "_"))[1]&
                                             all_cell_params$Cell == unique_cells[j], ] %>% 
      distinct()
    
    if(nrow(current_cell_params) > 1){
      warning("current_cell_params contains more than one row! Retaining only the first row.")
      current_cell_params <- current_cell_params[1, ]
    }
    
    if (nrow(current_cell_params)==1){ # if there are no acceptable parameters, current_cell_params will be nrow == 0 
      
        current_trace <- current_trace$trace
        
        if (unlist(current_cell_params[, "Channel"]) == "In4"){
          out <- predict_epsp_responses(trace = current_trace,
                                        tau = abs(as.numeric(unlist(current_cell_params[, "Tau"]))),
                                        rin = as.numeric(unlist(current_cell_params[, "Rin"])),
                                        v_ch = "In4",
                                        i_ch = "In7")
          
          # Save for review:
          saveRDS(current_trace[, c("In4", "In7", "Sweep", "Time")], 
                  here("data", "predicted_voltage", paste(
                    str_remove(current_file, ".abf"), "epsp", "In4", "actual_v.rds", sep = "-")))
          
          saveRDS(out$predictions, 
                  here("data", "predicted_voltage", paste(
                    str_remove(current_file, ".abf"), "epsp", "In4", "predict_v.rds", sep = "-")))
          
          
          
          
          save_plot(here("data", "data_audits", "epsp", paste(
            str_remove(current_file, ".abf"), "epsp", "In4", "segment.pdf", sep = "-")),
            out$diagnostic_plots$trace, base_height = 7, base_width = 10)
          
          
        } else if (unlist(current_cell_params[, "Channel"]) == "In9"){
          out <- predict_epsp_responses(trace = current_trace,
                                        tau = abs(as.numeric(unlist(current_cell_params[, "Tau"]))),
                                        rin = as.numeric(unlist(current_cell_params[, "Rin"])),
                                        v_ch = "In9",
                                        i_ch = "In12")
          
          # Save for review:
          saveRDS(current_trace[, c("In9", "In12", "Sweep", "Time")], 
                  here("data", "predicted_voltage", paste(
                    str_remove(current_file, ".abf"), "epsp", "In9", "actual_v.rds", sep = "-")))
          
          saveRDS(out$predictions, 
                  here("data", "predicted_voltage", paste(
                    str_remove(current_trace, ".abf"), "epsp", "In9", "predict_v.rds", sep = "-")))
          
          save_plot(here("data", "data_audits", "epsp", paste(
            str_remove(current_trace, ".abf"), "epsp", "In9", "segment.pdf", sep = "-")),
            out$diagnostic_plots$trace, base_height = 7, base_width = 10)
        }
      }
    }
  }
}

tictoc::toc()

# for (i in seq_along(unique_abfs)){
#   print(i)
#   # process_these_abfs[process_these_abfs$File == unique_abfs[i], ]
# 
#   current_file <- as.character(unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], "File"])[1])
#   ## Should we process the current ABF? ====
#   current_trace <- check_abf_expected(
#     exempt_ABF = force_process_ABF, 
#     dir_path = abf_dir_path,
#     file_name = current_file,
#     file_type = as.character(unlist(process_these_abfs[process_these_abfs$File == unique_abfs[i], "ABFType"])[1])
#   )
#   
#   
#   if (current_trace$process){
#     current_trace <- current_trace$trace
#     
#     
#     out <- process_gjcc_trace(trace = current_trace)
#     
#     out_df <- out$df 
#     out_df <- out_df %>% 
#       gather("key", "value", names(out_df)[names(out_df) != "Sweep"]) %>% 
#       mutate(key = str_replace_all(key, "In4_", replacement = "In4-"),
#              key = str_replace_all(key, "In9_", replacement = "In9-")) %>% 
#       separate(col = key, sep = "-", into = c("Ch", "DV")) %>% 
#       spread(key = "DV", value = "value") %>% 
#       mutate(File = current_file,
#              Sweep = as.numeric(Sweep)) %>% 
#       rename(Channel = Ch)
#     
#     
#     process_these_abfs <- full_join(process_these_abfs, out_df)
# 
#     
#     
#     
#     # Save for review:
#     # Estimates of Tau look poor.
#     save_plot(here("data", "data_audits", "gjcc", paste(str_remove(current_file, ".abf"), "gjcc", "trace.pdf", sep = "-")),
#               out$diagnostic_plots$trace, base_height = 7, base_width = 10)
#     
#     save_plot(here("data", "data_audits", "gjcc", paste(str_remove(current_file, ".abf"), "gjcc", "segment.pdf", sep = "-")),
#               out$diagnostic_plots$segment, base_height = 7, base_width = 10)
#     
#     save_plot(here("data", "data_audits", "gjcc", paste(str_remove(current_file, ".abf"), "gjcc", "fit_in4.pdf", sep = "-")),
#               out$diagnostic_plots$fit_In4, base_height = 7, base_width = 10)
#     
#     save_plot(here("data", "data_audits", "gjcc", paste(str_remove(current_file, ".abf"), "gjcc", "fit_in9.pdf", sep = "-")),
#               out$diagnostic_plots$fit_In9, base_height = 7, base_width = 10)
#     
#     
#          
# 
#     
#   } 
# }
# 
# process_these_abfs <- distinct(process_these_abfs) %>% filter(!is.na(R11))
# tictoc::toc()
# 
# 
# 
# # abfs_to_process <- full_join(abfs_to_process, 
# #           process_these_abfs) 
# 
# full_join(abfs_to_process, 
#           process_these_abfs) 
# 
# process_these_abfs[is.na(process_these_abfs$Experiment), ]
# 
# 
# t1 <- abfs_to_process %>% filter(File == "190808a_0019.abf")
# t2 <- process_these_abfs %>% filter(File == "190808a_0019.abf")
# 
# 
# full_join(t1, 
#           select(t2, 
#                  File, Channel, Sweep, CC, R1, R11, R12, Rc, Tau_est, Tau_std.err, Vrest)
#           ) %>% tail()
# 
# 
# 
# abfs_to_process <- full_join(
#   abfs_to_process, 
#   select(process_these_abfs, 
#          File, Channel, Sweep, CC, R1, R11, R12, Rc, Tau_est, Tau_std.err, Vrest)
#           )
# # merge back
# # abfs_to_process <- full_join(abfs_to_process, mutate(, Sweep = as.character(Sweep)))

```


workspace -- getting metrics from epsp
```{r eval=FALSE}
#TODO after discussion on 09/28 extract whatever metrics we've decided are most represntative for epsp

# read in trace
brian2_trace_files <- list.files(here("data", "predicted_voltage"))

brian2_trace_sets <- brian2_trace_files %>% 
  str_remove(pattern = "-actual_v.rds") %>% 
  str_remove(pattern = "-predict_v.rds") %>% 
  unique()

i=1 #FIXME for i in seq all sets
brian2_read_in <- brian2_trace_files[str_detect(brian2_trace_files, brian2_trace_sets[i])]


temp <- map(brian2_read_in, function(read_file){
  temp_predict <- readRDS(here("data", "predicted_voltage", read_file))
  
  if(str_detect(read_file, pattern = "predict_v")){
  #consolidate into one df
  for (j in seq(1, length(temp_predict))){
    temp_predict[[j]]$Sweep <- j
  }
  temp_predict <- do.call(rbind, temp_predict)
  }
  return(temp_predict)
})

names(temp) <- brian2_read_in

temp_a <- temp[str_detect(names(temp), pattern = "actual_v")][[1]]
temp_p <- temp[str_detect(names(temp), pattern = "predict_v")][[1]] %>% as.data.frame() %>% as_tibble()
temp_a$nrow <- seq(1, nrow(temp_a))
temp_p$nrow <- seq(1, nrow(temp_p))
temp_a$Sweep <- as.character(temp_a$Sweep)
temp_p$Sweep <- as.character(temp_p$Sweep)

temp <- full_join(temp_a, select(temp_p, -Time)) %>% select(-nrow)




downsample_data(temp, len = 10000) %>% 
# temp %>% 
  mutate(predicted = predicted - offset) %>% 
  mutate(difference = In4-predicted) %>% 
  ggplot(aes(x = Time))+
  geom_ribbon(aes(ymin=In4, ymax=predicted), fill = "cornflowerblue")+
  geom_line(aes(y=In4), color = "black")+
  geom_line(aes(y=predicted), color = "cornflowerblue", alpha = 0.3)+
  # geom_line(aes(y=difference-offset), color = "purple")+
  facet_grid(Sweep~.)


temp_part1 <- temp %>% 
  mutate(predicted = predicted - offset) %>% 
  mutate(difference = In4-predicted) %>% 
  gather(Key, mV, c("In4", "predicted", "difference")) %>% 
  group_by(Key, Sweep) %>% 
# Min Voltage
  mutate(Min.V = min(mV, na.rm = T)) %>%
  # Baseline voltage
  # Defining as average of the lowest 20% of points
  mutate(Use.in.Base = quantile(mV, probs = .2, na.rm = T)) %>%
  mutate(Use.in.Base = ifelse(mV <= Use.in.Base,
    mV,
    NA
  )) %>%
  mutate(Use.in.Base = mean(Use.in.Base, na.rm = T)) %>%
  # Max voltage
  mutate(Max.V = max(mV, na.rm = T)) %>%
  # Median Voltage
  mutate(Med.V = median(mV, na.rm = T)) %>%
  # Mean Voltage
  mutate(Mean.V = mean(mV, na.rm = T)) %>%
    # # Duration
    # mutate(Max.Time = max(Time, na.rm = T)) %>% 
  # AUC
  # Using Min.V
  mutate(AUC = (mV - Min.V))


# AUC
# Median mV
# Mean mV
# Stimulus correlation
# Max mV

calculated_metrics <- c("Min.V", "Use.in.Base", "Max.V", "Med.V", "Mean.V", "AUC")

temp_part1 <- temp_part1 %>% 
  ungroup() %>% 
  select(-In7, -Time, -offset, -mV) %>% 
  group_by(Key) %>% 
  mutate_at(
    calculated_metrics, 
    median, na.rm =T) %>% 
  distinct() %>% 
  ungroup() 

temp_part1 %>% 
  pivot_longer(cols = calculated_metrics, names_to = "key", values_to = "value") %>% 
  ggplot(aes(key, value, color = Key))+
  geom_point()



distinct(temp_part2)
```

(epsp) How could we slice up the trace? 
```{r}
# ## Here's the stimulus used in the protocol ====
# # sweep duration should be 19.687 seconds
# epsp_stim <- readABF_as_matrix(here("inst", "extdata", "epsp_stim_files", "08 current injection.abf"),
#                   channels = "Axo1I2")
# epsp_stim <- as_tibble(epsp_stim) %>%
#   mutate(Time = Time - min(Time, na.rm = T)) %>%
#   rename(Stim = Axo1I2)
# 
# 
# shading_annotations <- data.frame(
#   starts = c(0.40,
#              4.87,
#              10.74,
#              16.74),
#   next_start = c(4.87,
#                  10.74,
#                  16.74,
#                  19.685),
#   equal_len = c(0.40,
#                 4.87,
#                 10.74,
#                 16.74) + 2.945,
#   on_end = c(2,
#              6.17,
#              12.54, 
#              18.5),
#   equal_on = c(0.40,
#                4.87,
#                10.74,
#                16.74) + 1.30
# )
# 
# ggplot()+
#   geom_vline(xintercept = c(shading_annotations$starts, shading_annotations$equal_len, shading_annotations$next_start, shading_annotations$equal_on), color = "gray")+
#     geom_path(data = epsp_stim, aes(Time, Stim+1.5))+
#   geom_rect(data = shading_annotations, aes(xmin = starts, xmax = next_start, ymin = 0, ymax = 0.5), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[1], color = RColorBrewer::brewer.pal(3, "Set1")[1])+
#   geom_rect(data = shading_annotations, aes(xmin = starts, xmax = equal_len, ymin = -0.5, ymax = 0), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[1], color = RColorBrewer::brewer.pal(3, "Set1")[1])+
#   geom_rect(data = shading_annotations, aes(xmin = starts, xmax = on_end, ymin = -1, ymax = -0.5), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[2], color = RColorBrewer::brewer.pal(3, "Set1")[2])+
#   geom_rect(data = shading_annotations, aes(xmin = starts, xmax = equal_on, ymin = -1.5, ymax = -1), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[2], color = RColorBrewer::brewer.pal(3, "Set1")[2])+
#   theme_classic()+
#   geom_vline(xintercept = 12.54)+
#   ylim(-1.5, 9.5)+
#   labs(title = "Ways to Segement EPSP Stim")
```


Placeholder for fi
```{r}
#TODO
```

## Save automatically processed data
```{r}
#TODO
```


# Retrieve manually processed data ----



## User Defined Functions
```{r}
## Shrug ====
shrug <- function(){
  cat("¯\\_(ツ)_/¯")  }

## IV linear ====
iv_linear <- function(input.df = temp,
                             min.mV = -35,
                             max.mV = 5,
                             ch.i = "S2Max",
                             ch.v = "S1Max"){
  
  # input.df = temp
  # min.mV = -81
  # max.mV = -39
  # ch.i = "S2Max"
  # ch.v = "S1Max"
  
  input.df <- as.data.frame(input.df)
  
        # input.df <- input.df[!is.na(input.df[[ch.v]]), ]
  
  if (nrow(input.df[!is.na(input.df[[ch.v]]), ]) > 1 ){
      input.df <- input.df %>% rename(CH.I = ch.i) %>% rename(CH.V = ch.v)
  
  fm <- lm(CH.I ~ CH.V, input.df[input.df$CH.V >= min.mV & input.df$CH.V <= max.mV, ], na.action = "na.omit")
  
  }
  return(list(intercept = fm$coefficients[[1]],
       slope = fm$coefficients[[2]]))  

}

## mk_filename ====
# write file name from spreadsheet
mk_filename <- function(
  metadata.file = metadata,
  use.row = 1){
  filename <- paste0(
    as.character(
      metadata.file[use.row, "Experiment"]
    ),
    "_",
    paste0(
      rep("0", (4-length(metadata.file[use.row, "Recording"]))), collapse = ""),
    as.character(
      metadata.file[1, "Recording"]
    ),
    ".abf"
  )
  return(filename)
}
```

## Build metadata
```{r}
use.file.path <- here("inst", "extdata", "ManualDataEphys02.xlsx")
```

## Check entries in metadata file vs data files
```{r}

```

## Load Data Ephys Data
```{r}
metadata <- read_excel(use.file.path,
                       sheet = "MetadataEphys")  

ia <- read_excel(
use.file.path,
  sheet = "IA"
)

ihtk <- read_excel(
use.file.path,
  sheet = "IHTK"
)

tecc <- read_excel(
use.file.path,
  sheet = "TECC"
)

tevc <- read_excel(
use.file.path,
  sheet = "TEVC"
)
```

# Voltage Clamp K+ Protocols
## IA data 
Add intercept/slope from -35 to 5mV
```{r}
# ia <- ia %>% filter(Condition %in% c("Baseline", "Compensated", "Delayed") &
#                       Pharm %in% c("none", "tea"))

ia <- separate(ia, FileName, c("Experiment", "Recording"), sep = "_") %>% mutate(Recording = as.numeric(Recording))


ia <- right_join(x = 
  select(metadata, #Pharm, 
         Condition, #Notes, 
         In4,   In9, Experiment, Recording),
  y = ia)# %>% filter(Experiment != "0")

temp1 <- ia %>% select(-c(In9, S3Max, S4Max, S3Mean, S4Mean, Signal3, Signal4))
temp2 <- ia %>% select(-c(In4, S1Max, S2Max, S1Mean, S2Mean, Signal1, Signal2))

names(temp2) <- names(temp1)

ia <- full_join(temp1, temp2) %>% mutate(Cell = as.factor(In4))

# ia %>% 
#   # filter(Pharm != "4ap") %>% 
#   ggplot(aes(S1Max, S2Max, color = Cell))+
#   geom_point()+
#   facet_grid(Condition ~ Experiment)+
#   theme_bw()

ia$intercept <- NA %>% as.numeric() 
ia$slope <- NA %>% as.numeric()

ia <- ia %>% mutate(iter.var = paste(Experiment, Cell, Condition, sep =  "_"))
iter.over <- ia$iter.var %>% unique()

walk(1:length(iter.over), function(i){
  print(i)
  temp.df <- ia[ia$iter.var == iter.over[i], ]
  # temp <- select(temp, -c(leak, leak.sub))
  if(length(na.omit(temp.df$S2Max)) >1 &
     length(na.omit(temp.df$S1Max)) >1){
    
    temp.fm <- iv_linear(input.df = temp.df,
                         min.mV = -35,
                         max.mV = 5,
                         ch.i = "S2Max",
                         ch.v = "S1Max")
    if (length(temp.fm) > 0 ){
      ia[ia$iter.var == iter.over[i], "intercept"] <<- temp.fm$intercept
      ia[ia$iter.var == iter.over[i], "slope"] <<- temp.fm$slope    
    }}
})

# ia %>% 
#   ggplot(aes(Condition, intercept))+
#   geom_point()+
#   theme_minimal()
```

## IHTK data (not leak substracted)
```{r}
# ihtk <- ihtk %>% filter(Condition %in% c("Baseline", "Compensated", "Delayed") &
#                       Pharm %in% c("none", "tea"))

ihtk <- separate(ihtk, FileName, c("Experiment", "Recording"), sep = "_") %>% mutate(Recording = as.numeric(Recording))


ihtk <- right_join(x = 
  select(metadata, #Pharm, 
         Condition, #Notes, 
         In4,   In9, Experiment, Recording),
  y = ihtk)# %>% filter(Experiment != "0")

temp1 <- ihtk %>% select(-c(In9, S3Max, S4Max, S3Mean, S4Mean, Signal3, Signal4))
temp2 <- ihtk %>% select(-c(In4, S1Max, S2Max, S1Mean, S2Mean, Signal1, Signal2))

names(temp2) <- names(temp1)

ihtk <- full_join(temp1, temp2) %>% mutate(In4 = as.factor(In4)) %>% rename(Cell = In4)

# ihtk %>% 
#   # filter(Pharm != "4ap") %>% 
#   ggplot(aes(S1Max, S2Max, color = Cell))+
#   geom_point()+
#   facet_grid(Condition ~ Experiment)+
#   theme_bw()
```

```{r}
## Subtract leak from ihtk protocol
subtract_leak_df <- function(input.df = temp,
                             min.mV = -81,
                             max.mV = -39,
                             ch.i = "S2Max",
                             ch.v = "S1Max"){
  
  # input.df = temp
  # min.mV = -81
  # max.mV = -39
  # ch.i = "S2Max"
  # ch.v = "S1Max"
  
  input.df <- as.data.frame(input.df)
  
        # input.df <- input.df[!is.na(input.df[[ch.v]]), ]
  
  if (nrow(input.df[!is.na(input.df[[ch.v]]), ]) > 1 ){
      input.df <- input.df %>% rename(CH.I = ch.i) %>% rename(CH.V = ch.v)
  
  fm <- lm(CH.I ~ CH.V, input.df[input.df$CH.V >= min.mV & input.df$CH.V <= max.mV, ], na.action = "na.omit")
  
  input.df <- input.df %>% mutate(leak = predict(object = fm, newdata = input.df), na.action = "na.omit")
  input.df <- input.df %>% mutate(leak.sub = CH.I - leak)
  
  # input.df <- input.df %>% rename(ch.i = CH.I) %>% rename(ch.v = CH.V)
  
  names(input.df)[names(input.df) == "CH.I"] <- ch.i
  names(input.df)[names(input.df) == "CH.V"] <- ch.v
  
  
  # input.df %>% select(S1Max, S2Max, leak, leak.sub) %>% gather(type, value, 2:4) %>% ggplot(aes(x = S1Max, y = value, color = type))+geom_point()
  

  }
  return(input.df)  

}

ihtk <- ihtk %>% filter(Condition %in% c("Baseline", "Compensated", "Delayed"))

ihtk <- ihtk[!is.na(ihtk[["Experiment"]]) & 
         !is.na(ihtk[["Cell"]]) &
         !is.na(ihtk[["Condition"]]), ] 

ihtk <- ihtk %>% 
  mutate(iter.var = paste(Experiment, Cell, Condition, sep =  "_")) %>% 
  mutate(leak = NA) %>% 
  mutate(leak.sub = NA)


iter.over <- ihtk$iter.var %>% unique()



# Add in leak subtracted measure
ihtk$na.action <- NA
walk(1:length(iter.over), function(i){
  print(i)
  temp <- ihtk[ihtk$iter.var == iter.over[i], ]
  temp <- select(temp, -c(leak, leak.sub))
  
  temp <- subtract_leak_df(input.df = temp,
                     min.mV = -81,
                     max.mV = -39,
                     ch.i = "S2Max",
                     ch.v = "S1Max")
  if(nrow(temp)>1){
    # make sure the columns are in the same order
    temp <- temp[, names(ihtk)]
    
    ihtk[ihtk$iter.var == iter.over[i], ] <<- temp      
  }
})

ihtk <- ihtk %>% mutate(leak = as.numeric(leak)) 
ihtk$leak.sub <- ihtk$S2Max - ihtk$leak


# ihtk %>% ggplot()+
#    geom_line(aes(x = S1Max, y = leak, color = Cell), linetype = "dashed")+
#    geom_point(aes(x = S1Max, y = leak.sub, color = Cell))+
#    geom_line(aes(x = S1Max, y = S2Max, color = Cell))+
#   facet_grid(Condition ~ Experiment)+
#   theme_bw()

# ggsave(plot = last_plot(), filename = "IonicExample.tiff", path = here("data", "figures"))

# ihtk %>% 
#   filter(Experiment == "190716") %>% 
#   ggplot()+
#    geom_line(aes(x = S1Max, y = leak, color = Cell), linetype = "dashed")+
#    geom_point(aes(x = S1Max, y = leak.sub, color = Cell))+
#    geom_line(aes(x = S1Max, y = S2Max, color = Cell))+
#   facet_grid(Condition ~ Cell)+
#   theme_bw()
```

Fit Roughly linear portion from IHTK
```{r}
ihtk$intercept <- NA %>% as.numeric() 
ihtk$slope <- NA %>% as.numeric()

walk(1:length(iter.over), function(i){
  print(i)
  temp.df <- ihtk[ihtk$iter.var == iter.over[i], ]
  # temp <- select(temp, -c(leak, leak.sub))
  if(nrow(temp.df) > 1){
    temp.fm <- iv_linear(input.df = temp.df,
                         min.mV = -35,
                         max.mV = 5,
                         ch.i = "S2Max",
                         ch.v = "S1Max")
    if (length(temp.fm) > 0 ){
      ihtk[ihtk$iter.var == iter.over[i], "intercept"] <<- temp.fm$intercept
      ihtk[ihtk$iter.var == iter.over[i], "slope"] <<- temp.fm$slope    
    }}
})


```

```{r}
# ihtk %>% 
#   ggplot(aes(Condition, intercept))+
#   geom_point()+
#   theme_minimal()
# 
# ihtk %>% 
#   ggplot(aes(Condition, slope))+
#   geom_point()+
#   theme_minimal()
```

## Join ephys into combined df
```{r}
temp1 <- ihtk %>% 
  select(#Pharm, 
         Condition, Cell, Experiment, intercept, slope) %>% 
  filter(!duplicated(.)) %>% 
  rename(Ihtk.0 = intercept) %>% 
  rename(Ihtk.Slope = slope)
temp2 <- ia %>% select(#Pharm, 
  Condition, Cell, Experiment, intercept, slope) %>% 
  filter(!duplicated(.)) %>% 
  rename(Ia.0 = intercept) %>% rename(Ia.Slope = slope)

ionic <- full_join(temp1, temp2) %>% 
  filter(Condition %in% c("Baseline", "Compensated", "Delayed")) %>% 
  mutate(Condition = factor(Condition, levels = c("Baseline", "Compensated", "Delayed")))
```

## Save ionic for later use
```{r}
save(ionic, file = here("data", "ionic.rds"))
```

# Voltage Clamp GJ Protocol
```{r}

ThresholdVoltage <- 4

# Keep only those with steps greater than threshold
ThresholdVector <- abs(tevc$R1S1Mean) >= ThresholdVoltage | abs(tevc$R1S3Mean) >= ThresholdVoltage 
tevc <- tevc[ThresholdVector, ]

# Look for the smallest deviation from baseline to find which cell is postsynaptic
# if TRUE then S1 is the presynaptic cell
tevc$S1Pre <- abs(tevc$R1S1Mean) >= abs(tevc$R1S3Mean)
tevc$PreSyn <- ifelse(tevc$S1Pre, tevc$Signal1, tevc$Signal3)

# Drop any rows where this wasn't a bool
tevc <- tevc[!is.na(tevc$S1Pre), ]

# conductance = i_post / delta_mV
# Where S1Pre == T
# c = R1S4Mean / R1S1Mean 
# Otherwise 
# c = R1S2Mean / R1S3Mean
temp <- tevc %>% 
  group_by(FileName, S1Pre) %>% 
  mutate(Ig = ifelse(S1Pre, 
                     abs(R1S4Mean / R1S1Mean), #abs to flip the current being used to prevent mV change into current coming across gj
                     abs(R1S2Mean / R1S3Mean) 
  )
  ) %>% 
  ungroup()

# provide Median observation
temp <- temp %>% 
  select(FileName, S1Pre, R1S1Mean, R1S2Mean, R1S3Mean, R1S4Mean, Ig) %>% 
  group_by(FileName, S1Pre) %>% 
  mutate(MedianIg = median(Ig, na.rm = T)) %>% 
  ungroup()

# Merge back
tevc <- full_join(tevc, temp)

save(tevc, file = here("data", "tevc.rds"))
```

# Current Clamp GJ Protocol
Bennet 1966's resistances:

Apparant Cell resistances:
$$r_{11}=\frac{v_1}{i_1}$$

Transfer resistances:
$$r_{12}=\frac{v_2}{i_1}$$

Membrane resistance
$$r_1= \frac{r_{11}*r_{22} - r_{12}^2}{r_{22} - r_{12}}$$

Coupling resistance
$$r_c = \frac{r_{11}*r_{22} - r_{12}^2}{r_{12}}$$

```{r}
ExperimentNames <- tecc$FileName %>% stringr::str_split(pattern = "_")
ExperimentNames <- transpose(ExperimentNames)[[1]] %>% unlist()

tecc$Experiment <- ExperimentNames
```


```{r}
df = tecc
v1 = "R1S1Mean"#"IN4_mean"
i1 = "R1S3Mean"#"IN7_mean"
v2 = "R1S4Mean"#"IN9_mean"
i2 = "R1S6Mean"#"IN12_mean"
exp = "Experiment"
rec = "FileName"

# Grouping prevents this from working.
df <- ungroup(df)

df <- df %>% mutate(cell = ifelse(abs(R1S3Mean) > abs(R1S6Mean), "a", "b"))

## Set up selection vectors for when i1 (e.g. IN7) is being used to inject current
inj_i1 <- abs(df[[i1]]) > abs(df[[i2]])
inj_i2 <- abs(df[[i1]]) < abs(df[[i2]])
## figure out coupling coef
df[inj_i1, "cc"] <- df[inj_i1, v2] / df[inj_i1, v1] #when inj IN7
df[inj_i2, "cc"] <- df[inj_i2, v1] / df[inj_i2, v2] #when inj IN12
## figure out input resistance ====
df[inj_i1, "r11"] <- df[inj_i1, v1] / df[inj_i1, i1] #when inj IN7
df[inj_i2, "r11"] <- df[inj_i2, v2] / df[inj_i2, i2] #when inj IN12
## figure out transfer resistance ====
df[inj_i1, "r12"] <- df[inj_i1, v2] / df[inj_i1, i1]
df[inj_i2, "r12"] <- df[inj_i2, v1] / df[inj_i2, i2]

## figure out membrane resist and coupling resist for both cells ====
temp <- df %>%
  dplyr::select(
    exp, rec, cell, r11, r12
  ) %>%
  group_by(Experiment, FileName, cell) %>% 
  # mutate(cell = ifelse(inj_i1, "cell1", "cell2")) %>%
  mutate(r11 = median(r11, na.rm = T),
         r12 = median(r12, na.rm = T)) %>% 
  distinct() %>% 
  ungroup() %>% 
  pivot_wider(names_from = cell,
              values_from = c("r11", "r12")
  ) %>%
  mutate(r1_a = ((r11_a*r11_b) - (r12_a^2)) / (r11_b - r12_a)) %>%
  mutate(r1_b = ((r11_b*r11_a) - (r12_b^2)) / (r11_a - r12_b)) %>%
  mutate(rc_a = ((r11_a*r11_b) - (r12_a^2)) / (r12_a)) %>%
  mutate(rc_b = ((r11_b*r11_a) - (r12_b^2)) / (r12_b)) %>%
  pivot_longer(
    -c(exp, rec),
    names_to = c(".value", "cell"),
    names_sep = "_",
    values_drop_na = TRUE
  )

# collapse df to medians
df <- df[, c(
  "Experiment", "cell", 
  "FileName", 
  # "Trace", "TraceStart", 
  "Signal1", "Signal2", "Signal3", "Signal4", "Signal5", "Signal6", 
  # "Region1", "StartTime", "EndTime", 
  "R1S1Mean", "R1S2Mean", "R1S3Mean", "R1S4Mean", "R1S5Mean", "R1S6Mean", 
  "R1S1Baseline", "R1S2Baseline", "R1S3Baseline", "R1S4Baseline", "R1S5Baseline", "R1S6Baseline", 
  # "FilePath", 
  "cc"#, 
  # "r11", "r12"
)] %>% 
  group_by(Experiment, cell, FileName) %>% 
  mutate(R1S1Mean = median(R1S1Mean, na.rm = T),
         R1S2Mean = median(R1S2Mean, na.rm = T),
         R1S3Mean = median(R1S3Mean, na.rm = T),
         R1S4Mean = median(R1S4Mean, na.rm = T),
         R1S5Mean = median(R1S5Mean, na.rm = T),
         R1S6Mean = median(R1S6Mean, na.rm = T),
         
         R1S1Baseline = median(R1S1Baseline, na.rm = T),
         R1S2Baseline = median(R1S2Baseline, na.rm = T),
         R1S3Baseline = median(R1S3Baseline, na.rm = T),
         R1S4Baseline = median(R1S4Baseline, na.rm = T),
         R1S5Baseline = median(R1S5Baseline, na.rm = T),
         R1S6Baseline = median(R1S6Baseline, na.rm = T),
         
         cc = median(cc, na.rm = T),
  ) %>% 
  distinct() %>% 
  ungroup()

# Merge
df <- full_join(df, temp) %>% dplyr::select(-cell)

tecc <- df
```

```{r}
save(tecc, file = here("data", "tecc.rds"))
```


# Molecular Data

## Read in Brian's Data
```{r}
# load all of brian's cells
BriansCells <- list.files(here("inst", "extdata", "BriansCells"))
BriansCells <- BriansCells[!(BriansCells == "All.CSV")]

BriansDfs <- map(BriansCells, function(i){
  temp <- read.csv(here("inst", "extdata", "BriansCells", i))
  names(temp) <- janitor::make_clean_names(names(temp), case = "upper_camel")
  temp$Condition <- i
  temp$Source <- "Brian"
  
  return(temp)
})

BriansDf <- do.call(rbind, BriansDfs)

BriansDf$Condition <- BriansDf$Condition %>% str_remove(pattern = ".CSV")

BriansDf$Time <- ifelse(str_detect(BriansDf$Condition, pattern = "Control") & !(str_detect(BriansDf$Condition, pattern = "24")), "Baseline",
                        ifelse(str_detect(BriansDf$Condition, pattern = "Acute"), "Compensated",
                               ifelse(str_detect(BriansDf$Condition, pattern = "24"), "Delayed", "NotFound")
                               )
                        )

BriansDf$Pharm <- ifelse(str_detect(BriansDf$Condition, pattern = "Control"), "None",
                        ifelse(str_detect(BriansDf$Condition, pattern = "TEA"), "TEA",
                               ifelse(str_detect(BriansDf$Condition, pattern = "AP"), "AP", 
                                      ifelse(str_detect(BriansDf$Condition, pattern = "TTX"), "TTX", "NotFound")
                                      )
                               )
                        )

BriansDf <- BriansDf[, names(BriansDf)[!(names(BriansDf) %in% c("Condition"))]]

BriansDf <- BriansDf %>% select(-Treatment)

BriansMetadataCols <- c("Source", "Pharm", "Time", "Cell")
BriansDf <- BriansDf[, c(BriansMetadataCols, names(BriansDf)[!(names(BriansDf) %in% BriansMetadataCols)]) ]


# df <- data.frame()
# walk(BriansCells, function(i){
#   df <<- rbind(df, read.csv(here("inst", "extdata", "BriansCells",i)))
# })
# 
# df <- df %>% mutate(Pharm = "") %>% mutate(Condition = "")
# 
# update.df.labels <- data.frame(stringsAsFactors=FALSE,
#                                Treatment = c("4AP24h", "Control", "24h-CONTROL", "TEA-24h", "TEA-Acute",
#                                              "TTX-24h"),
#                                Pharm = c("AP", "none", "none", "tea", "tea", "ttx"),
#                                Condition = c("Delayed", "Baseline", "Delayed", "Delayed", "Compensated",
#                                              "Delayed")
# )
# 
# walk(1:nrow(update.df.labels), function(i){
#   up.t <- update.df.labels[i, "Treatment"]
#   up.p <- update.df.labels[i, "Pharm"]
#   up.c <- update.df.labels[i, "Condition"]
#   
#   BriansDf[BriansDf$TREATMENT == up.t, "Pharm"] <<- up.p
#   BriansDf[BriansDf$TREATMENT == up.t, "Condition"] <<- up.c
# })
# 
# df <- df %>% rename(UID = CELL) %>% select(-TREATMENT)
# df <- as_tibble(df)
# # mutate(var = replace(var, var != "Candy", "Not Candy"))
```
## Read in data paired with ephys
```{r}
TEAOverTime <- readxl::read_excel(here("inst", "extdata", "LCTEAhr0hr1hr24.xlsx")) %>% janitor::clean_names(case = "upper_camel")

TEAOverTime$Time <- ifelse(TEAOverTime$Tea == 0, "Baseline", 
                           ifelse(TEAOverTime$Tea == 1, "Compensated", 
                                  ifelse(TEAOverTime$Tea == 24, "Delayed", "NotFound")))

TEAOverTime$Pharm <- "TEA"
TEAOverTime$Source <- "Daniel"

TEAOverTime <- TEAOverTime[, names(TEAOverTime)[!(names(TEAOverTime) %in% c("Tea"))]]

MetadataCols <- c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell")
TEAOverTime <- TEAOverTime[, c(MetadataCols, names(TEAOverTime)[!(names(TEAOverTime) %in% MetadataCols)]) ]
```

```{r}
# Make everything lower to ensure easy merging.
names(TEAOverTime)[!(names(TEAOverTime) %in% c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell"))] <- tolower(names(TEAOverTime)[!(names(TEAOverTime) %in% c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell"))])

names(BriansDf)[!(names(BriansDf) %in% c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell"))] <- tolower(names(BriansDf)[!(names(BriansDf) %in% c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell"))])






mrna <- full_join(TEAOverTime, BriansDf)
```

Rename gene names so they're consistent and easy to lookup with `./inst/extdata/mRNAInfo.xlsx`
```{r}
mRNAInfo <- readxl::read_excel(here("inst", "extdata", "mRNAInfo.xlsx")) # tables from Northcutt 2016 and annotations
ToCorrect <- names(mrna)[!(names(mrna) %in% c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell"))]
# ToCorrect <- tolower(ToCorrect)

# Get the names InData and the corresponding output names
SwapNames <- mRNAInfo[mRNAInfo$InDataLower %in% ToCorrect, c("InDataLower", "RGeneName")]
# SwapNames$InData <- tolower(SwapNames$InData)

for (i in 1:nrow(SwapNames)){
  ToCorrect[ToCorrect == as.character(SwapNames[i, "InDataLower"])] <- as.character(SwapNames[i, "RGeneName"])  
}

names(mrna) <- c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell", ToCorrect)
```


```{r}
save(mrna, file = here("data", "mrna.rds"))
```





#End

## Overview of the data

| thing | File Name | Description |
| a | LCTEAhr0hr1hr24.xlsx | Contains mRNA data to accompany the ephys data I collected. |
| b | LCTEAhr0hr1hr24.xlsx | Contains mRNA data to accompany the ephys data I collected. |
| c | LCTEAhr0hr1hr24.xlsx | Contains mRNA data to accompany the ephys data I collected. |

## Read in data


# Not run
## from untitled2.
```{r eval=FALSE, include=FALSE}
non.metadata <- c("TECC", "TEVC", "IA", "IHTK")
metadata <- c("MetadataEphys")

use.file.path <- here("inst", "extdata", "ManualDataEphys02.xlsx")

# Read in manual metadata for comparsions
man.metadata <- read_excel(use.file.path, 
                           sheet = metadata)  

# Read in data
M <- purrr::map(non.metadata, function(i){
read_excel(use.file.path, 
           sheet = i)  
}) 
names(M) <- non.metadata

# Remove the relevant portions, i.e. the filenames and sheet names
M <- map(1:length(M), function(i){
  temp <- M[[i]] %>% select(FileName) %>% unique()
  temp <- temp %>% mutate(Type = as.character(names(M)[i]))
  return(temp)
})

# Combine into a single df
made.metadata <- data.frame()
walk(M, function(i){
  made.metadata <<- rbind(made.metadata, i)
})

# Massage to make it look like the manual metadata
made.metadata <- made.metadata %>% 
  mutate(FileName = str_remove(made.metadata$FileName, ".abf")) %>% 
  separate(., FileName, c("Experiment", "Recording"), sep = "_") %>% 
  mutate(Recording = as.numeric(Recording))

made.metadata$Data <- T
man.metadata$MData <- T

man.metadata <- man.metadata %>% rename(type = Type)

all.metadata <- left_join(made.metadata, man.metadata)

all.metadata <- all.metadata %>% arrange(Experiment, Recording)

# Interpolate metadata

# install.packages("xlsx")
library("xlsx")

# xlsx::write.xlsx(made.metadata, 
#                  file = "S:/Data_Daniel/ActiveProjects/mRNA24hLC/inst/extdata/ManualDataEphys.xlsx",
#                  sheetName = "MadeMetadata", 
#                  append = T)

xlsx::write.xlsx(all.metadata, 
                 file = use.file.path,
                 sheetName = "AllMetadata", 
                 append = T)
```
### Mol Bio
```{r eval=FALSE, include=FALSE}
M.none.B <- as.data.frame(read.csv("inst/extdata/Control.csv"))
M.tea.C <- as.data.frame(read.csv("inst/extdata/TEAAcute.CSV"))
M.tea.D <- as.data.frame(read.csv("inst/extdata/TEA24hr.CSV"))

M.none.B <- M.none.B %>% 
  rename(UID = CELL) %>% 
  mutate(Pharm = "none") %>% 
  mutate(Condition = "Baseline") %>% 
  select(-TREATMENT)

M.tea.C <- M.tea.C %>% 
  rename(UID = CELL) %>% 
  mutate(Pharm = "tea") %>% 
  mutate(Condition = "Compensated") %>% 
  select(-TREATMENT)

M.tea.D <- M.tea.D %>% 
  rename(UID = CELL) %>% 
  mutate(Pharm = "tea") %>% 
  mutate(Condition = "Delayed") %>% 
  select(-TREATMENT)

mrna <- full_join(M.none.B, M.tea.C) %>% full_join(., M.tea.D)

mrna.names <- mrna %>% select(-c(UID, Pharm, Condition)) %>% names()
mrna.names <- mrna.names[mrna.names %in% c("BKKCa", "SHAL", "Shaker")]

#, "Shab", "Shaw1", "Shaw2")]

cowplot::plot_grid(plotlist = 
map(mrna.names, function(i){
    ggplot(mrna, aes(x = Condition, group = Condition, fill = Condition))+
  # geom_smooth(method = "lm", se = F)+
    geom_boxplot(aes_string(y = i), width = 0.1)+
    ggbeeswarm::geom_beeswarm(aes_string(y = i), shape = 1)+
    # geom_point(size = 2)+
    stat_summary(aes_string(y = i, group = "1"), fun.y = mean, geom = "line")+
    stat_summary(aes_string(y = i, group = "1"), fun.y = mean, geom = "point", size = 4, shape = 4)+
    theme_minimal()+
  theme(legend.position = "")+
  labs(x = "", y = "", title = i)
}), ncol = 3
)

ggsave(plot = last_plot(), filename = "kchannels.tiff", path = here("data", "figures"))
# cowplot::plot_grid(plotlist = map(c("BKKCa", "Shaker", "Shab", "Shaw1", "Shaw2"), function(i){
#   ggplot(mrna, aes_string("CONDITION", i))+
#     geom_violin()+
#     geom_point()+
#     stat_summary(fun.y = "mean", geom = "point", size = 3, color = "red", shape = 15)+
#     theme_minimal()
# })
# )






```
### Find what data is missing from each sheet
```{r eval=FALSE, include=FALSE}
ihtk <- ihtk %>% mutate(FileName = paste0(FileName, ".abf"))
ia <- ia %>% mutate(FileName = paste0(FileName, ".abf"))




# Add FileName to help merge
metadata$FileName <- NA
walk(1:nrow(metadata), function(i){
  metadata[i, "FileName"] <<- mk_filename(
  metadata.file = metadata,
  use.row = i)
})







find_missing_entries <- function(
  data.file = ihtk,
  sheet = "ihtk",
  metadata.file = metadata,
  error.path = "inst/extdata"
){
  # find those that are not in metadata
  uniq.d <- unique(data.file$FileName)
  uniq.m <- unique(metadata.file$FileName)
  
  # the following metadata is not represented in the data
  m.i.d <- data.frame("MissingInData" = uniq.m[!(uniq.m %in% uniq.d)] )
  
  if (nrow(m.i.d) > 0){
    warning("Metadata entries found that were not in the data file.")
    warning(paste0("Writing error file at ", as.character(here(error.path, "MissingInMetadata.csv"))))
    m.i.d <- m.i.d %>% separate(., MissingInData, c("Experiment", "Recording"), sep = "_")
    m.i.d$Recording <- m.i.d$Recording %>% str_remove(".abf") %>% as.numeric()
    m.i.d$Type <- sheet
    if(!file.exists(here(error.path, "MissingInData.csv"))){
      
    }else if (file.exists(here(error.path, "MissingInData.csv"))){
      old.m.i.d <- read.csv(here(error.path, "MissingInData.csv"))
      m.i.d <- rbind(old.m.i.d[,-1], m.i.d) # need to drop the rownum col
    }
    write.csv(m.i.d, here(error.path, "MissingInData.csv"))
  }
  
  # the following data is not represented in the metadata
  m.i.m <- data.frame("MissingInMetadata" = uniq.d[!(uniq.d %in% uniq.m)] )
  
  if (nrow(m.i.m) > 0){
    warning("Data entries found that were not in metadata.")
    warning(paste0("Writing error file at ", as.character(here(error.path, "MissingInMetadata.csv"))))
    m.i.m <- m.i.m %>% separate(., MissingInMetadata, c("Experiment", "Recording"), sep = "_")
    m.i.m$Recording <- m.i.m$Recording %>% str_remove(".abf") %>% as.numeric()
    m.i.m$Type <- sheet
    
    if(!file.exists(here(error.path, "MissingInMetadata.csv"))){
      
    }else if (file.exists(here(error.path, "MissingInMetadata.csv"))){
      old.m.i.m <- read.csv(here(error.path, "MissingInMetadata.csv"))
      m.i.m <- rbind(old.m.i.m[, -1], m.i.m)# need to drop the rownum col
    }
    write.csv(m.i.m, here(error.path, "MissingInMetadata.csv"))
    
    # update.in.r <- readline(prompt="Update metadata in R? Y/N: ")
    # while (!(update.in.r %in% c("Y", "y", "N", "n"))){
    #   update.in.r <- readline(prompt="Update metadata in R? Y/N: ")
    # }
    # # interactive update
    # if (update.in.r %in% c("Y", "y")){
    #   print("Updating in r is a planned but not present feature. Please fork the repository or contact the package maintainer.")
    #   # m.i.m %>% mutate()
    #   # 
    #   # cbind(m.i.m, 
    #   # metadata.file[0, ]
    #   # )
    #   
    #   # let user enter each desired value
    #   # return metadata. Writing into xlsx will be more hastle than it's worth
    #   # Not focusing on this now, it'll be easier for me ATM to do this updating in excel.
    # }
    # no update
  }
  
}

find_missing_entries(
  data.file = ihtk,
  sheet = "IHTK",
  metadata.file = metadata,
  error.path = "inst/extdata"
)

find_missing_entries(
  data.file = ia,
  sheet = "IA",
  metadata.file = metadata,
  error.path = "inst/extdata"
)

find_missing_entries(
  data.file = tecc,
  sheet = "TECC",
  metadata.file = metadata,
  error.path = "inst/extdata"
)

find_missing_entries(
  data.file = tevc,
  sheet = "TEVC",
  metadata.file = metadata,
  error.path = "inst/extdata"
)


#idk why but this seems to not be joining them.










```















## Check vs metadata


