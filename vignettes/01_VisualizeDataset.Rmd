---
title: "01_VisualizeDataset"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(here)
library(readxl)
library(tidyverse)

library(ggpmisc) # for labeling through stat_poly_eq
theme_set(ggplot2::theme_minimal())
devtools::load_all()
```

## load data and create a uid
```{r}
## Load in data ====
load(here("data", "ionic.rds"))
load(here("data", "tevc.rds"))
load(here("data", "tecc.rds"))
load(here("data", "mrna.rds"))
epsp <- read.csv(here("data", "epsp.csv")) %>% as_tibble()
metadata <- read_excel(here("inst", "extdata", "ManualDataEphys02.xlsx"),
                       sheet = "MetadataEphys")  
mRNAInfo <- readxl::read_excel(here("inst", "extdata", "mRNAInfo.xlsx")) # tables from Northcutt 2016 and annotations

```

```{r}
## Add Experment/Cell to metadata ====
metadata <- metadata %>% 
  mutate(ABFType = case_when(Type %in% c("tevc") ~ "gjvc",
                            # Type %in% c("igj","igj_50", "gj") ~ "gjcc",
                            # Type %in% c("epsp", "epsp_50") ~ "epsp",
                            Type %in% c("fi_50", "fi") ~ "fi")) %>% 
  # make expected file names
  mutate(num_zeros = str_length(Recording)) %>% 
  mutate(num_zeros = ifelse(num_zeros == 1, "000", 
                            ifelse(num_zeros == 2, "00", 
                                   ifelse(num_zeros == 3, "0", NA)))) %>% 
  mutate(FileName = paste0(Experiment, "_", num_zeros, as.character(Recording), ".abf" )) %>% 
  select(-num_zeros)

#TODO there are only two Type == "gj". Replace these with igj|igj_50
#   Experiment  Page Recording Type    TEA Condition Include Notes   In4   In9 ABFType FileName       
#   <chr>      <dbl>     <dbl> <chr> <dbl> <chr>     <lgl>   <lgl> <dbl> <dbl> <chr>   <chr>          
# 1 190906         0        32 gj       24 Delayed   NA      NA        5    NA NA      190906_0032.abf
# 2 190906         0        50 gj       24 Delayed   NA      NA        4    NA NA      190906_0050.abf


### use a subset of metadata cols to add experment/cell data to other dfs ####
small_metadata <- metadata %>% 
  select(Experiment, FileName, In4, In9) %>% 
  gather("Channel", "Cell", c("In4", "In9"))

small_metadata2 <- metadata %>% 
  select(Experiment, Type, FileName, In4, In9) %>% 
  gather("Channel", "Cell", c("In4", "In9"))
```


```{r}
## Add Experment/Cell to tecc ====
tecc <- tecc %>% 
  mutate(PreSyn = case_when(
    (abs(R1S3Mean) > abs(R1S6Mean)) ~ Signal1, 
    (abs(R1S3Mean) < abs(R1S6Mean)) ~ Signal4
    ),
    vrest = case_when(
    (abs(R1S3Mean) > abs(R1S6Mean)) ~ R1S1Baseline, 
    (abs(R1S3Mean) < abs(R1S6Mean)) ~ R1S4Baseline
    )) %>% 
  mutate(PreSyn = case_when(
    PreSyn == "IN 9" ~ "In9",
    PreSyn == "IN 4" ~ "In4"
  )) %>% 
  select(FileName, PreSyn, vrest, #Signal1, Signal4, R1S1Baseline, R1S4Baseline, 
         cc, r11, r1#, r12, rc # gap junction measures we'll get from voltage clamp
         ) %>% 
  distinct() %>% 
  rename(Channel = PreSyn)


tecc <- left_join(tecc, spread(small_metadata, Channel, Cell)) %>% 
  mutate(Cell = case_when(Channel == "In9" ~ In9,
                          Channel == "In4" ~ In4),
         PrePost = case_when(Channel == "In9" ~ paste0("cc.", as.character(In9), "_", as.character(In4)),
                             Channel == "In4" ~ paste0("cc.", as.character(In4), "_", as.character(In9)))
         ) %>% 
  filter(!is.na(Cell) &
           !is.na(In4) &
           !is.na(In9)) %>% 
  filter(In4 %in% c(3, 4, 5) &
         In9 %in% c(3, 4, 5)) %>% 
  select(-In4, -In9) %>% 
  filter(!is.na(cc)) %>% 
  spread(PrePost, cc)
```

handle tevc data
```{r}
## Add Experment/Cell to tevc ====
tevc <-
  tevc %>% 
  select(FileName, PreSyn, MedianIg) %>% 
  distinct() %>% 
  mutate(PreSyn = case_when(
    PreSyn == "IN 9" ~ "In9",
    PreSyn == "IN 4" ~ "In4"
  )) %>% 
  rename(Channel = PreSyn,
         ig = MedianIg)


tevc <- left_join(tevc, spread(small_metadata, Channel, Cell)) %>% 
  mutate(Cell = case_when(Channel == "In9" ~ In9,
                          Channel == "In4" ~ In4),
         PrePost = case_when(Channel == "In9" ~ paste0("ig.", as.character(In9), "_", as.character(In4)),
                             Channel == "In4" ~ paste0("ig.", as.character(In4), "_", as.character(In9)))
         ) %>% 
  filter(!is.na(Cell) &
           !is.na(In4) &
           !is.na(In9)) %>% 
  filter(In4 %in% c(3, 4, 5) &
         In9 %in% c(3, 4, 5)) %>% 
  select(-In4, -In9) %>% 
  filter(!is.na(ig)) %>% 
  spread(PrePost, ig)

# is conductance symmetric?
# tevc_plt <- tevc %>% 
#   select(-FileName, -Channel, -Cell) %>%
#   group_by(Experiment) %>% 
#   mutate_all(median, na.rm = T) %>% 
#   distinct() 
# 
# tevc_plt %>% 
# ggplot(aes(x = ig.3_4, y = ig.4_3))+
#   geom_point()
# 
# tevc_plt %>% 
# ggplot(aes(x = ig.3_5, y = ig.5_3))+
#   geom_point()
# 
# tevc_plt %>% 
# ggplot(aes(x = ig.4_5, y = ig.5_4))+
#   geom_point()

tevc[is.na(tevc$ig.3_4), "ig.3_4"] <- tevc[is.na(tevc$ig.3_4), "ig.4_3"]
tevc[is.na(tevc$ig.3_5), "ig.3_5"] <- tevc[is.na(tevc$ig.3_5), "ig.5_3"]
tevc[is.na(tevc$ig.4_5), "ig.4_5"] <- tevc[is.na(tevc$ig.4_5), "ig.5_4"]

tevc <- tevc %>% select(-ig.4_3, -ig.5_3, -ig.5_4)
```

add metadata to epsp
```{r}
## Add Experment/Cell to epsp ====
epsp <- left_join(epsp, small_metadata2)

# TODO How do we best caputre variace? find range between max/min across all sweeps when calculating auc? 
# note that there are plenty of replicates here
epsp %>% group_by(Experiment, Cell, Type) %>% filter(Sweep == 1 & Key == "predicted") %>% tally()
# epsp %>% filter(Experiment == "190808a" & Cell == 3 & Sweep == 1)

##
```

Relabel Brian's cells
```{r}
# Relabel Brian's cells ----
##
temp <- mrna[mrna$Source == "Brian" &
       mrna$Pharm == "AP" &
       mrna$Time == "Delayed", "Cell"]%>% 
  unlist() %>% 
  str_remove(pattern = "#") %>% 
  str_split(pattern = " ") %>%
  transpose()

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "AP" &
       mrna$Time == "Delayed", "Experiment"] <- unlist(transpose(temp[[1]]))

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "AP" &
       mrna$Time == "Delayed", "Cell"] <- unlist(transpose(temp[[2]])) %>% str_remove(pattern = "LC")


##
temp <- mrna[mrna$Source == "Brian" &
       mrna$Pharm == "None" &
       mrna$Time == "Baseline", "Cell"] %>% 
  unlist() %>% 
  str_remove(pattern = "Control #")

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "None" &
       mrna$Time == "Baseline", "Experiment"] <- temp

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "None" &
       mrna$Time == "Baseline", "Cell"] <- NA


##
temp <- mrna[mrna$Source == "Brian" &
       mrna$Pharm == "None" &
       mrna$Time == "Delayed", "Cell"] %>% 
  unlist() %>% 
  str_split(pattern = " ") %>%
  transpose()

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "None" &
       mrna$Time == "Delayed", "Experiment"] <- unlist(transpose(temp[[1]]))

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "None" &
       mrna$Time == "Delayed", "Cell"] <- unlist(transpose(temp[[2]])) %>% str_remove(pattern = "LC")


##
temp <- mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TEA" &
       mrna$Time == "Compensated", "Cell"] %>% 
  unlist() %>% 
  str_remove(pattern = "TEA #")

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TEA" &
       mrna$Time == "Compensated", "Experiment"] <- temp

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TEA" &
       mrna$Time == "Compensated", "Cell"] <- NA

##
temp <- mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TEA" &
       mrna$Time == "Delayed", "Cell"] %>% 
  unlist() %>% 
  str_remove(pattern = "TEA24-")

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TEA" &
       mrna$Time == "Delayed", "Experiment"] <- temp

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TEA" &
       mrna$Time == "Delayed", "Cell"] <- NA

##
temp <- mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TTX", "Cell"] %>% 
  unlist() %>% 
  str_split(pattern = "-") %>%
  transpose()

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TTX", "Experiment"] <- unlist(transpose(temp[[1]]))

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TTX", "Cell"] <- unlist(transpose(temp[[2]]))
## deduplicate mrna
mrna <- mrna %>% 
  gather(key = "mrna", 
         value = "count", 
         names(mrna)[!(names(mrna) %in% c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell"))]) %>% 
  filter(mrna != c("htr2b", "kainate2b", "nmda1a", "nmda2b", "mglur7", "trpm1", "machrb", "htr1b")) %>% # drop fully missing mrnas
  group_by(Source, Experiment, Cell, mrna) %>% 
  mutate(count = median(count, na.rm = T)) %>%
  ungroup() %>% 
  distinct() %>% 
  spread(key = "mrna", value = "count")
```


Add additional context
```{r}
# Was there activity on the EC? 
metadata <- full_join(metadata,
tibble::tribble(
  ~Experiment, ~ExtracellularActive,
    "190808a",                 TRUE,
     "190830",                 TRUE,
     "190903",                 TRUE,
     "190904",                 TRUE,
     "190905",                 TRUE,
     "190906",                 TRUE,
     "190907",                 TRUE,
     "190915",                 TRUE,
    "190916a",                 TRUE,
    "190917a",                   NA, # File not found. Entry not found in notebook either.
     "190917",                 TRUE,
     "190918",                 TRUE,
     "190924",                 TRUE,
    "190924a",                 TRUE,
     "191002",                 TRUE,
     "191004",                 TRUE,
     "190926",                 TRUE,
     "190927",                FALSE,
    "190927a",                 TRUE,
     "190930",                FALSE,
    "190930a",                FALSE,
     "191001",                 TRUE
  )
)

metadata %>% 
  select(Experiment, Condition, ExtracellularActive) %>% 
  filter(Condition %in% c("Baseline", "Compensated", "Delayed")) %>% 
  distinct() %>% 
  group_by(Condition, ExtracellularActive) %>% 
  tally()

```

Create cross type data, sans Brian's cells
```{r}
small_metadata <- metadata[, c("Experiment",  "FileName", "Condition")]

M_ionic<- ionic %>% mutate(Cell = as.character(Cell))  
#Ihtk.0 Ihtk.Slope  Ia.0 Ia.Slope
M_tecc <- left_join(tecc, small_metadata) %>% select(-FileName) %>% mutate(Cell = as.character(Cell))
# QC drop all non positive resistances, all ccs outside 0-1

M_tecc <- M_tecc %>% mutate(
  # cc  = ifelse(cc > 0 & cc < 1, cc, NA),
  r11 = ifelse(r11 >0, r11, NA),
  r1  = ifelse(r1 >0, r1, NA),
  # r12  = ifelse(r12 >0, r12, NA),
  # rc  = ifelse(rc >0, rc, NA)
  
  cc.3_4  = ifelse(cc.3_4 > 0 & cc.3_4 < 1, cc.3_4, NA),
  cc.3_5  = ifelse(cc.3_5 > 0 & cc.3_5 < 1, cc.3_5, NA),
  cc.4_3  = ifelse(cc.4_3 > 0 & cc.4_3 < 1, cc.4_3, NA),
  
  cc.4_5  = ifelse(cc.4_5 > 0 & cc.4_5 < 1, cc.4_5, NA),
  cc.5_3  = ifelse(cc.5_3 > 0 & cc.5_3 < 1, cc.5_3, NA),
  cc.5_4  = ifelse(cc.5_4 > 0 & cc.5_4 < 1, cc.5_4, NA)
) #%>% 
  # mutate(rc = rc^-1) %>% 
  # rename(rc.ig = rc)

#vrest     cc   r11    r12    r1    rc 
M_tevc <- left_join(tevc, small_metadata) %>% select(-FileName) %>% mutate(Cell = as.character(Cell)) 
#ig
M_epsp <- left_join(epsp, small_metadata) %>% 
  select(-FileName, -Type) %>% 
  mutate(Cell = as.character(Cell))  %>% 
  mutate(Key = case_when(Key %in% c("In4", "In9") ~ "Obs",
                                  Key %in% c("predicted")  ~ "Sim")) %>% 
  pivot_wider(names_from = "Key", values_from  = c("Min.V", "Max.Amplitude", "AUC")) %>% 
  mutate(Max.Amplitude_Sim = Max.Amplitude_Sim + (Min.V_Obs - Min.V_Sim)) %>% 
  mutate(Max.Amplitude_Delta = Max.Amplitude_Obs - Max.Amplitude_Sim,
         AUC_Delta = AUC_Obs - AUC_Sim) %>% 
  group_by(Condition, Experiment, Cell) %>% 
  select(-Min.V_Sim) %>% 
  mutate_at(c("Cor", 
              "Min.V_Obs", #"Min.V_Sim", "Min.V_Delta", 
              "Max.Amplitude_Obs", "Max.Amplitude_Sim", "Max.Amplitude_Delta", 
              "AUC_Obs", "AUC_Sim", "AUC_Delta"), median, na.rm = T) %>% 
  distinct() %>% 
  ungroup()
  

#Sweep   Cor Key        Min.V Max.Amplitude    AUC 
M_mrna <- left_join(mrna[mrna$Source == "Daniel", ], small_metadata) %>% select(-FileName) %>% mutate(Cell = as.character(Cell))


#Set up data cols to help organize full dataset
ionic_cols <- c("Ihtk.0", "Ihtk.Slope", "Ia.0", "Ia.Slope")
tecc_cols <- c("vrest", "r11", "r1", "cc.3_4", "cc.3_5", "cc.4_3", "cc.4_5", "cc.5_3", "cc.5_4")#, "r12", "rc.ig") # ignore rc, ig is a more direct measure
tevc_cols <- c("ig.3_4", "ig.3_5", "ig.4_5")
epsp_cols <- c("Cor", "Min.V_Obs", "Max.Amplitude_Obs", "Max.Amplitude_Sim", "AUC_Obs", "AUC_Sim", 
               "Max.Amplitude_Delta", "AUC_Delta")
mrna_cols <- names(mrna)[!(names(mrna) %in% c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell"))]


M_all <- full_join(M_ionic, M_tecc) %>% full_join(M_tevc) %>% full_join(M_epsp) %>% full_join(M_mrna)

reordered_names <- c(names(M_all)[!(names(M_all) %in% c(tecc_cols, tevc_cols, epsp_cols, ionic_cols, mrna_cols))], 
                                                      c(tecc_cols, tevc_cols, epsp_cols, ionic_cols, mrna_cols))


M_all <- M_all[, reordered_names] %>% filter(Condition %in% c("Baseline", "Compensated", "Delayed") & Cell %in% c(3, 4, 5)) %>% distinct()

# #TODO this needs some prep work. We'll want to capture the variance in these measures.
# # Not clear how to do that. 
# epsp %>% ggplot(aes(x = FileName, Max.Amplitude, color = interaction(Experiment, Cell)))+
#   geom_line()+
#   geom_point()+
#   facet_grid(.~Key)
```

# Primary Questions

What happens at the individual cell level?

membrane
```{r}
plt_membrane <- M_all %>% 
  select(Condition, Experiment, Cell, r11, r1, Ihtk.0, Ia.0) %>% 
  group_by(Condition, Experiment, Cell) %>% 
  mutate_all(median, na.rm = T) %>% 
  ungroup() %>% 
  distinct() 


plot_univariate_decorated_0 <- function(temp = plt_membrane,
                                        yvar = "Ihtk.0"){
  names(temp)[names(temp) == yvar] <- "yvar"
  
  temp_bands <- temp %>% 
    group_by(Condition) %>% 
    summarise(
      q10 = quantile(yvar, probs = 0.1, na.rm = T),
      q25 = quantile(yvar, probs = 0.25, na.rm = T),
      # q45 = quantile(yvar, probs = 0.45, na.rm = T),
      q50 = quantile(yvar, probs = 0.5, na.rm = T),
      # q55 = quantile(yvar, probs = 0.55, na.rm = T),
      q75 = quantile(yvar, probs = 0.75, na.rm = T),
      q90 = quantile(yvar, probs = 0.9, na.rm = T),
    ) %>% 
    mutate(outlier_up = q50 + 1.5*(q75 - q25),
           outlier_down = q50 - 1.5*(q75 - q25))
  
  temp <- full_join(temp, temp_bands)
  
  temp_plt <- ggplot(data = temp, aes(x = Condition, y = yvar))+
    # geom_ribbon(aes(x = Condition, ymin = q10, ymax = q90, group = 1), color = "lightgray", fill = "cornflowerblue", alpha = 0.3)+
    geom_ribbon(aes(x = Condition, ymin = q25, ymax = q75, group = 1), color = "darkgray", fill = "cornflowerblue", alpha = 0.3)+
    # geom_ribbon(aes(x = Condition, ymin = q45, ymax = q55, group = 1), color = "black", fill = "cornflowerblue", alpha = 0.3)+
    geom_line(aes(x = Condition, y = q50, group = 1), linetype = "dashed", color = "blue")+
    
    geom_line(aes(x = Condition, y = outlier_up, group = 1), linetype = "dashed", color = "black")+
    geom_line(aes(x = Condition, y = outlier_down, group = 1), linetype = "dashed", color = "black")+
    
    geom_point(aes(x = Condition, y = q50), color = "lightgray", size = 4)+
    geom_point(aes(x = Condition, y = q50), color = "black", size = 4, shape = 1)+
    geom_point(alpha = 0.5)+
    labs(y=yvar)
  
  return(temp_plt)
}


membrane_dvs_plt <- c("r11", "r1", "Ihtk.0", "Ia.0")
membrane_plts <- map(membrane_dvs_plt, function(i){plot_univariate_decorated_0(temp = ungroup(plt_membrane), yvar = i)})

membrane_plts[[1]]

membrane_plts[[2]]

membrane_plts[[3]]

membrane_plts[[4]]

walk(seq_along(membrane_dvs_plt), function(i){
  ggsave(paste0(membrane_dvs_plt[i],".tiff"), 
         plot = membrane_plts[[i]], 
         path = here("officer_output"), 
         width = 11.5/2, height = 4.76)  
})
```

mrna
```{r}
plt_mrna <- M_all[, c("Condition", "Experiment", "Cell", mrna_cols)] %>% 
  # select(Condition, Experiment, Cell, r11, r1, Ihtk.0, Ia.0) %>% 
  group_by(Condition, Experiment, Cell) %>% 
  mutate_all(median, na.rm = T) %>% 
  ungroup() %>% 
  distinct() 

mrna_plts <- map(mrna_cols, function(i){plot_univariate_decorated_0(temp = ungroup(plt_mrna), yvar = i)})

walk(seq_along(mrna_cols), function(i){
  ggsave(paste0(mrna_cols[i],".tiff"), 
         plot = mrna_plts[[i]], 
         path = here("officer_output"), 
         width = 11.5/2, height = 4.76)  
})
```


What happens at the network level?
```{r}
plt_tevc <- M_all %>% 
  select(Condition, Experiment, ig.3_4, ig.3_5, ig.4_5) %>% 
  distinct() %>% 
  gather("ElectricalSynapse", "ig", c("ig.3_4", "ig.3_5", "ig.4_5")) %>% 
  filter(!is.na(ig)) 

plt_1.1 <- 
plt_tevc %>% 
  filter(ElectricalSynapse != "ig.4_5") %>% 
  ggplot(aes(x = Condition, y = ig))+
  geom_boxplot()+
  ggbeeswarm::geom_beeswarm(alpha = 0.3)+
  # geom_violin()+
  # geom_point(position = position_jitter(width = 0.05), alpha = 0.3)+
  facet_wrap(.~ElectricalSynapse)
  
plt_1.2 <- plt_tevc %>% 
  filter(ElectricalSynapse == "ig.4_5") %>% 
  ggplot(aes(x = Condition, y = ig))+
    geom_segment(aes(x = "Baseline", xend = "Baseline", y =0, yend = 0.05), color = "gray", size = 2)+
  geom_boxplot()+
  ggbeeswarm::geom_beeswarm(alpha = 0.3)+
  facet_wrap(.~ElectricalSynapse)+
  scale_y_continuous(position = "right")

library(patchwork)
plt_1.1 + plt_1.2 + plot_layout(widths = c(2, 1) )

#### ####

plt_tecc <- M_all %>% 
  select(Condition, Experiment, cc.3_4, cc.3_5, cc.4_3, cc.4_5, cc.5_3, cc.5_4) %>% 
  group_by(Condition, Experiment) %>% 
  mutate_all(median, na.rm = T) %>% 
  ungroup() %>% 
  distinct() 

plt_2.0 <- 
plt_tecc %>% 
  gather("Cells", "CC", c("cc.3_4", "cc.3_5", "cc.4_3", "cc.4_5", "cc.5_3", "cc.5_4")) %>% 
  mutate(Cells = factor(Cells, levels = c("cc.3_4", "cc.4_3", "cc.3_5", "cc.5_3", "cc.4_5", "cc.5_4"))) %>% 
  filter(!is.na(CC)) %>% 
  ggplot(aes(Condition, CC))+
  geom_boxplot()+
  ggbeeswarm::geom_beeswarm(alpha = 0.3)+
  facet_grid(.~Cells)

plt_2.0

#### ####

triangle_lower_df <- data.frame(
  id    = c("b", "b", "b"),
  value = c("2", "2", "2"),
  x     = c(0, 1, 1),
  y     = c(0, 1, 0)
)

triangle_upper_df <- data.frame(
  id    = c("a", "a", "a"),
  value = c("1", "1", "1"),
  x     = c(0, 1, 0),
  y     = c(0, 1, 1)
)


plt_2.1 <- plt_tecc %>% 
  ggplot(aes(cc.3_4, cc.4_3))+
  geom_polygon(data = triangle_upper_df, aes(x = x, y = y, group = id), fill = "#e41a1c")+
  geom_polygon(data = triangle_lower_df, aes(x = x, y = y, group = id), fill = "#377eb8")+
  geom_abline(slope = 1, intercept = 0, linetype = "dashed")+
  geom_point()+
  facet_grid(.~Condition)

plt_2.2 <- plt_tecc %>% 
  ggplot(aes(cc.3_5, cc.5_3))+
  geom_polygon(data = triangle_upper_df, aes(x = x, y = y, group = id), fill = "#e41a1c")+
  geom_polygon(data = triangle_lower_df, aes(x = x, y = y, group = id), fill = "#4daf4a")+
  geom_point()+
  facet_grid(.~Condition)

plt_2.3 <- plt_tecc %>% 
  ggplot(aes(cc.4_5, cc.5_4))+
  geom_polygon(data = triangle_upper_df, aes(x = x, y = y, group = id), fill = "#377eb8")+
  geom_polygon(data = triangle_lower_df, aes(x = x, y = y, group = id), fill = "#4daf4a")+
  geom_point()+
  facet_grid(.~Condition)

plt_2.1 / plt_2.2 / plt_2.3
```




what happens at the level of output (excitability)? 

## What is different across the three groups? 
### Univariate

```{r}
# temp <- M_all %>% 
#   select(Condition, Experiment, Cell,  Ihtk.0) %>% 
#   group_by(Condition, Experiment, Cell) %>% 
#   mutate(Ihtk.0 = median(Ihtk.0, na.rm = T)) %>% 
#   distinct() %>% 
#   ungroup()
# 
# temp_bands <- temp %>% group_by(Condition) %>% summarise(
#   q10 = quantile(Ihtk.0, probs = 0.1, na.rm = T),
#   q25 = quantile(Ihtk.0, probs = 0.25, na.rm = T),
#   q45 = quantile(Ihtk.0, probs = 0.45, na.rm = T),
#   q50 = quantile(Ihtk.0, probs = 0.5, na.rm = T),
#   q55 = quantile(Ihtk.0, probs = 0.55, na.rm = T),
#   q75 = quantile(Ihtk.0, probs = 0.75, na.rm = T),
#   q90 = quantile(Ihtk.0, probs = 0.9, na.rm = T),
#   )
# 
# temp <- full_join(temp, temp_bands)
# 
# ggplot(data = temp, aes(x = Condition, y = Ihtk.0))+
#   geom_ribbon(aes(x = Condition, ymin = q10, ymax = q90, group = 1), color = "lightgray", fill = "cornflowerblue", alpha = 0.3)+
#   geom_ribbon(aes(x = Condition, ymin = q25, ymax = q75, group = 1), color = "darkgray", fill = "cornflowerblue", alpha = 0.3)+
#   # geom_ribbon(aes(x = Condition, ymin = q45, ymax = q55, group = 1), color = "black", fill = "cornflowerblue", alpha = 0.3)+
#   geom_line(aes(x = Condition, y = q50, group = 1), linetype = "dashed", color = "blue")+
#   geom_point(aes(x = Condition, y = q50), color = "lightgray", size = 4)+
#   geom_point(aes(x = Condition, y = q50), color = "black", size = 4, shape = 1)+
#   geom_point(alpha = 0.5)

# Make table ----
# c(tecc_cols, tevc_cols, epsp_cols, ionic_cols, mrna_cols)
# 
# temp_col = "Ihtk.0"

#TODO figure out what to do with the epsp cols
tictoc::tic()
temp_list <- map(
  c(tecc_cols, tevc_cols, epsp_cols, ionic_cols, mrna_cols), function(temp_col){
    print(temp_col)
    
    temp <- M_all[, c("Condition", "Experiment", "Cell", temp_col)] %>% distinct()
    
    # Identify outliers for each group
    temp_b <- temp[temp$Condition == "Baseline", ]
    temp_c <- temp[temp$Condition == "Compensated", ]
    temp_d <- temp[temp$Condition == "Delayed", ]
    
    temp_b <- temp_b[win_x_iqr(temp_b[[temp_col]], multiplier = 1.5), ]
    temp_c <- temp_c[win_x_iqr(temp_c[[temp_col]], multiplier = 1.5), ]
    temp_d <- temp_d[win_x_iqr(temp_d[[temp_col]], multiplier = 1.5), ]
    
    temp <- rbind(temp_b, temp_c) %>% rbind(temp_d)
    
    # temp <- temp[win_x_iqr(temp[[temp_col]], multiplier = 1.5), ]
    temp <- temp[!is.na(temp[[temp_col]]), ]
    
    # make sure we don't have pseudoreplicates for network measurements
    if (temp_col %in% c("ig.3_4", "ig.3_5", "ig.4_5")){
      temp <- temp %>% 
        select(-Cell) %>% 
        group_by(Condition, Experiment) %>% 
        mutate_all(median, na.rm = T) %>% 
        distinct()
    }
    
    
    if(nrow(temp) < 10){
      
      return(list(
        dv = temp_col,
        p = NA,
        ep = NA,
        hsd_groups = data.frame(dv = c(NA, NA, NA), 
                                groups = c(NA, NA, NA), 
                                Condition = c(NA, NA, NA)
        ),
        fm = NA))
      
    } else {
      
      
      temp_shuffle <- temp
      resample_array <- map(1:1000, function(i){
        temp_shuffle$Condition <- sample(temp_shuffle$Condition, replace = F)
        fm <- lm(as.formula(paste0(temp_col, " ~ Condition")), data = temp_shuffle)      
        return(car::Anova(fm)[1,3])
      }) %>% unlist()

      
      fm <- lm(as.formula(paste0(temp_col, " ~ Condition")), data = temp)
      
      fm_hsd <- agricolae::HSD.test(fm, trt = "Condition") 
      fm_hsd <- fm_hsd$group
      
      fm_hsd$Condition <- rownames(fm_hsd)
      
      
      
      return(list(
        dv = temp_col,
        p = car::Anova(fm)[1,4],
        ep = mean(resample_array >= car::Anova(fm)[1,3]),
        hsd_groups = fm_hsd,
        fm = fm))
    }
  })
tictoc::toc()


temp_list <- temp_list %>% transpose()
fm_overview_table <- data.frame(dv = unlist(temp_list[[1]]),
                                p  = unlist(temp_list[[2]]),
                                ep = unlist(temp_list[[3]]))


# work up post hoc stats
temp_list_hsd <- map(seq_along(temp_list[[4]]), function(i){
  if (!is.na(unique(temp_list[[4]][[i]]$groups))){
    temp_list[[4]][[i]] %>% 
      gather("dv", "Estimate", names(temp_list[[4]][[i]])[1]) %>% 
      pivot_wider(names_from = "Condition", values_from = c("groups", "Estimate") ) %>% 
      mutate_all(as.character)
  }
})  

fm_overview_hsd <- do.call(rbind, temp_list_hsd)
```

Make table
```{r}
fm_overview_table <- full_join(fm_overview_table, fm_overview_hsd)

 
# add groupings
fm_overview_table <- fm_overview_table %>% mutate(Family = case_when(
  dv %in% c("vrest") ~ "Resting Voltage",
  dv %in% c("r11", "r1") ~ "Membrane Resistance",
  dv %in% ionic_cols ~ "Outward Currents",
  dv %in% epsp_cols ~ "Excitability",
  dv %in% c("r12", "rc", "ig", "cc", "ig.3_4", "ig.3_5", "ig.4_5") ~ "Coupling Measures"
))

fm_overview_table <- fm_overview_table %>% 
  mutate(Family = factor(fm_overview_table$Family, levels = c("Membrane Resistance", "Resting Voltage", "Coupling Measures", "Outward Currents", "Excitability"))) %>% 
  arrange(Family) %>% 
  mutate(Family = as.character(Family))

# temp <- rename(mRNAInfo[, c("Family", "RGeneName")], dv = RGeneName)
fm_overview_table <- full_join(fm_overview_table, 
                               rename(mRNAInfo[, c("Family", "RGeneName")], dv = RGeneName, Family2 = Family))

fm_overview_table <- fm_overview_table %>% 
  mutate(Family = ifelse(is.na(Family) & !is.na(Family2), Family2, Family)) %>% 
  select(-Family2) %>% 
  filter(!is.na(p))


# add additional cols
fm_overview_table$fdr <- p.adjust(fm_overview_table$ep, method = "fdr")

fm_overview_table <- fm_overview_table %>% 
  mutate(Estimate_Baseline = as.numeric(Estimate_Baseline),
         Estimate_Compensated = as.numeric(Estimate_Compensated),
         Estimate_Delayed = as.numeric(Estimate_Delayed)) %>% 
  mutate(p = round(p, digits = 4),
         ep = round(ep, digits = 4),
         fdr = round(fdr, digits = 4),
         Estimate_Baseline = round(Estimate_Baseline, digits = 4),
         Estimate_Compensated = round(Estimate_Compensated, digits = 4),
         Estimate_Delayed = round(Estimate_Delayed, digits = 4)) %>% 
  mutate(stars = case_when(fdr > 0.10               ~ "",
                           fdr < 0.10 & fdr > 0.05  ~ ".",
                           fdr < 0.05 & fdr > 0.01  ~ "*",
                           fdr < 0.01 & fdr > 0.001 ~ "**",
                           fdr < 0.001              ~ "***"
  ))


# library(officer)
library(flextable)
M_ft <-flextable(fm_overview_table,
                 col_keys = c("Family", "dv", "p", "ep",
                              "fdr", 
                              "stars", "Estimate_Baseline", "Estimate_Compensated", "Estimate_Delayed"))

M_ft <- theme_vanilla(M_ft)
M_ft <- merge_v(M_ft, j = c("Family") )
# M_ft <- color(M_ft, ~ fdr < 0.05, ~ stars, color = "red")
M_ft <- bold(M_ft, ~ fdr <= 0.05, ~ dv, bold = TRUE)
M_ft <- bold(M_ft, ~ p   <= 0.05, ~ p, bold = TRUE)
M_ft <- bold(M_ft, ~ ep  <= 0.05, ~ ep, bold = TRUE)
M_ft <- bold(M_ft, ~ fdr <= 0.05, ~ fdr, bold = TRUE)
M_ft <- bold(M_ft, ~ fdr <= 0.05, ~ stars, bold = TRUE)

# get the groupings without showing the columns. 

color_a = "#ffeda0"
color_ab= "#feb24c"
color_b = "#f03b20"
color_c = "#2b8cbe"

M_ft <- bg(M_ft, ~ groups_Baseline == "a", ~ Estimate_Baseline, bg = color_a)
M_ft <- bg(M_ft, ~ groups_Baseline == "ab",~ Estimate_Baseline, bg = color_ab)
M_ft <- bg(M_ft, ~ groups_Baseline == "b", ~ Estimate_Baseline, bg = color_b)
M_ft <- bg(M_ft, ~ groups_Baseline == "c", ~ Estimate_Baseline, bg = color_c)

M_ft <- bg(M_ft, ~ groups_Compensated == "a", ~ Estimate_Compensated, bg = color_a)
M_ft <- bg(M_ft, ~ groups_Compensated == "ab",~ Estimate_Compensated, bg = color_ab)
M_ft <- bg(M_ft, ~ groups_Compensated == "b", ~ Estimate_Compensated, bg = color_b)
M_ft <- bg(M_ft, ~ groups_Compensated == "c", ~ Estimate_Compensated, bg = color_c)

M_ft <- bg(M_ft, ~ groups_Delayed == "a", ~ Estimate_Delayed, bg = color_a)
M_ft <- bg(M_ft, ~ groups_Delayed == "ab",~ Estimate_Delayed, bg = color_ab)
M_ft <- bg(M_ft, ~ groups_Delayed == "b", ~ Estimate_Delayed, bg = color_b)
M_ft <- bg(M_ft, ~ groups_Delayed == "c", ~ Estimate_Delayed, bg = color_c)


M_ft <- bg(M_ft, ~ fdr > 0.05, ~ Estimate_Baseline, bg = "White")
M_ft <- bg(M_ft, ~ fdr > 0.05, ~ Estimate_Compensated, bg = "White")
M_ft <- bg(M_ft, ~ fdr > 0.05, ~ Estimate_Delayed, bg = "White")


M_ft <- set_header_labels(M_ft, Estimate_Baseline = "Baseline", Estimate_Compensated = "Compensated", Estimate_Delayed = "Delayed" )

M_ft <- autofit(M_ft)
M_ft

pptx_file <- "./officer_output/example.pptx"
save_as_pptx("my table" = M_ft, path = pptx_file)




# fm_overview_table %>% 
#   ggplot(aes(x = ep))+
#   geom_histogram(binwidth = 0.025)+
#   geom_vline(xintercept = 0.05)
```


## Another take on excitability:
### binned Cor
```{r eval=FALSE}

# Goal: extract Absolute measures and differential measures for 
# 1. Burst Amplitude (max mV)
# 2. AUC 
# 3. Stimulus correlation (between)


# read in trace
brian2_trace_files <- list.files(here("data", "predicted_voltage"))

brian2_trace_sets <- brian2_trace_files %>% 
  str_remove(pattern = "-actual_v.rds") %>% 
  str_remove(pattern = "-predict_v.rds") %>% 
  unique()

epsp_summary_list <- map(seq(1, length(brian2_trace_sets)), function(i){
  print(i)
  brian2_read_in <- brian2_trace_files[str_detect(brian2_trace_files, brian2_trace_sets[i])]
  

  # retrieve data and merge into a single df
  temp <- map(brian2_read_in, function(read_file){
    temp_predict <- readRDS(here("data", "predicted_voltage", read_file))
    
    if(str_detect(read_file, pattern = "predict_v")){
      #consolidate into one df
      for (j in seq(1, length(temp_predict))){
        temp_predict[[j]]$Sweep <- j
      }
      temp_predict <- do.call(rbind, temp_predict)
    }
    return(temp_predict)
  })
  
  names(temp) <- brian2_read_in
  
  temp_a <- temp[str_detect(names(temp), pattern = "actual_v")][[1]]
  temp_p <- temp[str_detect(names(temp), pattern = "predict_v")][[1]] %>% as.data.frame() %>% as_tibble()
  temp_a$nrow <- seq(1, nrow(temp_a))
  temp_p$nrow <- seq(1, nrow(temp_p))
  temp_a$Sweep <- as.character(temp_a$Sweep)
  temp_p$Sweep <- as.character(temp_p$Sweep)
  
  temp <- full_join(temp_a, select(temp_p, -Time)) %>% select(-nrow)
  
  # Show difference between expected/actual
  # i = 1
  # [1] "190808a_0014-epsp-In4-actual_v.rds"  "190808a_0014-epsp-In4-predict_v.rds" shows why we need to be able to audit the outcome.
  # Here the end of sweep 4 deviates from baseline so the delta is off
  # TODO instead of subtracting a value at the end, we should look at the times with i_inj less than x and then use a percentile from that to estimate the baseline.
  

  # To get around this in the short term we'll calulate the factors independently for expected/obs
  # downsample_data(temp, len = 10000) %>% 
  # # temp %>% 
  #   mutate(predicted = predicted - offset) %>% 
  #   mutate(difference = In4-predicted) %>% 
  #   ggplot(aes(x = Time))+
  #   geom_ribbon(aes(ymin=In4, ymax=predicted), fill = "cornflowerblue")+
  #   geom_line(aes(y=In4), color = "black")+
  #   geom_line(aes(y=predicted), color = "cornflowerblue", alpha = 0.3)+
  #   # geom_line(aes(y=difference-offset), color = "purple")+
  #   facet_grid(Sweep~.)
  
  # This is an inelegant workaround for data that is based on in9/12. This prevents duplication of the large set below
  
  rewrite_names <- F
  if ("In9" %in% names(temp)){
    names(temp) <- c("In4", "In7", "Sweep", "Time", "predicted", "offset")
    rewrite_names <- T
  }
  
  Use.Bin.Size <- 19687
  
  temp_processed <- temp
  temp_processed$TimeBin <- rep(rep(seq(1, (nrow(temp)/4)/Use.Bin.Size), each = Use.Bin.Size), times = 4)

  # begin to work with data proper
  # Add optional ways to slice the data based on what we expect to occur
  # At the moment we leave this unused
  temp_processed <- temp_processed %>% 
    mutate(
      Period = case_when(
        Time > 0.40  & Time <  4.87  ~ "A",
        Time > 4.87  & Time < 10.74  ~ "B",
        Time > 10.74 & Time < 16.74  ~ "C",
        Time > 16.74 & Time < 19.685 ~ "D"
      ),
      Period_eq = case_when(
        Time > 0.40  & Time <  0.40 + 2.945 ~ "A",
        Time > 4.87  & Time <  4.87 + 2.945 ~ "B",
        Time > 10.74 & Time < 10.74 + 2.945 ~ "C",
        Time > 16.74 & Time < 16.74 + 2.945 ~ "D"
      ),
      Burst = case_when(
        Time > 0.40  & Time <  2    ~ "A",
        Time > 4.87  & Time <  6.17 ~ "B",
        Time > 10.74 & Time < 12.54 ~ "C",
        Time > 16.74 & Time < 18.5  ~ "D"
      ),
      Burst_eq = case_when(
        Time > 0.40  & Time <  2    + 1.30 ~ "A",
        Time > 4.87  & Time <  6.17 + 1.30 ~ "B",
        Time > 10.74 & Time < 12.54 + 1.30 ~ "C",
        Time > 16.74 & Time < 18.5  + 1.30 ~ "D"
      )
    ) %>% 
    # correlation with expected
    group_by(Sweep, TimeBin) %>% 
    mutate(Cor = cor(In4, predicted)) %>% 
    ungroup() %>% 
    gather(Key, mV, c("In4", "predicted")) %>% 
    ## Metrics for whole sweep
    group_by(Key, Sweep) %>% 
    # Min voltage
    mutate(Min.V = min(mV, na.rm = T)) %>%
    # Defining Baseline as average of the lowest 20% of points
    mutate(Use.in.Base = quantile(mV, probs = .2, na.rm = T)) %>%
    mutate(Use.in.Base = ifelse(mV <= Use.in.Base, mV, NA)) %>%
    mutate(Use.in.Base = mean(Use.in.Base, na.rm = T)) %>%
    # Max voltage
    mutate(Max.Amplitude = max(mV, na.rm = T)) %>%
    # AUC
    # Using Min.V
    # mutate(AUC = sum(mV - Min.V, na.rm = T)/(max(temp$Time)/Use.Bin.Size)) %>%
    ungroup() 
  
  temp_processed <- temp_processed[seq(1, nrow(temp_processed), by = Use.Bin.Size), ]
  
  
  
  if (rewrite_names){
    temp_processed <- temp_processed %>% 
      mutate(Key = ifelse(Key == "In4", "In9", Key))
  }
  
  
  temp_processed <- temp_processed[, c("Sweep", "TimeBin", "Time", "Cor", "Key", "Min.V", #"Use.in.Base", 
                                       "Max.Amplitude", "AUC")] %>% 
    distinct() #%>% 
    # pivot_wider(names_from = "Key", values_from = c("Min.V", #"Use.in.Base", 
    #                                                 "Max.Amplitude", "AUC")) 
  
  
  # add annotations to aid merging
  file_name <- brian2_read_in[[1]] %>% str_split(pattern = "-")
  
  temp_processed$Experiment <- as.character(str_split(as.character(file_name[[1]][1]), pattern = "_")[[1]][1])
  temp_processed$FileName <- paste0(as.character(file_name[[1]][1]), ".abf")
  temp_processed$Channel <- as.character(file_name[[1]][3])
  
  return(temp_processed)
})


epsp_summary <- do.call(rbind, epsp_summary_list)
# epsp_summary <- epsp_summary[, c("Experiment", "FileName", "Channel", "Sweep", "Cor", "Key", "Min.V", "Max.Amplitude", "AUC")]

epsp_summary %>% filter(FileName == "190808a_0014.abf", Sweep == 1) %>% 
  ggplot(aes(x = Time, y = Cor))+
  geom_point()


ggplot(aes(x = Time, y = Cor))+
  scattermore::geom_scattermost(
    as.data.frame(epsp_summary[epsp_summary$Sweep == 1, ]),
    # col=viridisLite::viridis(100, alpha=0.05)[1+99*d[,2]],
    pointsize=1,
    pixels=c(700,700)) +
  ggtitle("geom_scattermost")


```

### Binned by event
```{r eval=FALSE}

# Goal: extract Absolute measures and differential measures for 
# 1. Burst Amplitude (max mV)
# 2. AUC 
# 3. Stimulus correlation (between)


# read in trace
brian2_trace_files <- list.files(here("data", "predicted_voltage"))

brian2_trace_sets <- brian2_trace_files %>% 
  str_remove(pattern = "-actual_v.rds") %>% 
  str_remove(pattern = "-predict_v.rds") %>% 
  unique()

epsp_summary_list <- map(seq(1, length(brian2_trace_sets)), function(i){
  print(i)
  brian2_read_in <- brian2_trace_files[str_detect(brian2_trace_files, brian2_trace_sets[i])]
  

  # retrieve data and merge into a single df
  temp <- map(brian2_read_in, function(read_file){
    temp_predict <- readRDS(here("data", "predicted_voltage", read_file))
    
    if(str_detect(read_file, pattern = "predict_v")){
      #consolidate into one df
      for (j in seq(1, length(temp_predict))){
        temp_predict[[j]]$Sweep <- j
      }
      temp_predict <- do.call(rbind, temp_predict)
    }
    return(temp_predict)
  })
  
  names(temp) <- brian2_read_in
  
  temp_a <- temp[str_detect(names(temp), pattern = "actual_v")][[1]]
  temp_p <- temp[str_detect(names(temp), pattern = "predict_v")][[1]] %>% as.data.frame() %>% as_tibble()
  temp_a$nrow <- seq(1, nrow(temp_a))
  temp_p$nrow <- seq(1, nrow(temp_p))
  temp_a$Sweep <- as.character(temp_a$Sweep)
  temp_p$Sweep <- as.character(temp_p$Sweep)
  
  temp <- full_join(temp_a, select(temp_p, -Time)) %>% select(-nrow)
  
  # Show difference between expected/actual
  # i = 1
  # [1] "190808a_0014-epsp-In4-actual_v.rds"  "190808a_0014-epsp-In4-predict_v.rds" shows why we need to be able to audit the outcome.
  # Here the end of sweep 4 deviates from baseline so the delta is off
  # TODO instead of subtracting a value at the end, we should look at the times with i_inj less than x and then use a percentile from that to estimate the baseline.
  

  # To get around this in the short term we'll calulate the factors independently for expected/obs
  # downsample_data(temp, len = 10000) %>% 
  # # temp %>% 
  #   mutate(predicted = predicted - offset) %>% 
  #   mutate(difference = In4-predicted) %>% 
  #   ggplot(aes(x = Time))+
  #   geom_ribbon(aes(ymin=In4, ymax=predicted), fill = "cornflowerblue")+
  #   geom_line(aes(y=In4), color = "black")+
  #   geom_line(aes(y=predicted), color = "cornflowerblue", alpha = 0.3)+
  #   # geom_line(aes(y=difference-offset), color = "purple")+
  #   facet_grid(Sweep~.)
  
  # This is an inelegant workaround for data that is based on in9/12. This prevents duplication of the large set below
  
  rewrite_names <- F
  if ("In9" %in% names(temp)){
    names(temp) <- c("In4", "In7", "Sweep", "Time", "predicted", "offset")
    rewrite_names <- T
  }
  
  # begin to work with data proper
  # Add optional ways to slice the data based on what we expect to occur
  # At the moment we leave this unused
  temp_processed <- temp %>% 
    mutate(
      Segment = case_when(
        Time > 0.40  & Time < 2      ~ "A_B",
        Time > 2     & Time < 4.87   ~ "A_I",
        Time > 4.87  & Time < 6.17   ~ "B_B",
        Time > 6.17  & Time < 10.74  ~ "B_I",        
        Time > 10.74 & Time < 12.54  ~ "C_B",
        Time > 12.54 & Time < 16.74  ~ "C_I",
        Time > 16.74 & Time < 18.5   ~ "D_B",
        Time > 18.5  & Time < 19.685 ~ "D_I"
      )
    ) %>% 
    # correlation with expected
    group_by(Sweep, Segment) %>% 
    mutate(Cor = cor(In4, predicted)) %>% 
    ungroup() %>% 
    gather(Key, mV, c("In4", "predicted")) %>% 
    ## Metrics for whole sweep
    group_by(Key, Sweep) %>% 
    # Min voltage
    mutate(Min.V = min(mV, na.rm = T)) %>%
    # Defining Baseline as average of the lowest 20% of points
    mutate(Use.in.Base = quantile(mV, probs = .2, na.rm = T)) %>%
    mutate(Use.in.Base = ifelse(mV <= Use.in.Base, mV, NA)) %>%
    mutate(Use.in.Base = mean(Use.in.Base, na.rm = T)) %>%
    # Max voltage
    mutate(Max.Amplitude = max(mV, na.rm = T)) %>%
    # AUC
    # Using Min.V
    # mutate(AUC = sum(mV - Min.V, na.rm = T)/19.68685) %>%
    ungroup() 
  
  
  if (rewrite_names){
    temp_processed <- temp_processed %>% 
      mutate(Key = ifelse(Key == "In4", "In9", Key))
  }
  
  
  temp_processed <- temp_processed[, c("Sweep", "Segment", "Cor", "Key", "Min.V", #"Use.in.Base", 
                                       "Max.Amplitude")] %>% 
    distinct() #%>% 
    # pivot_wider(names_from = "Key", values_from = c("Min.V", #"Use.in.Base", 
    #                                                 "Max.Amplitude", "AUC")) 
  
  
  # add annotations to aid merging
  file_name <- brian2_read_in[[1]] %>% str_split(pattern = "-")
  
  temp_processed$Experiment <- as.character(str_split(as.character(file_name[[1]][1]), pattern = "_")[[1]][1])
  temp_processed$FileName <- paste0(as.character(file_name[[1]][1]), ".abf")
  temp_processed$Channel <- as.character(file_name[[1]][3])
  
  return(temp_processed)
})


epsp_summary <- do.call(rbind, epsp_summary_list)
# epsp_summary <- epsp_summary[, c("Experiment", "FileName", "Channel", "Sweep", "Cor", "Key", "Min.V", "Max.Amplitude", "AUC")]



epsp_summary <- left_join(epsp_summary, metadata) %>% 
  select(-FileName, -Type) %>% 
  mutate(Cell = case_when(Channel == "In4" ~ In4,
                          Channel == "In9" ~ In9)) %>% 
  mutate(Cell = as.character(Cell))  %>% 
  mutate(Key = case_when(Key %in% c("In4", "In9") ~ "Obs",
                                  Key %in% c("predicted")  ~ "Sim")) %>% 
  pivot_wider(names_from = "Key", values_from  = c("Min.V", "Max.Amplitude")) %>% 
  mutate(Max.Amplitude_Sim = Max.Amplitude_Sim + (Min.V_Obs - Min.V_Sim)) %>% 
  mutate(Max.Amplitude_Delta = Max.Amplitude_Obs - Max.Amplitude_Sim) %>% 
  group_by(Condition, Experiment, Cell, Segment, Sweep) %>% 
  select(-Min.V_Sim) %>% 
  mutate_at(c("Cor", 
              "Min.V_Obs", #"Min.V_Sim", "Min.V_Delta", 
              "Max.Amplitude_Obs", "Max.Amplitude_Sim", "Max.Amplitude_Delta"), median, na.rm = T) %>% 
  distinct() %>% 
  ungroup()


epsp_summary %>% 
  ggplot(aes(x = Segment, y = Cor, group = Sweep, color = Sweep))+
  geom_point(position = position_jitter(width = 0.1), alpha = 0.3)+
  geom_smooth(se = F)+
  facet_grid(.~Condition)+
  ggsci::scale_color_aaas()

epsp_summary %>% 
  filter(!is.na(Segment)) %>% 
  ggplot(aes(x = Cor, y = Sweep, fill = factor(stat(quantile))))+#, group = Sweep, color = Sweep))+
  # ggridges::geom_density_ridges()+
  ggridges::stat_density_ridges(
               geom = "density_ridges_gradient", calc_ecdf = TRUE,
               quantiles = 4, quantile_lines = TRUE
             ) +
               scale_fill_viridis_d(name = "Quartiles")+
  coord_flip()+
  facet_grid(Condition~Segment)+
  theme(legend.position = "")
  


## Here's the stimulus used in the protocol ====
# sweep duration should be 19.687 seconds
epsp_stim <- readABF_as_matrix(here("inst", "extdata", "epsp_stim_files", "08 current injection.abf"),
                  channels = "Axo1I2")
epsp_stim <- as_tibble(epsp_stim) %>%
  mutate(Time = Time - min(Time, na.rm = T)) %>%
  rename(Stim = Axo1I2)



epsp_stim <- mutate(epsp_stim,
Stim = Stim - min(Stim, na.rm = T),
         Stim = (Stim / 11.9034)-1) 


epsp_summary %>% 
  filter(!is.na(Segment)) %>% 
  mutate(x = case_when(
    Segment == "A_B" ~ 0.40,
    Segment == "A_I" ~ 2,
    Segment == "B_B" ~ 4.87,
    Segment == "B_I" ~ 6.17,
    Segment == "C_B" ~ 10.74,
    Segment == "C_I" ~ 12.54,
    Segment == "D_B" ~ 16.74,
    Segment == "D_I" ~ 18.5
  ),
  xend = case_when(
    Segment == "A_B" ~ 2,
    Segment == "A_I" ~ 4.87,
    Segment == "B_B" ~ 6.17,
    Segment == "B_I" ~ 10.74,
    Segment == "C_B" ~ 12.54,
    Segment == "C_I" ~ 16.74,
    Segment == "D_B" ~ 18.5,
    Segment == "D_I" ~ 19.687
  )) %>% 
  ggplot()+
  geom_segment(aes(x = x, y = Cor, xend = xend, yend = Cor, colour = Cor))+
  facet_grid(Condition~Sweep)+
  geom_line(data = epsp_stim, aes(Time, Stim))+
  theme(legend.position = "")+
  scale_color_viridis_c(direction = -1, option = "B")
#   option	
# A character string indicating the colormap option to use. Four options are available: "magma" (or "A"), "inferno" (or "B"), "plasma" (or "C"), "viridis" (or "D", the default option) and "cividis" (or "E").
  





epsp_stim %>% 
  mutate(Stim = Stim - min(Stim, na.rm = T),
         Stim = (Stim / 11.9034)-1) %>%
  ggplot(aes(Time, Stim))+
  geom_line()

# 
# 
# shading_annotations <- data.frame(
#   starts = c(0.40,
#              4.87,
#              10.74,
#              16.74),
#   next_start = c(4.87,
#                  10.74,
#                  16.74,
#                  19.685),
#   equal_len = c(0.40,
#                 4.87,
#                 10.74,
#                 16.74) + 2.945,
#   on_end = c(2,
#              6.17,
#              12.54, 
#              18.5),
#   equal_on = c(0.40,
#                4.87,
#                10.74,
#                16.74) + 1.30
# )
# 
# annotation_df <- data.frame(x = c(0.5, 0.5, 2.1, 1.8),
#                             y = seq(0.25, -1.25, length.out = 4),
#                             text = c("Period",
#                                      "Minumum Period",
#                                      "Burst", 
#                                      "Min Burst"))
# 
# segmentation_demo_plt <- ggplot()+
#   geom_vline(xintercept = c(shading_annotations$starts, shading_annotations$equal_len, shading_annotations$next_start, shading_annotations$equal_on), color = "gray")+
#   geom_path(data = epsp_stim, aes(Time, Stim+1.5))+
#   geom_rect(data = shading_annotations, aes(xmin = starts, xmax = next_start, ymin = 0, ymax = 0.5), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[1], color = RColorBrewer::brewer.pal(3, "Set1")[1])+
#   geom_rect(data = shading_annotations, aes(xmin = starts, xmax = equal_len, ymin = -0.5, ymax = 0), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[1], color = RColorBrewer::brewer.pal(3, "Set1")[1])+
#   geom_rect(data = shading_annotations, aes(xmin = starts, xmax = on_end, ymin = -1, ymax = -0.5), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[2], color = RColorBrewer::brewer.pal(3, "Set1")[2])+
#   geom_rect(data = shading_annotations, aes(xmin = starts, xmax = equal_on, ymin = -1.5, ymax = -1), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[2], color = RColorBrewer::brewer.pal(3, "Set1")[2])+
#   theme_classic()+
#   # geom_vline(xintercept = 12.54)+
#   geom_text(data = annotation_df[1:2, ], aes(x=x, y=y, label = text), hjust = "inward", color = RColorBrewer::brewer.pal(3, "Set1")[1])+
#   geom_text(data = annotation_df[3:4, ], aes(x=x, y=y, label = text), hjust = "inward", color = RColorBrewer::brewer.pal(3, "Set1")[2])+
#   ylim(-1.5, 9.5)+
#   labs(title = "Ways to Segement EPSP Stim")
# 
# 
# segmentation_demo_plt
```

### Rolling Cor
```{r eval=FALSE}

# Goal: extract Absolute measures and differential measures for 
# 1. Burst Amplitude (max mV)
# 2. AUC 
# 3. Stimulus correlation (between)


# read in trace
brian2_trace_files <- list.files(here("data", "predicted_voltage"))

brian2_trace_sets <- brian2_trace_files %>% 
  str_remove(pattern = "-actual_v.rds") %>% 
  str_remove(pattern = "-predict_v.rds") %>% 
  unique()

epsp_summary_list <- map(seq(1, length(brian2_trace_sets)), function(i){
  print(i)
  brian2_read_in <- brian2_trace_files[str_detect(brian2_trace_files, brian2_trace_sets[i])]
  

  # retrieve data and merge into a single df
  temp <- map(brian2_read_in, function(read_file){
    temp_predict <- readRDS(here("data", "predicted_voltage", read_file))
    
    if(str_detect(read_file, pattern = "predict_v")){
      #consolidate into one df
      for (j in seq(1, length(temp_predict))){
        temp_predict[[j]]$Sweep <- j
      }
      temp_predict <- do.call(rbind, temp_predict)
    }
    return(temp_predict)
  })
  
  names(temp) <- brian2_read_in
  
  temp_a <- temp[str_detect(names(temp), pattern = "actual_v")][[1]]
  temp_p <- temp[str_detect(names(temp), pattern = "predict_v")][[1]] %>% as.data.frame() %>% as_tibble()
  temp_a$nrow <- seq(1, nrow(temp_a))
  temp_p$nrow <- seq(1, nrow(temp_p))
  temp_a$Sweep <- as.character(temp_a$Sweep)
  temp_p$Sweep <- as.character(temp_p$Sweep)
  
  temp <- full_join(temp_a, select(temp_p, -Time)) %>% select(-nrow)
  
  # Show difference between expected/actual
  # i = 1
  # [1] "190808a_0014-epsp-In4-actual_v.rds"  "190808a_0014-epsp-In4-predict_v.rds" shows why we need to be able to audit the outcome.
  # Here the end of sweep 4 deviates from baseline so the delta is off
  # TODO instead of subtracting a value at the end, we should look at the times with i_inj less than x and then use a percentile from that to estimate the baseline.
  

  # To get around this in the short term we'll calulate the factors independently for expected/obs
  # downsample_data(temp, len = 10000) %>% 
  # # temp %>% 
  #   mutate(predicted = predicted - offset) %>% 
  #   mutate(difference = In4-predicted) %>% 
  #   ggplot(aes(x = Time))+
  #   geom_ribbon(aes(ymin=In4, ymax=predicted), fill = "cornflowerblue")+
  #   geom_line(aes(y=In4), color = "black")+
  #   geom_line(aes(y=predicted), color = "cornflowerblue", alpha = 0.3)+
  #   # geom_line(aes(y=difference-offset), color = "purple")+
  #   facet_grid(Sweep~.)
  
  # This is an inelegant workaround for data that is based on in9/12. This prevents duplication of the large set below
  
  rewrite_names <- F
  if ("In9" %in% names(temp)){
    names(temp) <- c("In4", "In7", "Sweep", "Time", "predicted", "offset")
    rewrite_names <- T
  }
  
  # begin to work with data proper
  # Add optional ways to slice the data based on what we expect to occur
  # At the moment we leave this unused
  temp_processed <- temp %>% 
    mutate(
      Period = case_when(
        Time > 0.40  & Time <  4.87  ~ "A",
        Time > 4.87  & Time < 10.74  ~ "B",
        Time > 10.74 & Time < 16.74  ~ "C",
        Time > 16.74 & Time < 19.685 ~ "D"
      ),
      Period_eq = case_when(
        Time > 0.40  & Time <  0.40 + 2.945 ~ "A",
        Time > 4.87  & Time <  4.87 + 2.945 ~ "B",
        Time > 10.74 & Time < 10.74 + 2.945 ~ "C",
        Time > 16.74 & Time < 16.74 + 2.945 ~ "D"
      ),
      Burst = case_when(
        Time > 0.40  & Time <  2    ~ "A",
        Time > 4.87  & Time <  6.17 ~ "B",
        Time > 10.74 & Time < 12.54 ~ "C",
        Time > 16.74 & Time < 18.5  ~ "D"
      ),
      Burst_eq = case_when(
        Time > 0.40  & Time <  2    + 1.30 ~ "A",
        Time > 4.87  & Time <  6.17 + 1.30 ~ "B",
        Time > 10.74 & Time < 12.54 + 1.30 ~ "C",
        Time > 16.74 & Time < 18.5  + 1.30 ~ "D"
      )
    ) %>% 
    # correlation with expected
    group_by(Sweep) %>% 
    mutate(Cor = cor(In4, predicted)) %>% 
    ungroup() %>% 
    gather(Key, mV, c("In4", "predicted")) %>% 
    ## Metrics for whole sweep
    group_by(Key, Sweep) %>% 
    # Min voltage
    mutate(Min.V = min(mV, na.rm = T)) %>%
    # Defining Baseline as average of the lowest 20% of points
    mutate(Use.in.Base = quantile(mV, probs = .2, na.rm = T)) %>%
    mutate(Use.in.Base = ifelse(mV <= Use.in.Base, mV, NA)) %>%
    mutate(Use.in.Base = mean(Use.in.Base, na.rm = T)) %>%
    # Max voltage
    mutate(Max.Amplitude = max(mV, na.rm = T)) %>%
    # AUC
    # Using Min.V
    mutate(AUC = sum(mV - Min.V, na.rm = T)/19.68685) %>%
    ungroup() 
  
  
  if (rewrite_names){
    temp_processed <- temp_processed %>% 
      mutate(Key = ifelse(Key == "In4", "In9", Key))
  }
  
  
  temp_processed <- temp_processed[, c("Sweep", "Cor", "Key", "Min.V", #"Use.in.Base", 
                                       "Max.Amplitude", "AUC")] %>% 
    distinct() #%>% 
    # pivot_wider(names_from = "Key", values_from = c("Min.V", #"Use.in.Base", 
    #                                                 "Max.Amplitude", "AUC")) 
  
  
  # add annotations to aid merging
  file_name <- brian2_read_in[[1]] %>% str_split(pattern = "-")
  
  temp_processed$Experiment <- as.character(str_split(as.character(file_name[[1]][1]), pattern = "_")[[1]][1])
  temp_processed$FileName <- paste0(as.character(file_name[[1]][1]), ".abf")
  temp_processed$Channel <- as.character(file_name[[1]][3])
  
  return(temp_processed)
})


epsp_summary <- do.call(rbind, epsp_summary_list)
epsp_summary <- epsp_summary[, c("Experiment", "FileName", "Channel", "Sweep", "Cor", "Key", "Min.V", "Max.Amplitude", "AUC")]

```


## What relationships exist at baseline?

```{r}
#TODO
```


## How do these relationships change for TEA over time?

### globally, clustering etc
```{r}

temp <- unite(data = M, "Pharm_Condition", Pharm, Condition) 

# baseline, compensated, delayed
no_outlier_tea_list <- map(unique(temp$Pharm_Condition)[order(unique(temp$Pharm_Condition))], function(PhCon){
  temp2 <- temp[temp$Pharm_Condition == PhCon, ]
  
  for (NAME in names(M)[!(names(M) %in% c("Pharm_Condition" , "Pharm", "Condition", "Cell", "Experiment", "Source", "Time", "Sample"))]){
    temp2[[NAME]] <- ifelse(win_x_iqr(temp2[[NAME]]), temp2[[NAME]], NA)
  }
  
  return(temp2)
})

# walk(seq_along(no_outlier_tea_list), function(i){
#   for_corr <- no_outlier_tea_list[[i]][, c(MeasuredKCurrents, MeasuredmRNA)]
#   
#   MCorr <- cor(for_corr, use = "pairwise.complete.obs")
#   
#   pMat <- cor_pmat(for_corr)
#   
#   png(filename=c("plots/BaselineTEA.png", "plots/CompensatedTEA.png", "plots/DelayedTEA.png")[i])
#   # plot(faithful)
#   corrplot(MCorr, method = "square", type = "upper", tl.col = "black", 
#            # order = "hclust", 
#            col = brewer.pal(n = 9, name = "PuOr"),
#            p.mat = pMat,
#            sig.level = 0.05, insig = "blank")  
#   dev.off()
# })


tea_plt_list <- map(seq_along(no_outlier_tea_list), function(i){
  for_corr <- no_outlier_tea_list[[i]][, c(MeasuredKCurrents, MeasuredmRNA)]
  
  MCorr <- cor(for_corr, use = "pairwise.complete.obs")
  
  pMat <- cor_pmat(for_corr)
  
  MCorr <- as.data.frame(MCorr) 
  MCorr$row_names <- rownames(MCorr)
  MCorr <- MCorr %>% gather(col_names, Corr, names(MCorr)[names(MCorr) != "row_names"])
  
  pMat <- as.data.frame(pMat) 
  pMat$row_names <- rownames(pMat)
  pMat <- pMat %>% gather(col_names, p, names(pMat)[names(pMat) != "row_names"])
  
  
  
  ggplot(MCorr, aes(col_names, row_names, fill = Corr))+
    geom_tile()+
    geom_tile(data = pMat[pMat$p > 0.05, ], aes(col_names, row_names, fill = p), fill = "white", color = "white")+
    scale_fill_gradient2(low = RColorBrewer::brewer.pal(7, "PuOr")[1],
                         mid = RColorBrewer::brewer.pal(7, "PuOr")[4],
                         high = RColorBrewer::brewer.pal(7, "PuOr")[7],
                         midpoint = 0, 
                         na.value = "#00000000")+
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0), legend.position = "")+
    labs(x = "", y = "")
})

cowplot::plot_grid(plotlist = tea_plt_list, labels = letters)
```

![](../plots/BaselineTEA.png)
![](../plots/CompensatedTEA.png)
![](../plots/DelayedTEA.png)

ecdfs
```{r}
tea_cor_list <- map(seq_along(no_outlier_tea_list), function(i){
  for_corr <- no_outlier_tea_list[[i]][, c(MeasuredKCurrents, MeasuredmRNA)]
  
  MCorr <- cor(for_corr, use = "pairwise.complete.obs")
  
  pMat <- cor_pmat(for_corr)
  
  MCorr <- as.data.frame(MCorr) 
  MCorr$row_names <- rownames(MCorr)
  MCorr <- MCorr %>% gather(col_names, Corr, names(MCorr)[names(MCorr) != "row_names"])
  
  pMat <- as.data.frame(pMat) 
  pMat$row_names <- rownames(pMat)
  pMat <- pMat %>% gather(col_names, p, names(pMat)[names(pMat) != "row_names"])
  
  return(list(Corr = MCorr, pValue = pMat))
})


temp1 <- tea_cor_list[[1]]$Corr
temp2 <- tea_cor_list[[2]]$Corr
temp3 <- tea_cor_list[[3]]$Corr

temp1$group <- "Baseline"
temp2$group <- "Compensated"
temp3$group <- "Delayed"

# plot_ecdf_ks(
#   df = rbind(temp1, temp2),
#   data.col = "Corr",
#   group.col = "group",
#   group1 = "Baseline",
#   group2 = "Compensated",
#   colors = c("#4d4d4d",
#              #"#67a9cf",
#              "#1c9099"))




ecdf_corr_list <- 
map(list(
  list(
    rbind(temp1, temp2),
    c("Baseline", "Compensated"),
    c("#4d4d4d", 
      "#67a9cf"#, 
      #"#1c9099"
      )
  ),
  list(
    rbind(temp1, temp3),
    c("Baseline", "Delayed"),
    c("#4d4d4d", 
      #"#67a9cf", 
      "#1c9099")
  ),
  list(
    rbind(temp2, temp3),
    c("Compensated", "Delayed"),
    c(#"#4d4d4d", 
      "#67a9cf",
      "#1c9099")
  )
), function(list.obj){
  plot_ecdf_ks(
  df = list.obj[[1]],
  data.col = "Corr",
  group.col = "group",
  group1 = list.obj[[2]][1],
  group2 = list.obj[[2]][2],
  colors = list.obj[[3]])
})

cowplot::plot_grid(plotlist = ecdf_corr_list)
```

What does this look like without the currents?
```{r}
temp1_nocurrents <- temp1[!((temp1$row_names %in% MeasuredKCurrents) | (temp1$col_names %in% MeasuredKCurrents)), ]
temp2_nocurrents <- temp2[!((temp2$row_names %in% MeasuredKCurrents) | (temp2$col_names %in% MeasuredKCurrents)), ]
temp3_nocurrents <- temp3[!((temp3$row_names %in% MeasuredKCurrents) | (temp3$col_names %in% MeasuredKCurrents)), ]


ecdf_corr_nocurrents_list <- 
map(list(
  list(
    rbind(temp1_nocurrents, temp2_nocurrents),
    c("Baseline", "Compensated"),
    c("#4d4d4d", 
      "#67a9cf"#, 
      #"#1c9099"
      )
  ),
  list(
    rbind(temp1_nocurrents, temp3_nocurrents),
    c("Baseline", "Delayed"),
    c("#4d4d4d", 
      #"#67a9cf", 
      "#1c9099")
  ),
  list(
    rbind(temp2_nocurrents, temp3_nocurrents),
    c("Compensated", "Delayed"),
    c(#"#4d4d4d", 
      "#67a9cf",
      "#1c9099")
  )
), function(list.obj){
  plot_ecdf_ks(
  df = list.obj[[1]],
  data.col = "Corr",
  group.col = "group",
  group1 = list.obj[[2]][1],
  group2 = list.obj[[2]][2],
  colors = list.obj[[3]])
})

cowplot::plot_grid(plotlist = ecdf_corr_nocurrents_list)
```


Combined fig corr/ecdf
```{r}
temp_list <- tea_plt_list

temp_list[[4]] <- ecdf_corr_list[[1]]
temp_list[[5]] <- ecdf_corr_list[[2]]
temp_list[[6]] <- ecdf_corr_list[[3]]


cowplot::plot_grid(plotlist = temp_list)
#TODO how much of the difference in KS between compensated and baseline is noise? I guess we have to cut out the currents and redo it to figure out...
```

Contrast ecdfs with and without currents.
```{r}
temp_list2 <- ecdf_corr_list

temp_list2[[4]] <- ecdf_corr_nocurrents_list[[1]]
temp_list2[[5]] <- ecdf_corr_nocurrents_list[[2]]
temp_list2[[6]] <- ecdf_corr_nocurrents_list[[3]]

cowplot::plot_grid(plotlist = temp_list2)
```

How do they separate? cluster?


```{r}

no_outlier_tea_df <- do.call(rbind, no_outlier_tea_list)

# require at least X of observations to contain data in a column to be allowed.
require_complete_rate <- 0.4

skim_df <- skimr::skim(no_outlier_tea_df)
retain_cols <- skim_df[skim_df$complete_rate > require_complete_rate, "skim_variable"] %>% unlist()

no_outlier_tea_df <- no_outlier_tea_df[, retain_cols]

library(imputeMissings)
no_outlier_tea_df <- imputeMissings::impute(no_outlier_tea_df, method = "median/mode")

rownames(no_outlier_tea_df) <- paste(no_outlier_tea_df$Experiment, no_outlier_tea_df$Cell, no_outlier_tea_df$Time, sep = "-")
```

dendrogram 
```{r}
library(pvclust)
library(ggdendro)
set.seed(654684)
cluster <- pvclust(t(no_outlier_tea_df[, c(MeasuredKCurrents, MeasuredmRNA)]),
                   method.hclust = "ward.D2",
                   method.dist = "correlation",
                   use.cor = "pairwise.complete.obs")
```


dendrogram plot method 1
```{r}
library(dendextend)
cluster %>% 
  as.dendrogram() %>% 
  set("branches_k_color", k = 3, value = RColorBrewer::brewer.pal(3, "Set1")) %>%
  plot()

# plot(cluster, hang = -1, main = "Cluster dendogram with AU/BP values (%) Raw Data")
```

dendrogram plot method 2
```{r}
plt <- ggdendro::ggdendrogram(cluster$hclust)

cluster_dend <- ggdendro::dendro_data(as.dendrogram(cluster$hclust), type = "rectangle")
cluster_dend_segments <- ggdendro::segment(cluster_dend)


label_df <- data.frame(labels = no_outlier_tea_df[, "Time"],
                       exps = no_outlier_tea_df[, "Experiment"])
label_df$orderby <- as.numeric(as.character(ggdendro::label(cluster_dend)$label))
label_df <- arrange(label_df, orderby)


# cluster_dend_labs <- data.frame(ggdendro::label(cluster_dend), Time = as.factor(no_outlier_tea_df[match(label(no_outlier_tea_df)$label, rownames(no_outlier_tea_df)), "Time"]))

ggplot()+
  geom_segment(data = cluster_dend_segments,
               aes(x = x, y = y, xend = xend, yend = yend),
               size = 1.25,
               colour = "black",
               lineend = "round")+ 
  geom_text(data = data.frame(ggdendro::label(cluster_dend),
                              Time = label_df$labels,
                              exps = label_df$exps), 
            aes(x = x, y = y, label = exps, colour = Time), 
            nudge_y = 0, family = "boldserif", size = 5, angle = 90, hjust = 1)+ 
  xlab("")+ 
  ylab("Height")+
  lims(y = c(-0.1, 0.8))+
  theme(axis.line.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        text = element_text(family = "serif"),
        legend.position = "bottom")
```


have dendrogram on both sides
```{r}
cluster_2 <- pvclust(no_outlier_tea_df[, c(MeasuredKCurrents, MeasuredmRNA)],
                   method.hclust = "ward.D2",
                   method.dist = "correlation",
                   use.cor = "pairwise.complete.obs")

mrna_cluster_dend <- as.dendrogram(cluster)
cell_cluster_dend <- as.dendrogram(cluster_2)


mrna_cutree <- cutree(mrna_cluster_dend, k = 5)
cell_cutree <- cutree(cell_cluster_dend, k = 4)


library(RColorBrewer)
mypalette <- rev(brewer.pal(9, "PuOr")[-1])


matrix_for_heatmap <- as.matrix(no_outlier_tea_df[, c(MeasuredKCurrents, MeasuredmRNA)])

# Reference
# https://rpubs.com/Sammi/132435
heatmap(
matrix_for_heatmap,
Rowv = mrna_cluster_dend,
Colv = cell_cluster_dend,

RowSideColors = as.character(mrna_cutree),
ColSideColors = as.character(cell_cutree),
# scale = "col"

key = T, 
col = mypalette
)


library(gplots)
heatmap.2(
matrix_for_heatmap,
Rowv = mrna_cluster_dend,
Colv = cell_cluster_dend,

RowSideColors = as.character(mrna_cutree),
ColSideColors = as.character(cell_cutree),
# scale = "col"

trace = "none",
key = T
# col = mypalette
)


# source("http://faculty.ucr.edu/~tgirke/Documents/R_BioCond/My_R_Scripts/my.colorFct.R")
# heatmap(y, 
#         Rowv = as.dendrogram(hr), 
#         Colv = as.dendrogram(hc), 
#         col=my.colorFct(), 
#         scale="row")
```


Evaluating clustering quality
```{r}
# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install("BiocGenerics")
library(BiocGenerics)
library(imputeMissings)
library(magrittr) # for %>% (this is part of tidyverse)
library(clues)
library(NMF)

## Evaluate clustering performance ==========================================
get_cluster_comparisons <- function(reference.clustering = mrna_raw$Cell,
                                    generated.clustering) {
  if (length(reference.clustering) != length(generated.clustering)) {
    warning("Input vectors are not of the same length!")
  } else {
    # reference.clustering = mrna_raw$Cell
    # generated.clustering = kmeans.m$cluster
    output <- array(0, dim = 6)
    reference.clustering <- as.numeric(reference.clustering) %>% as.factor()
    generated.clustering <- as.numeric(generated.clustering) %>% as.factor()
    output <- NMF::purity(reference.clustering, generated.clustering)
    names(output) <- "Purity"
    # Get a lot of concurrance measures
    # https://davetang.org/muse/2017/09/21/adjusted-rand-index/
    output <- c(
      output,
      clues::adjustedRand(
        BiocGenerics::as.vector(reference.clustering),
        BiocGenerics::as.vector(generated.clustering)
      )
    )
    return(output)
  }
}
```


```{r}
temp.clust <- as.dendrogram(cluster$hclust)
assignment <- cutree(temp.clust, k = 3)[order.dendrogram(temp.clust)]

# use names to get groupings
time_groups <- as.factor(unlist(transpose(stringr::str_split(names(assignment), pattern = "-"))[[3]]))

library(purrr)
set.seed(9348957)
resample.indices <- map(1:10001, function(i){
  if (i == 1){
    indices <- get_cluster_comparisons(reference.clustering = time_groups,
                                       assignment)
  }else{
    indices <- get_cluster_comparisons(reference.clustering = time_groups,
                                       sample(assignment, replace = F))
  }
})
resample.indices <- do.call(rbind, resample.indices)
resample.indices <- resample.indices %>% as.data.frame()

library(ggplot2)
resample.indices %>% 
  ggplot(aes(x = Jaccard))+
  geom_density()+
  geom_vline(xintercept = as.numeric(resample.indices[1, "Jaccard"]))+
  xlim(0,1)+
  theme_minimal()
# empirical p-value from 10,000 random samplings
mean(resample.indices$Jaccard >= resample.indices[1, "Jaccard"])
```



pca 
```{r}
library(factoextra)
library(FactoMineR) #PCA
library(car)
# library(cowplot)
library(patchwork)


mk_pca_multi_plt <- function(input.df = t_pass,
                             scree.max.y = 100){
  
  res.pca <- PCA(input.df,  graph = FALSE)
  # Extract eigenvalues/variances
  # get_eig(res.pca)
  
  # Visualize eigenvalues/variances
  p0 <- fviz_screeplot(res.pca, addlabels = TRUE, ylim = c(0, scree.max.y))
  
  p1 <- fviz_contrib(res.pca, choice = "var", axes = 1, top = 20)
  p2 <- fviz_contrib(res.pca, choice = "var", axes = 2, top = 20)
  p3 <- fviz_contrib(res.pca, choice = "var", axes = 3, top = 20)
  
  # Control variable colors using their contributions
  p4 <- fviz_pca_var(res.pca, col.var="contrib",
                     gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
                     repel = TRUE # Avoid text overlapping
  )
  
  # pca.multi <- {p4|p0}/{p1+p2+p3}
  # return(pca.multi)
  return(list(scree = p0, 
              cont1 = p1, 
              cont2 = p2, 
              cont3 = p3, 
              biplt = p4))
}

pca_summary_descriptions <- map(list(
  no_outlier_tea_df[no_outlier_tea_df$Time == "Baseline", c(MeasuredKCurrents, MeasuredmRNA)],
  no_outlier_tea_df[no_outlier_tea_df$Time == "Compensated", c(MeasuredKCurrents, MeasuredmRNA)],
  no_outlier_tea_df[no_outlier_tea_df$Time == "Delayed", c(MeasuredKCurrents, MeasuredmRNA)]
  
), function(df){
  mk_pca_multi_plt(input.df = df,
                 scree.max.y = 100)
})


# {p4|p0}/{p1+p2+p3}

{pca_summary_descriptions[[1]]$scree | pca_summary_descriptions[[2]]$scree | pca_summary_descriptions[[3]]$scree}

{pca_summary_descriptions[[1]]$cont1 | pca_summary_descriptions[[2]]$cont1 | pca_summary_descriptions[[3]]$cont1}

{pca_summary_descriptions[[1]]$biplt | pca_summary_descriptions[[2]]$biplt | pca_summary_descriptions[[3]]$biplt}

```


```{r}
library(rgl)


vis_pca_3D <- function(input.df = dplyr::filter(M, pass == T) %>% dplyr::select(-lc, -net, -pass),
                       color.by = M[M$pass == T, "lc"],
                       turn.x.times = 2,
           use.colors = RColorBrewer::brewer.pal(8, "Set1")){
  
  res.pca <- PCA(input.df,  graph = FALSE)
  
  indivduals <- get_pca_ind(res.pca)
  indivduals <- as.data.frame(indivduals$coord)
  indivduals$cell.num <- as.factor(as.character(color.by))
  
  car::scatter3d(x = indivduals$Dim.1,
                 z = indivduals$Dim.3,
                 y = indivduals$Dim.2,
                 groups = indivduals$cell.num,
                 
                 
                 
                 surface=F, 
                 # fit = "smooth",
                 # surface.alpha = 0.5,
                 grid = F,
                 # residuals = F,
                 bg.col = "white", # white black
                 surface.col = use.colors, 
                 point.col = use.colors,                 
                 
                 xlab = "Dim. 1",
                 ylab = "Dim. 2",
                 zlab = "Dim. 3",
                 revolutions=turn.x.times, 
                 # revolutions = 1,
                 
                 # surface = F,
                 ellipsoid = TRUE
  )
}



vis_pca_3D(input.df = no_outlier_tea_df[, c(MeasuredKCurrents, MeasuredmRNA)],
           color.by = no_outlier_tea_df[, "Time"],
           turn.x.times = 1,
           use.colors = RColorBrewer::brewer.pal(3, "Set1")
)


```

Is the overlap in "compensated" due to k currents? (no)
```{r}
vis_pca_3D(input.df = no_outlier_tea_df[, c(MeasuredmRNA)],
           color.by = no_outlier_tea_df[, "Time"],
           turn.x.times = 1,
           use.colors = RColorBrewer::brewer.pal(3, "Set1")
)
```

### specifically

```{r}

```






# Secondary Questions
```{r}
scatter_w_wo_outliers(temp = distinct(select(filter(M_all, Time == "Baseline"), shal, Ia.0)), 
                  X = "shal", 
                  Y = "Ia.0")

scatter_w_wo_outliers(temp = distinct(select(filter(M_all, Time == "Compensated"), shal, Ia.0)), 
                  X = "shal", 
                  Y = "Ia.0")

scatter_w_wo_outliers(temp = distinct(select(filter(M_all, Time == "Delayed"), shal, Ia.0)), 
                  X = "shal", 
                  Y = "Ia.0")

```


                       
                       
```{r reference}
# ref ----
# c(
#   ## Ion Channels ====
#   #Kv
#   "Shab", "Shaker", "Shal", "Shaw1", "Shaw2",
#   "KCNQ1", "KCNQ2", 
#   "KCNH1", "KCNH2", "KCNH3",
#   #K
#   "BKKCa", "SKKCa", 
#   "KCNT1", "IRK", "KCNK1", "KCNK2", 
#   #Ca
#   "CaV1", "CaV2", "CaV3", 
#   #Na
#   "CbNaV", 
#   "NALCN", 
#   #Hyp/CyclNuc Activated/Gated
#   "IH", 
#   ## CNGs
#   
#   #TRPs
#   "TRP-A1", "TRP-A-like", "TRP-M1", "TRP-M3", "TRP-M-like", 
#   ##-V5, -V6, -Pyrexia
#   
#   
#   #Biogenic amine activated
#   "HisCL", 
#   
#   ## Receptors Biogenic Amines ====
#   #octopamine
#   
#   #dopamine
#   "DAR1A", "DAR2",  "Dopa-1Br",
#   #serotonin
#   "HTR1A", "HTR2", "HTR7", "5HTr-1Br",  
#   
#   #histamine
#   "His-1r", "His-2r", "His-3r", 
#   #gaba
#   "GABAB-R1",
#   "LCCH3r",
#   "RDLr", 
#   "mGABA2", "mGABA3", 
#   
#   ## Receptors Glutamate/Acetylcholine ====
#   #metabotropic glutamate receptors
#   "mGluR1", "mGluR2", "mGluR4", "mGluR5", "mGluR7",
#   #kainate-like receptors
#   "Kainate-1A", "Kainate-1B", "Kainate-2A", "Kainate-2B", "Kainate-2C",
#   #NMDA-like receptors
#   "NMDA-1A", "NMDA-1B", "NMDA-2A", "NMDA-2B", "NMDA-2-like", 
#   #glutamate-gated chloride channel
#   "GluCl",
#   #acetylcholine receptors
#   "mACHrA", "mACHrB", 
#   
#   # Crustacean cardioactive peptide receptor ===
#   "CCAPr", 
#   
#   #Acetylcholinesterase
#   "ACHE", 
#   # Actylcholine catalyst
#   "ChAT", 
#   
#   #vesicular ach transporter
#   "vAChT", 
#   #vesicular glut transporter
#   "vGluT", 
#   
#   ## Innexins ====
#   "INX1", "INX2", "INX3", "INX4", "INX5"
# )
```




```{r}
load(here("data", "ionic.rds"))
load(here("data", "tevc.rds"))
load(here("data", "tecc.rds"))
load(here("data", "mrna.rds"))

mRNAInfo <- readxl::read_excel(here("inst", "extdata", "mRNAInfo.xlsx")) # tables from Northcutt 2016 and annotations
```

# ionic ~ mrna?

## Make a joint dataset
```{r}
M <- left_join(ionic, mrna)

M <- M[!is.na(M$x18s), ]

MeasuredmRNA <- names(mrna)[!(names(mrna) %in% c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell"))]

# temp.plts <- map(seq_along(MeasuredmRNA), function(i){
#   ggplot(M, aes_string(MeasuredmRNA[i], y = "Ihtk.0", color = "Time"))+
#   geom_smooth(method = "lm", se = F)+
#   geom_point()
# })
# 
# cowplot::plot_grid(plotlist = temp.plts)
# 
# mrna
```

## Clean up data cols
```{r}
PercentNotNA <- map(MeasuredmRNA, function(i){
  mean(!is.na(M[[i]]))
}) %>% unlist()

ThresholdPercentNotNA <- 0.6
MeasuredmRNA <- MeasuredmRNA[PercentNotNA >= ThresholdPercentNotNA] # use in map call
MeasuredKCurrents <- c("Ihtk.0", "Ihtk.Slope", "Ia.0", "Ia.Slope") # use in map call
```

## How well does this work for currents we know something about?
Ia ~ shal
```{r}
# TEXTING WITH DAVE
scatter_w_wo_outliers(temp = filter(M, Time == "Baseline"), 
                  X = "shal", 
                  Y = "Ia.0")

# broom::tidy(lm(Ia.0 ~ shal, temp))
# broom::tidy(lm(Ia.0 ~ shal, temp[temp$flag, ]))
```


```{r eval=FALSE, include=FALSE}
library(brms)
# Loading required package: StanHeaders
# rstan (Version 2.19.3, GitRev: 2e1f913d3ca3)
# For execution on a local, multicore CPU with excess RAM we recommend calling
options(mc.cores = parallel::detectCores())
# To avoid recompilation of unchanged Stan programs, we recommend calling
rstan_options(auto_write = TRUE)
# For improved execution time, we recommend calling
Sys.setenv(LOCAL_CPPFLAGS = '-march=corei7 -mtune=corei7')
# although this causes Stan to throw an error on a few processors.


temp <- temp[!is.na(temp$Ia.0), ]

tic <- Sys.time()
fm1 <- lm(Ia.0 ~ shal, temp)
toc1 <- Sys.time() - tic

tic <- Sys.time()
fm2 <- brm(Ia.0 ~ shal, data  = temp, family = gaussian())
toc2 <- Sys.time() - tic

tic <- Sys.time()
fm3 <- brm(Ia.0 ~ shal, data  = temp, family = student())
toc3 <- Sys.time() - tic



toc1
toc2
toc3

t1 <- broom::tidy(fm1)
t2 <- broom::tidy(fm2)
t3 <- broom::tidy(fm3)



bayes_ex1 <- 
ggplot(temp, aes(x = shal, y = Ia.0))+
  geom_point()+
  geom_abline(slope = as.numeric(t1[2, "estimate"]), intercept = as.numeric(t1[1, "estimate"]), size = 1, color = "gray")+
  geom_abline(slope = as.numeric(t2[2, "estimate"]), intercept = as.numeric(t2[1, "estimate"]), size = 1, color = "cornflowerblue")+
  geom_abline(slope = as.numeric(t3[2, "estimate"]), intercept = as.numeric(t3[1, "estimate"]), size = 1, color = "firebrick")+
  theme_bw()
```



Ia ~ shaker
```{r}
scatter_w_wo_outliers(temp = filter(M, Time == "Baseline"), 
                  X = "shaker", 
                  Y = "Ia.0")
```


Model comparison *shal best predicts Ia*
```{r}
temp <- filter(M, Time == "Baseline") 
# What's the best model?
library(AICcmodavg)
# no rm points
aictab(cand.set = list(
  lm(Ia.0 ~ shal, temp),
  lm(Ia.0 ~ shaker, temp),
  lm(Ia.0 ~ shal+shaker, temp),
  lm(Ia.0 ~ shal*shaker, temp)
))

# rm points
temp_no_outliers <- temp %>% 
  mutate(shal = ifelse(win_x_iqr(shal), shal, NA)) %>% 
  mutate(shaker = ifelse(win_x_iqr(shaker), shaker, NA)) %>% 
  mutate(Ia.0 = ifelse(win_x_iqr(Ia.0), Ia.0, NA))


aictab(cand.set = list(
  lm(Ia.0 ~ shal, temp_no_outliers),
  lm(Ia.0 ~ shaker, temp_no_outliers),
  lm(Ia.0 ~ shal+shaker, temp_no_outliers),
  lm(Ia.0 ~ shal*shaker, temp_no_outliers)
))
```




IHTK ~ bkkca
```{r}
scatter_w_wo_outliers(temp = filter(M, Time == "Baseline"), 
                  X = "bkkca", 
                  Y = "Ihtk.0")
```





How might we exclude outliers? Cooks Distance? Iterated Cooks?
```{r eval=FALSE, include=FALSE}
temp <- filter(M, Time == "Baseline") %>%
  mutate(flag = ifelse(bkkca < 3000, T, F))

fm <- lm(Ihtk.0 ~ bkkca, temp)

temp$cooksd <- cooks.distance(fm)

ggplot(temp, aes_string("bkkca", "Ihtk.0", color = "flag"))+
  geom_smooth(method = lm, se = F, color = "gray")+
  geom_smooth(data = temp[temp$flag == T, ], method = lm, se = F, fullrange = T)+
  geom_point(aes(color = cooksd < (mean(cooks.distance(fm))*2.2) ))+
  scale_color_manual(values = c("gray", "black"))+
  theme_bw()+
  theme(legend.position = "")

# broom::tidy(lm(Ihtk.0 ~ bkkca, temp))
# broom::tidy(lm(Ihtk.0 ~ bkkca, temp[temp$flag, ]))
broom::tidy(lm(Ihtk.0 ~ bkkca, temp[temp$cooksd < (mean(cooks.distance(fm))*4) , ]))
# temp %>% filter(flag == F)

```

Checking the use of iterated Cook's distance 
Using cooks is going to be challenging. It'll be hard to choose a stopping criteria as 
```{r eval=FALSE, include=FALSE}
flag_cooks_outliers <- function(
  df = filter(M, Time == "Baseline"),
  mod = "Ihtk.0 ~ bkkca",
  multiplier = 4,
  center = "mean"){
  
  fm <- lm(as.formula(mod), df)
  
  cd <- cooks.distance(fm)
  
  if (center == "mean"){
    cd_outlier <- cd > mean(cd)*multiplier 
  } else if (center == "median") {
    cd_outlier <- cd > median(cd)*multiplier 
  } else {
    warning("center must be mean or median")
  }
  
  return(cd_outlier)
}

# run 10 iterations of cooks distance. When a cell is identified as an outlier, drop it and note when it was deamed an outlier

temp <- M %>% dplyr::select(Ihtk.0, bkkca, Time) %>% filter(Time == "Baseline")
temp$dropout <- NA

for (i in 1:10){
  current_outliers <- flag_cooks_outliers(df = temp[is.na(temp$dropout), ],
                    mod = "Ihtk.0 ~ bkkca",
                    multiplier = 4,
                    center = "mean")
  
  temp[is.na(temp$dropout), ][current_outliers, "dropout"] <- i
  
}

ggplot(temp, aes(x = bkkca, y = Ihtk.0, color = as.factor(dropout)))+
  geom_point()

bkkca_cook_outliers <- temp$dropout
temp %>% group_by(dropout) %>% tally()
# # A tibble: 5 x 2
#   dropout     n
#     <int> <int>
# 1       1     1
# 2       2     1
# 3       3     1
# 4       4     1
# 5      NA    12





temp <- M  %>% filter(Time == "Baseline")
temp$dropout <- NA
for (i in 1:10){
  current_outliers <- flag_cooks_outliers(df = temp[is.na(temp$dropout), ],
                    mod = "Ia.0 ~ shal",
                    multiplier = 4,
                    center = "mean")
  temp[is.na(temp$dropout), ][current_outliers, "dropout"] <- i
}

temp %>% group_by(dropout) %>% tally()


temp <- M  %>% filter(Time == "Baseline")
temp$dropout <- NA
for (i in 1:10){
  current_outliers <- flag_cooks_outliers(df = temp[is.na(temp$dropout), ],
                    mod = "Ia.0 ~ shaker",
                    multiplier = 4,
                    center = "mean")
  temp[is.na(temp$dropout), ][current_outliers, "dropout"] <- i
}

temp %>% group_by(dropout) %>% tally()
```

contrast cooks with a fit t distribution.
```{r eval=FALSE, include=FALSE}
# temp <- filter(M, Time == "Baseline")
# 
# tic <- Sys.time()
# fm0 <- lm(Ihtk.0 ~ bkkca, temp[temp$bkkca < 3000, ])
# toc1 <- Sys.time() - tic
# 
# tic <- Sys.time()
# fm1 <- lm(Ihtk.0 ~ bkkca, temp)
# toc1 <- Sys.time() - tic
# 
# tic <- Sys.time()
# fm2 <- brm(Ihtk.0 ~ bkkca, data  = temp, family = gaussian())
# toc2 <- Sys.time() - tic
# 
# tic <- Sys.time()
# fm3 <- brm(Ihtk.0 ~ bkkca, data  = temp, family = student())
# toc3 <- Sys.time() - tic
# 
# 
# 
# toc1
# toc2
# toc3
# 
# t0 <- broom::tidy(fm0)
# t1 <- broom::tidy(fm1)
# t2 <- broom::tidy(fm2)
# t3 <- broom::tidy(fm3)
# 
# 
# temp$dropout <- bkkca_cook_outliers
# # temp[is.na(temp$dropout), "dropout"] <- 11
# 
# alpha_param <-  0.8
# # bayes_ex1 <- 
# ggplot(temp, aes(x = bkkca, y = Ihtk.0, color = as.factor(dropout)))+
#   
#   geom_abline(slope = as.numeric(t0[2, "estimate"]), intercept = as.numeric(t0[1, "estimate"]), size = 1, alpha = alpha_param, color = "black")+
#   geom_abline(slope = as.numeric(t1[2, "estimate"]), intercept = as.numeric(t1[1, "estimate"]), size = 1, alpha = alpha_param, color = "black")+
#   geom_abline(slope = as.numeric(t2[2, "estimate"]), intercept = as.numeric(t2[1, "estimate"]), size = 1, alpha = alpha_param, color = "cornflowerblue")+
#   geom_abline(slope = as.numeric(t3[2, "estimate"]), intercept = as.numeric(t3[1, "estimate"]), size = 1, alpha = alpha_param, color = "firebrick")+
#   
#   geom_point(size = 2, color = "white")+
#   geom_point(size = 2)+
#   geom_point(size = 2, color = "black", shape = 1)+
#   
#   theme_bw()+
#   theme(legend.position = "bottom")+
#   scale_color_brewer(type = "div", palette = "PuOr")




```



IHTK ~ skkca
```{r}
scatter_w_wo_outliers(temp = filter(M, Time == "Baseline"), 
                  X = "skkca", 
                  Y = "Ihtk.0")
```


How do K channels predict IKv intercepts?
```{r}
# TODO redo this using the info in mRNAInfo 
# TODO use next block as inspiration.

# filter(M, Time == "Baseline") %>% 
#   select(Ihtk.0, Ihtk.Slope, Ia.0, Ia.Slope, 
#          #Kv
#          shab, shaker, shal, shaw1, shaw2,
#          kcnq1, kcnq2,
#          kcnh1, kcnh2, kcnh3,
#          #k
#          bkkca, skkca,
#          kcnt1, irk, kcnk1, kcnk2
#   ) %>% 
#   pivot_longer(cols = c(
#     #kv
#     "shab", "shaker", "shal", "shaw1", "shaw2", 
#     "kcnq1", "kcnq2",
#     "kcnh1", "kcnh2", "kcnh3", 
#     #k
#     "bkkca", "skkca", 
#     "kcnt1", "irk", "kcnk1", "kcnk2"
#   ), names_to = "mRNA", values_to = "Count") %>% 
#   pivot_longer(cols = c("Ihtk.0", 
#                         # "Ihtk.Slope", 
#                         "Ia.0"#, 
#                         # "Ia.Slope"
#                         ),
#                names_to = "Key", values_to = "Value") %>% 
#   ggplot(aes(x = Count, y = Value))+
#   geom_smooth(method = lm, se = F)+
#   geom_point()+
#   # facet_wrap(Key ~ mRNA, nrow = 4, scales = "free")
#   facet_grid(Key ~ mRNA)+
#   theme_bw()
#   
# 
# PlotList <- 
# map(c(
#   #Kv
#   "Shab", "Shaker", "Shal", "Shaw1", "Shaw2", 
#   "Kcnq1", "Kcnq2",
#   "Kcnh1", "Kcnh2", "Kcnh3", 
#   #K
#   "BkkCa", "SkkCa", 
#   "Kcnt1", "Irk", "Kcnk1", "Kcnk2"
# ), function(X){
#   map(c("Ihtk.0", 
#         # "Ihtk.Slope", 
#         "Ia.0"#, 
#         # "Ia.Slope"
#   ), function(Y){
#     ggplot(filter(M, Time == "Baseline"), aes_string(X, Y))+
#       geom_smooth(method = lm, se = F)+
#       geom_point()+
#       theme_bw()
#   })
# })
#   
# PlotList <- transpose(PlotList)  
# 
# library(cowplot)
# cowplot::plot_grid(plotlist = PlotList[[1]])
# 
# cowplot::plot_grid(plotlist = PlotList[[2]])
```





## Linear models -- what predicts ionics?
This falls under the auspices of EDA. 
```{r}
KCurrent = "Ihtk.0"
mRNA = "BkkCa"

# Make outlier free version of the baseline data

M_baseline_outlier_free <- filter(M, Time == "Baseline")

for (NAME in names(M)[!(names(M) %in% c("Condition" , "Cell", "Experiment", "Source", "Pharm", "Time", "Sample"))]){
  M_baseline_outlier_free[[NAME]] <- ifelse(win_x_iqr(M_baseline_outlier_free[[NAME]]), M_baseline_outlier_free[[NAME]], NA)
}



# Which have relationships at baseline?
fm.list <- map(MeasuredKCurrents, function(KCurrent){
  map(MeasuredmRNA, function(mRNA){
    lm(as.formula(paste0(KCurrent, " ~ ", mRNA)), data = M_baseline_outlier_free)
  })
})


p.list <- map(fm.list, function(ListLvl1){
  map(ListLvl1, function(ListLvl2){
    broom::tidy(ListLvl2)[2, "p.value"] # non-intercept p
  }) %>% unlist()
})

p.df <- do.call(cbind, p.list) %>% as.data.frame()

names(p.df) <- MeasuredKCurrents
p.df$mRNA <- MeasuredmRNA





# Uncorrected
p.df.long <- p.df %>% 
  gather(iK, pValue, all_of(MeasuredKCurrents))
  # dplyr::filter(iK %in% c("Ia.0", "Ihtk.0")) %>% 
  # mutate(pAdj = p.adjust(pValue, method = "fdr")) %>% 
  
highlight.text.temp.df <- p.df.long %>% 
  mutate(highlight = ifelse(pValue <= 0.05, 1, 0)) %>% 
  select(-pValue) %>% pivot_wider(names_from = iK, values_from = highlight) %>% 
  mutate(highlight = ifelse(Ihtk.0 == 0, 
                     ifelse(Ihtk.Slope == 0,
                     ifelse(Ia.0 == 0, 
                     ifelse(Ia.Slope == 0, 
                            0, 1), 1), 1), 1) ) %>% 
  mutate(highlight = ifelse(highlight == 1, "firebrick", "black")) %>% 
  arrange(mRNA)

plt.fm <-   
p.df.long %>% 
  ggplot(aes(x = mRNA, color = pValue <= 0.05))+
  geom_hline(yintercept = 0.95, color = "gray", linetype = "dashed")+
  # geom_point()+
  # geom_rect(aes(xmin = mRNA, xmax = mRNA, ymin = 0, ymax = 1- pValue), size = 2, color = "gray", alpha = 0.0001)+
  geom_rect(aes(xmin = mRNA, xmax = mRNA, ymin = 0, ymax = 1- pValue), size = 2)+
  
  # geom_segment(aes(x = mRNA, xend = mRNA, y = 0, yend = 1- pValue), size = 2)+
  # geom_segment(aes(x = mRNA, xend = mRNA, y = 0, yend = 1- pAdj), size = 2)+
  facet_grid(iK~.)+
  scale_color_manual(values = c("black", "firebrick"))+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, color = highlight.text.temp.df[["highlight"]]),
        legend.position = "")

# Corrected with fdr
plt.fm.fdr <- 
p.df %>% 
  gather(iK, pValue, all_of(MeasuredKCurrents)) %>% 
  # dplyr::filter(iK %in% c("Ia.0", "Ihtk.0")) %>% 
  mutate(pAdj = p.adjust(pValue, method = "fdr")) %>% 
  ggplot(aes(x = mRNA, color = pAdj <= 0.05))+
  geom_hline(yintercept = 0.95, color = "gray", linetype = "dashed")+
  # geom_point()+
  geom_rect(aes(xmin = mRNA, xmax = mRNA, ymin = 0, ymax = 1- pValue), size = 2, color = "gray", alpha = 0.0001)+
  geom_rect(aes(xmin = mRNA, xmax = mRNA, ymin = 0, ymax = 1- pAdj), size = 2, color = "black")+
  
  # geom_segment(aes(x = mRNA, xend = mRNA, y = 0, yend = 1- pValue), size = 2)+
  # geom_segment(aes(x = mRNA, xend = mRNA, y = 0, yend = 1- pAdj), size = 2)+
  facet_grid(iK~.)+
  scale_color_manual(values = c("black", "firebrick"))+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
        legend.position = "")
```

## PCA what loads with ionics?
```{r}
library(factoextra)
# library(missMDA) # for imputePCA 
library("FactoMineR") #PCA

MNumericOnly <- M_baseline_outlier_free
MNumericOnly <- MNumericOnly[, c(MeasuredKCurrents, MeasuredmRNA)]

ResPCA <- PCA(MNumericOnly, scale.unit = T)

get_eig(ResPCA)

fviz_screeplot(ResPCA, addlabels = T)

fviz_pca_biplot(ResPCA, repel = T)
# Ihtk.Slope, Ihtk.0, Ia.0, Ia.Slope, and Kainate1A are all loading together (roughly)

fviz_pca_var(ResPCA, 
             col.var = "contrib",
             # gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping
             )
```

## What correlates with ionics?
```{r}
library(corrr)

MCorrr <- MNumericOnly %>% 
  correlate()

temp <- MCorrr %>% 
  as_tibble() %>% 
  select(rowname, Ihtk.0, Ihtk.Slope, Ia.0, Ia.Slope) %>% 
  gather(colname, Cor, c("Ihtk.0", "Ihtk.Slope", "Ia.0", "Ia.Slope")) 

# temp$rowname <- as.factor(temp$rowname) 
#TODO fix ordering


temp %>% 
  ggplot(aes(rowname, Cor, color = Cor))+
  geom_segment(aes(x = rowname, xend = rowname, y = 0, yend = Cor))+
  geom_point()+
  geom_point(shape = 1, color = "black")+
  geom_hline(yintercept = 0)+
  ylim(-1,1)+
  facet_grid(colname~.)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  scale_color_gradient2(low = RColorBrewer::brewer.pal(7, "PuOr")[1],
                         mid = RColorBrewer::brewer.pal(7, "PuOr")[4],
                         high = RColorBrewer::brewer.pal(7, "PuOr")[7],
                         midpoint = 0, 
                         na.value = "#00000000")



# 
# 
# 
# # rplot(MCorrr)
# 
# # You have to zoom or the chords don't show up. \_()_/
# # network_plot(MCorrr, min_cor = .7)
# 
# 
library(ggcorrplot)
# 
MCorr <- cor(MNumericOnly, use = "pairwise.complete.obs")

pMat <- cor_pmat(MNumericOnly)
# 
library(RColorBrewer)
# ggcorrplot(MCorr, 
#            colors = RColorBrewer::brewer.pal(7, "PuOr")[c(1, 4 ,7)]#,
#            # p.mat = pMat
#            # lab = T
#            )
# 
# # library(GGally)
# # GGally::ggscatmat(MNumericOnly)
# GGally::ggcorr(MCorr,
#        # nbreaks = 5,
#        low = RColorBrewer::brewer.pal(7, "PuOr")[1],
#                          mid = RColorBrewer::brewer.pal(7, "PuOr")[4],
#                          high = RColorBrewer::brewer.pal(7, "PuOr")[7])


library(corrplot)
corrplot(MCorr, method = "square", type = "upper", tl.col = "black", order = "hclust", col = brewer.pal(n = 9, name = "PuOr"),
         p.mat = pMat,
         sig.level = 0.01, insig = "blank")
  

```







# from untitled 2



```{r}
#TODO read in ionic


```

Marginal plot
```{r}
# p <- ionic %>% filter(!is.na(Ihtk.0) & !is.na(Ia.0)) %>% 
#   ggplot(aes(Ihtk.0, Ia.0, group = Condition, color = Condition))+
#   # geom_smooth(method = "lm", se = F)+
#     geom_point(size = 2)+
#     theme_minimal()+
#   theme(legend.position = "bottom")
# 
# p <- ggExtra::ggMarginal(
#   p,
#   type = 'density',
#   margins = 'both',
#   size = 5,
#   groupColour = TRUE, groupFill = TRUE
# )
# 
# ggsave(plot = p, filename = "Ionic0M.tiff", path = here("data", "figures"))
```


```{r}
# p <- ionic %>% filter(!is.na(Ihtk.Slope) & !is.na(Ia.Slope)) %>% 
#   ggplot(aes(Ihtk.Slope, Ia.Slope, group = Condition, color = Condition))+
#   # geom_smooth(method = "lm", se = F)+
#     geom_point(size = 2)+
#     theme_minimal()+
#   theme(legend.position = "bottom")
# 
# p <- ggExtra::ggMarginal(
#   p,
#   type = 'density',
#   margins = 'both',
#   size = 5,
#   groupColour = TRUE, groupFill = TRUE
# )
# 
# ggsave(plot = p, filename = "IonicDM.tiff", path = here("data", "figures"))
```


```{r}
# cowplot::plot_grid(plotlist = 
# map(c("Ihtk.0", "Ia.0", "Ihtk.Slope", "Ia.Slope"), function(i){
#     ggplot(ionic, aes(x = Condition, group = Condition, fill = Condition))+
#   # geom_smooth(method = "lm", se = F)+
#     geom_boxplot(aes_string(y = i), width = 0.1)+
#     ggbeeswarm::geom_beeswarm(aes_string(y = i), shape = 1)+
#     # geom_point(size = 2)+
#     stat_summary(aes_string(y = i, group = "1"), fun.y = mean, geom = "line")+
#     stat_summary(aes_string(y = i, group = "1"), fun.y = mean, geom = "point", size = 4, shape = 4)+
#     theme_minimal()+
#   theme(legend.position = "")+
#   labs(x = "", y = "", title = i)
# })
# 
# )
# 
# ggsave(plot = last_plot(), filename = "IonicDelta.tiff", path = here("data", "figures"))
```


```{r}
ionic %>% 
  filter(!is.na(Cell)) %>% 
  select(-c(Ihtk.0, Ihtk.Slope)) %>%  
  distinct() %>% 
  group_by(Condition, Cell) %>% 
  tally()


ionic %>% 
  filter(!is.na(Cell)) %>% 
  select(-c(Ia.0, Ia.Slope)) %>%  
  distinct() %>% 
  group_by(Condition, Cell) %>% 
  tally()

ionic %>% 
  filter(!is.na(Cell)) %>% 
  select(-c(Ihtk.0, Ihtk.Slope)) %>%  
  distinct() %>% 
  group_by(Condition) %>% 
  tally()

ionic %>% 
  filter(!is.na(Cell)) %>% 
  select(-c(Ia.0, Ia.Slope)) %>%  
  distinct() %>% 
  group_by(Condition) %>% 
  tally()



```


### from untitled2 assumes df = brians joined data


```{r}
# # install.packages("corrr")
# library(corrr)
# 
# x <- df %>% 
#   dplyr::filter(Pharm == "tea" & Condition == "Delayed") %>% 
#   dplyr::select( -c(UID, Pharm, Condition)) %>% 
# correlate() # Create correlation data frame (cor_df)
# 
# x %>% 
#   rearrange() %>%  # rearrange by correlations
#   shave() # Shave off the upper triangle for a clean result
# 
# rplot(x)
# 
# # You have to zoom or the chord don't show up. \_()_/
# network_plot(x, min_cor = .7)
```


```{r}
# x %>% 
#   gather(mrna, cor, 2:ncol(.)) %>% 
#   ggplot(aes(rowname, mrna, fill = cor))+
#   geom_tile()+
#   scale_fill_gradient2(low = "Red", mid = "White", high = "Blue")
# 
# library("corrplot")
# 
# x <- as.data.frame(x)
# 
# rownames(x) <- x$rowname
# 
# corrplot::corrplot(
#   as.matrix(select(x, -rowname)), method = "color", order = "hclust", 
#   addrect = 3,
#   na.label = " "
#   )
# 
# # corrplot.mixed(as.matrix(select(x, -rowname)), upper = "color")
# 
# cowplot::plot_grid(plotlist = list(pp, pp))
# 
# # install.packages("ggcorrplot")
# library(ggcorrplot)
# 
# 
# 
# df <- df %>% mutate(Set = paste(Pharm, Condition))
# 
# 
# Sets <- unique(df$Set)
# 
# baseline <- df %>% filter(Set == "none Baseline") %>% select(-c(Set, Pharm, Condition, UID)) %>% correlate()
#   baseline <- as.data.frame(baseline)
#   rownames(baseline) <- baseline$rowname
#   baseline <- baseline %>% select(-rowname)
# 
# 
# cowplot::plot_grid(plotlist = 
# map(Sets, function(i){
#   temp <- df %>% filter(Set == i) %>% select(-c(Set, Pharm, Condition, UID)) %>% correlate()
#   temp <- as.data.frame(temp)
#   rownames(temp) <- temp$rowname
#   temp <- temp %>% select(-rowname)
#   
#   # temp <- temp-baseline
#   
#   ggcorrplot(temp)+labs(title = i)
# })
# )



```




##Attempts at visualizing correlations
```{r}
# treatments <- unique(M$TREATMENT)
# mrnas <- c("CAV1", "CAV2", "SHAL", "BKKCa", "CbNaV", "Shab", "Shaker", "Shaw1", "Shaw2", "INX1", "INX2", "INX3", "INX4", "INX5")
# 
# 
# cor.list <- map(treatments, function(i){
#   temp <- M[M$TREATMENT == i, ]  
#   cor(temp[, mrnas], temp[, mrnas], use = "pairwise.complete.obs", method = "spearman")
# })
# names(cor.list) <- treatments
# 
# library("corrplot")
# walk(treatments, function(i){
#   print(i)
#   corrplot(cor.list[[i]], method = "color")
# })
# 
# 
# corrplot(cor.list$`24h-CONTROL`, method = "color")
# 
# #corrplot((cor.list$`4AP24h` - cor.list$Control), method = "color")
# 
# walk(treatments[-3], function(i){
#   print(i)
# gplots::heatmap.2((cor.list[[i]] - cor.list$`TEA-Acute`),
#   cellnote = round((cor.list[[i]] - cor.list$`TEA-Acute`), digits = 2),  # same data set for cell labels
#   #main = "Correlation", # heat map title
#   notecol="black",      # change font color of cell labels to black
#   density.info="none",  # turns off density plot inside color legend
#   trace="none",         # turns off trace lines inside the heat map
#   #margins =c(12,9),     # widens margins around plot
#   #col=my_palette,       # use on color palette defined earlier
#   #breaks=col_breaks,    # enable color transition at specified limits
#   dendrogram="none",     # only draw a row dendrogram
#   Colv="NA")            # turn off column clustering
# })
# 
# library("PerformanceAnalytics")
# chart.Correlation(temp[, mrnas], histogram=TRUE, pch=19)
```


### vis with line plot?
```{r}
# N <- M[1, !(names(M) %in% c("CELL", "Pharm", "Time"))]
# N$cor <- ""
# 
# walk(1:length(cor.list), function(i){
#   temp <- as.data.frame(cor.list[[i]])
#   temp$cor <- rownames(temp)
#   temp$TREATMENT <- treatments[i]
#   N <<- full_join(N, temp) 
# })
# N <- N[-1, ]
# #N <- gather(N, )
```

```{r}
# ggplot(N, aes(x = TREATMENT, y = CAV1, color = cor, group = cor))+
#   geom_point()+
#   geom_line()
```


```{r}
# # make network plots
# library(corrplot)
# library(psych)
# library(qgraph)
# temp <- cor.list[[1]]
# 
# mk_plt <- function(use.matrix, use.name){
#   qgraph(use.matrix,
#   # minimum= 0,
#   vsize = 5,
#   # border.color="#006600",
#   title = use.name,
#   label.font = 4,
#   # edge.color="black",
#   border.width = 4,
#   esize = 7,
#   curveAll = TRUE,
#   curveDefault = 0.5,
#   curveShape = -2,
#   # color= "#006600",
#   node.width = 1.5,
#   # border.color= "black",
#   # borders=TRUE,
#   # border.color= "black",
#   # layout= "circle",
#   fade = FALSE,
#   labels = colnames(use.matrix) # , labels=TRUE
# )
# }
# 
# walk(1:length(cor.list), function(i){
#   mk_plt(cor.list[[i]], treatements[i])
# })
```


###



# Deep dive on the effects of TEA
## Electrophysiology

## Molecular bio

## Merging and processing

### Quality control and outlier analysis

### Characterizing the baseline

### 
### Compare Brian's and My molecular data




```{r}
# M <- readxl::read_excel(here("inst", "extdata", "LCTEAhr0hr1hr24.xlsx"))
# 
# M.long <- M %>% 
#   gather(mRNA, Count, 5:75)
# 
# M.long %>% 
#   ggplot(aes(mRNA, Count))+
#   geom_jitter()+
#   scale_y_log10()
# 
# 
# M.long <-
# M.long %>%
#   mutate(type =
#              ifelse(mRNA %in% c(
#                ## Ion Channels ====
#                #Kv
#                "Shab", "Shaker", "Shal", "Shaw1", "Shaw2",
#                "KCNQ1", "KCNQ2",
#                "KCNH1", "KCNH2", "KCNH3",
#                #K
#                "BKKCa", "SKKCa",
#                "KCNT1", "IRK", "KCNK1", "KCNK2",
#                #Ca
#                "CaV1", "CaV2", "CaV3",
#                #Na
#                "CbNaV",
#                "NALCN",
#                #Hyp/CyclNuc Activated/Gated
#                "IH",
#                #TRPs
#                "TRP-A1", "TRP-A-like", "TRP-M1", "TRP-M3", "TRP-M-like",
#                #Biogenic amine activated
#                "HisCL"
#              ),
#              "IonChannel",
#              ifelse(mRNA %in% c(
#                ## Receptors Biogenic Amines ====
#                #octopamine
#                #dopamine
#                "DAR1A", "DAR2",  "Dopa-1Br",
#                #serotonin
#                "HTR1A", "HTR2", "HTR7", "5HTr-1Br",
#                #histamine
#                "His-1r", "His-2r", "His-3r",
#                #gaba
#                "GABAB-R1",
#                "LCCH3r",
#                "RDLr",
#                "mGABA2", "mGABA3",
#                ## Receptors Glutamate/Acetylcholine ====
#                #metabotropic glutamate receptors
#                "mGluR1", "mGluR2", "mGluR4", "mGluR5", "mGluR7",
#                #kainate-like receptors
#                "Kainate-1A", "Kainate-1B", "Kainate-2A", "Kainate-2B", "Kainate-2C",
#                #NMDA-like receptors
#                "NMDA-1A", "NMDA-1B", "NMDA-2A", "NMDA-2B", "NMDA-2-like",
#                #glutamate-gated chloride channel
#                "GluCl",
#                #acetylcholine receptors
#                "mACHrA", "mACHrB",
#                # Crustacean cardioactive peptide receptor ===
#                "CCAPr"
#              ),
#              "Receptor",
# 
#              ifelse(mRNA %in% c(
#                ## Innexins ====
#                "INX1", "INX2", "INX3", "INX4", "INX5"
#              ),
#              "Innexin",
# 
#              ifelse(mRNA %in% c(
#                #Acetylcholinesterase
#                "ACHE",
#                # Actylcholine catalyst
#                "ChAT",
#                #vesicular ach transporter
#                "vAChT",
#                #vesicular glut transporter
#                "vGluT"
#              ),
#              "Misc",
#              NA
#              )))))
# 
# ggplot(filter(M, type != "Innexin"), aes(mRNA, Count, color = type))+
#   geom_jitter()
# 
# ggplot(filter(M, type == "Innexin" & mRNA != "INX5"), aes(mRNA, Count, color = type))+
#   geom_jitter()
# 
# ggplot(filter(M, type == "Innexin" & mRNA == "INX5"), aes(mRNA, Count))+
#   geom_jitter()
```

```{r}

# temp <- M %>% 
#   filter(TEA == 0) %>% 
#   select(names(M[!names(M) %in% c("Sample", "TEA", "Experiment", "Cell")])) 
# 
# numeric.cols <- sapply(temp, class) == "numeric"
# temp <- temp[numeric.cols]
# 
# # z <- prcomp(~., data = temp, center = TRUE, scale. = TRUE)
# # fviz_screeplot(z, addlabels = TRUE, ylim = c(0, 50))
# # fviz_pca_var(z, col.var="contrib",
# #              gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
# #              repel = TRUE # Avoid text overlapping
# #              )
# 
# 
# library(factoextra)
# library(missMDA) # for imputePCA 
# library("FactoMineR") #PCA
# 
# df = temp[, -"IH"]
# missMDA::imputePCA(df, ncp = 2) # using two components
# 
# res.pca <- PCA(df,  graph = FALSE)
# # Extract eigenvalues/variances
# get_eig(res.pca)
# # Visualize eigenvalues/variances
# fviz_screeplot(res.pca, addlabels = TRUE, ylim = c(0, 50))
# # Extract the results for variables
# var <- get_pca_var(res.pca)
# var
# 
# # Graph of variables: default plot
# fviz_pca_var(res.pca, col.var = "black")
# 
# # Control variable colors using their contributions
# fviz_pca_var(res.pca, col.var="contrib",
#              gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
#              repel = TRUE # Avoid text overlapping
#              )

```

```{r}
# df <- EDA.r %>%
#   filter(Time == 40) %>%
#   select("r11", "r12", "r1", "rc", "cc", "rmp",
#    "Mean.Min.V", "Mean.Max.V", "Mean.Med.V", "Mean.Mean.V",
#     "Mean.Duration", "Mean.On.Duration", "Mean.Duty.Cycle",
#     "Percent.Shift", "Onset.Delay", "P.Onset.Delay", "Cor",
#     "Mean.AUC", "Min.AUC", "Mean.AUC.mV.S", "Min.AUC.mV.S")
# 
# 
# z <- prcomp(~., data = df, center = TRUE, scale. = TRUE)
# fviz_screeplot(z, addlabels = TRUE, ylim = c(0, 50))
# fviz_pca_var(z, col.var="contrib",
#              gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
#              repel = TRUE # Avoid text overlapping
#              )

# z <- prcomp(~ Fat + Lactose, data = M, center = TRUE, scale. = TRUE)
#
# str(z)
# summary(z)
# biplot(z)



```
## What structure is there in the dataset?


## What correspondence between ephys ~ mRNA is there?

## How can we extend this to the data Brian Collected?
