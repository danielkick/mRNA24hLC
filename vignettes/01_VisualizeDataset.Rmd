---
title: "01_VisualizeDataset"
author: "Daniel Kick"
date: 'Last updated: `r Sys.Date()`'
output:
  distill::distill_article:
    toc: true
    toc_float: true
---

```{r eval=FALSE, include=FALSE}
# below: yaml for html without distill
# output:
#   html_document:
#     smart: no
#     theme: flatly
#     toc: true
#     toc_float: true
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE) # run code, echo = False will only show output
# knitr::opts_chunk$set(include = FALSE) # show nothing

library(here)
library(readxl)

library(plotly) # loaded first so that it doesn't become the default filter
library(tidyverse)
library(car)
library(FSA) # for Dunn's Test

library(factoextra)
library(FactoMineR) #PCA
library(umap) # for UMAP
library(pvclust)
library(dendextend)

library(ggthemes)
library(cowplot)
library(patchwork)
library(rgl) # for vis_pca_3D

library(ggpmisc) # for labeling through stat_poly_eq
theme_set(ggplot2::theme_minimal())
devtools::load_all()
```

# Data preparation
## Load data and create a uid
```{r load data}
## Load in data ====
load(here("data", "ionic.rds"))
load(here("data", "tevc.rds"))
load(here("data", "tecc.rds"))
load(here("data", "mrna.rds"))
epsp <- read.csv(here("data", "epsp.csv")) %>% as_tibble()
metadata <- read_excel(here("inst", "extdata", "ManualDataEphys02.xlsx"),
                       sheet = "MetadataEphys")  
# tables from Northcutt 2016 and annotations
mRNAInfo <- readxl::read_excel(here("inst", "extdata", "mRNAInfo.xlsx")) 
```

```{r mk metadata}
## Add Experiment/Cell to metadata ====
metadata <- metadata %>% 
  mutate(ABFType = case_when(Type %in% c("tevc") ~ "gjvc",
                            # Type %in% c("igj","igj_50", "gj") ~ "gjcc",
                            # Type %in% c("epsp", "epsp_50") ~ "epsp",
                            Type %in% c("fi_50", "fi") ~ "fi")) %>% 
  # make expected file names
  mutate(num_zeros = str_length(Recording)) %>% 
  mutate(num_zeros = ifelse(num_zeros == 1, "000", 
                            ifelse(num_zeros == 2, "00", 
                                   ifelse(num_zeros == 3, "0", NA)))) %>% 
  mutate(FileName = paste0(Experiment, "_", num_zeros, as.character(Recording), ".abf" )) %>% 
  select(-num_zeros)



#TODO there are only two Type == "gj". Replace these with igj|igj_50
#   Experiment  Page Recording Type    TEA Condition Include Notes   In4   In9 ABFType FileName       
#   <chr>      <dbl>     <dbl> <chr> <dbl> <chr>     <lgl>   <lgl> <dbl> <dbl> <chr>   <chr>          
# 1 190906         0        32 gj       24 Delayed   NA      NA        5    NA NA      190906_0032.abf
# 2 190906         0        50 gj       24 Delayed   NA      NA        4    NA NA      190906_0050.abf



### use a subset of metadata cols to add experiment/cell data to other dfs ####
small_metadata <- metadata %>% 
  select(Experiment, FileName, In4, In9) %>% 
  gather("Channel", "Cell", c("In4", "In9"))

small_metadata2 <- metadata %>% 
  select(Experiment, Type, FileName, In4, In9) %>% 
  gather("Channel", "Cell", c("In4", "In9"))
```

## Current Clamp
```{r tecc metadata}
## Add Experiment/Cell to tecc ====
tecc <- tecc %>% 
  mutate(PreSyn = case_when(
    (abs(R1S3Mean) > abs(R1S6Mean)) ~ Signal1, 
    (abs(R1S3Mean) < abs(R1S6Mean)) ~ Signal4
    ),
    vrest = case_when(
    (abs(R1S3Mean) > abs(R1S6Mean)) ~ R1S1Baseline, 
    (abs(R1S3Mean) < abs(R1S6Mean)) ~ R1S4Baseline
    )) %>% 
  mutate(PreSyn = case_when(
    PreSyn == "IN 9" ~ "In9",
    PreSyn == "IN 4" ~ "In4"
  )) %>% 
  select(FileName, PreSyn, vrest, #Signal1, Signal4, R1S1Baseline, R1S4Baseline, 
         cc, r11, r1#, r12, rc # gap junction measures we'll get from voltage clamp
         ) %>% 
  distinct() %>% 
  rename(Channel = PreSyn)


tecc <- left_join(tecc, spread(small_metadata, Channel, Cell)) %>% 
  mutate(Cell = case_when(Channel == "In9" ~ In9,
                          Channel == "In4" ~ In4),
         PrePost = case_when(Channel == "In9" ~ paste0("cc.", as.character(In9), "_", as.character(In4)),
                             Channel == "In4" ~ paste0("cc.", as.character(In4), "_", as.character(In9)))
         ) %>% 
  filter(!is.na(Cell) &
           !is.na(In4) &
           !is.na(In9)) %>% 
  filter(In4 %in% c(3, 4, 5) &
         In9 %in% c(3, 4, 5)) %>% 
  select(-In4, -In9) %>% 
  filter(!is.na(cc)) %>% 
  spread(PrePost, cc)
```

## Voltage Clamp (Gap Junction Procedure)
```{r tevc metadata}
## Add Experiment/Cell to tevc ====
tevc <-
  tevc %>% 
  select(FileName, PreSyn, MedianIg) %>% 
  distinct() %>% 
  mutate(PreSyn = case_when(
    PreSyn == "IN 9" ~ "In9",
    PreSyn == "IN 4" ~ "In4"
  )) %>% 
  rename(Channel = PreSyn,
         ig = MedianIg)


tevc <- left_join(tevc, spread(small_metadata, Channel, Cell)) %>% 
  mutate(Cell = case_when(Channel == "In9" ~ In9,
                          Channel == "In4" ~ In4),
         PrePost = case_when(Channel == "In9" ~ paste0("ig.", as.character(In9), "_", as.character(In4)),
                             Channel == "In4" ~ paste0("ig.", as.character(In4), "_", as.character(In9)))
         ) %>% 
  filter(!is.na(Cell) &
           !is.na(In4) &
           !is.na(In9)) %>% 
  filter(In4 %in% c(3, 4, 5) &
         In9 %in% c(3, 4, 5)) %>% 
  select(-In4, -In9) %>% 
  filter(!is.na(ig)) %>% 
  spread(PrePost, ig)

# is conductance symmetric?
# tevc_plt <- tevc %>% 
#   select(-FileName, -Channel, -Cell) %>%
#   group_by(Experiment) %>% 
#   mutate_all(median, na.rm = T) %>% 
#   distinct() 
# 
# tevc_plt %>% 
# ggplot(aes(x = ig.3_4, y = ig.4_3))+
#   geom_point()
# 
# tevc_plt %>% 
# ggplot(aes(x = ig.3_5, y = ig.5_3))+
#   geom_point()
# 
# tevc_plt %>% 
# ggplot(aes(x = ig.4_5, y = ig.5_4))+
#   geom_point()

tevc[is.na(tevc$ig.3_4), "ig.3_4"] <- tevc[is.na(tevc$ig.3_4), "ig.4_3"]
tevc[is.na(tevc$ig.3_5), "ig.3_5"] <- tevc[is.na(tevc$ig.3_5), "ig.5_3"]
tevc[is.na(tevc$ig.4_5), "ig.4_5"] <- tevc[is.na(tevc$ig.4_5), "ig.5_4"]

tevc <- tevc %>% select(-ig.4_3, -ig.5_3, -ig.5_4)
```


## Add metadata to epsp
```{r epsp metadata}
## Add Experment/Cell to epsp ====
epsp <- left_join(epsp, small_metadata2)

# TODO How do we best caputre variace? find range between max/min across all sweeps when calculating auc? 
# note that there are plenty of replicates here
epsp %>% group_by(Experiment, Cell, Type) %>% filter(Sweep == 1 & Key == "predicted") %>% tally()
# epsp %>% filter(Experiment == "190808a" & Cell == 3 & Sweep == 1)

##
```

## Update labeling on Brian's cells
```{r}
# Relabel Brian's cells ----
##
temp <- mrna[mrna$Source == "Brian" &
       mrna$Pharm == "AP" &
       mrna$Time == "Delayed", "Cell"]%>% 
  unlist() %>% 
  str_remove(pattern = "#") %>% 
  str_split(pattern = " ") %>%
  transpose()

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "AP" &
       mrna$Time == "Delayed", "Experiment"] <- unlist(transpose(temp[[1]]))

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "AP" &
       mrna$Time == "Delayed", "Cell"] <- unlist(transpose(temp[[2]])) %>% str_remove(pattern = "LC")


##
temp <- mrna[mrna$Source == "Brian" &
       mrna$Pharm == "None" &
       mrna$Time == "Baseline", "Cell"] %>% 
  unlist() %>% 
  str_remove(pattern = "Control #")

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "None" &
       mrna$Time == "Baseline", "Experiment"] <- temp

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "None" &
       mrna$Time == "Baseline", "Cell"] <- NA


##
temp <- mrna[mrna$Source == "Brian" &
       mrna$Pharm == "None" &
       mrna$Time == "Delayed", "Cell"] %>% 
  unlist() %>% 
  str_split(pattern = " ") %>%
  transpose()

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "None" &
       mrna$Time == "Delayed", "Experiment"] <- unlist(transpose(temp[[1]]))

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "None" &
       mrna$Time == "Delayed", "Cell"] <- unlist(transpose(temp[[2]])) %>% str_remove(pattern = "LC")


##
temp <- mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TEA" &
       mrna$Time == "Compensated", "Cell"] %>% 
  unlist() %>% 
  str_remove(pattern = "TEA #")

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TEA" &
       mrna$Time == "Compensated", "Experiment"] <- temp

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TEA" &
       mrna$Time == "Compensated", "Cell"] <- NA

##
temp <- mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TEA" &
       mrna$Time == "Delayed", "Cell"] %>% 
  unlist() %>% 
  str_remove(pattern = "TEA24-")

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TEA" &
       mrna$Time == "Delayed", "Experiment"] <- temp

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TEA" &
       mrna$Time == "Delayed", "Cell"] <- NA

##
temp <- mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TTX", "Cell"] %>% 
  unlist() %>% 
  str_split(pattern = "-") %>%
  transpose()

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TTX", "Experiment"] <- unlist(transpose(temp[[1]]))

mrna[mrna$Source == "Brian" &
       mrna$Pharm == "TTX", "Cell"] <- unlist(transpose(temp[[2]]))
## deduplicate mrna
mrna <- mrna %>%
  gather(key = "mrna",
         value = "count",
         names(mrna)[!(names(mrna) %in% c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell"))]) %>%
  filter(mrna != c("htr2b", "kainate2b", "nmda1a", "nmda2b", "mglur7", "trpm1", "machrb", "htr1b")) %>% # drop fully missing mrnas
  group_by(Source, Pharm, Time, Experiment, Cell, mrna) %>%
  mutate(count = median(count, na.rm = T)) %>%
  ungroup() %>%
  distinct() %>%
  spread(key = "mrna", value = "count")
```


## Add whether network was active to metadata
```{r}
# Was there activity on the EC? 
metadata <- full_join(metadata,
tibble::tribble(
  ~Experiment, ~ExtracellularActive,
    "190808a",                 TRUE,
     "190830",                 TRUE,
     "190903",                 TRUE,
     "190904",                 TRUE,
     "190905",                 TRUE,
     "190906",                 TRUE,
     "190907",                 TRUE,
     "190915",                 TRUE,
    "190916a",                 TRUE,
    "190917a",                   NA, # File not found. Entry not found in notebook either.
     "190917",                 TRUE,
     "190918",                 TRUE,
     "190924",                 TRUE,
    "190924a",                 TRUE,
     "191002",                 TRUE,
     "191004",                 TRUE,
     "190926",                 TRUE,
     "190927",                FALSE,
    "190927a",                 TRUE,
     "190930",                FALSE,
    "190930a",                FALSE,
     "191001",                 TRUE
  )
)

metadata %>% 
  select(Experiment, Condition, ExtracellularActive) %>% 
  filter(Condition %in% c("Baseline", "Compensated", "Delayed")) %>% 
  distinct() %>% 
  group_by(Condition, ExtracellularActive) %>% 
  tally() %>%
  filter(!is.na(ExtracellularActive)) %>% 
  pivot_wider(names_from = "ExtracellularActive", values_from = "n")

```

## Create cross type data, sans Brian's cells
```{r}
small_metadata <- metadata[, c("Experiment",  "FileName", "Condition")]

M_ionic<- ionic %>% mutate(Cell = as.character(Cell))  
#Ihtk.0 Ihtk.Slope  Ia.0 Ia.Slope
M_tecc <- left_join(tecc, small_metadata) %>% select(-FileName) %>% mutate(Cell = as.character(Cell))
# QC drop all non positive resistances, all ccs outside 0-1

M_tecc <- M_tecc %>% mutate(
  # cc  = ifelse(cc > 0 & cc < 1, cc, NA),
  r11 = ifelse(r11 >0, r11, NA),
  r1  = ifelse(r1 >0, r1, NA),
  # r12  = ifelse(r12 >0, r12, NA),
  # rc  = ifelse(rc >0, rc, NA)
  
  cc.3_4  = ifelse(cc.3_4 > 0 & cc.3_4 < 1, cc.3_4, NA),
  cc.3_5  = ifelse(cc.3_5 > 0 & cc.3_5 < 1, cc.3_5, NA),
  cc.4_3  = ifelse(cc.4_3 > 0 & cc.4_3 < 1, cc.4_3, NA),
  
  cc.4_5  = ifelse(cc.4_5 > 0 & cc.4_5 < 1, cc.4_5, NA),
  cc.5_3  = ifelse(cc.5_3 > 0 & cc.5_3 < 1, cc.5_3, NA),
  cc.5_4  = ifelse(cc.5_4 > 0 & cc.5_4 < 1, cc.5_4, NA)
) #%>% 
  # mutate(rc = rc^-1) %>% 
  # rename(rc.ig = rc)

#vrest     cc   r11    r12    r1    rc 
M_tevc <- left_join(tevc, small_metadata) %>% select(-FileName) %>% mutate(Cell = as.character(Cell)) 
#ig
M_epsp <- left_join(epsp, small_metadata) %>% 
  select(-FileName, -Type) %>% 
  mutate(Cell = as.character(Cell))  %>% 
  mutate(Key = case_when(Key %in% c("In4", "In9") ~ "Obs",
                                  Key %in% c("predicted")  ~ "Sim")) %>% 
  pivot_wider(names_from = "Key", values_from  = c("Min.V", "Max.Amplitude", "AUC")) %>% 
  mutate(Max.Amplitude_Sim = Max.Amplitude_Sim + (Min.V_Obs - Min.V_Sim)) %>% 
  mutate(Max.Amplitude_Delta = Max.Amplitude_Obs - Max.Amplitude_Sim,
         AUC_Delta = AUC_Obs - AUC_Sim) %>% 
  group_by(Condition, Experiment, Cell) %>% 
  select(-Min.V_Sim) %>% 
  mutate_at(c("Cor", 
              "Min.V_Obs", #"Min.V_Sim", "Min.V_Delta", 
              "Max.Amplitude_Obs", "Max.Amplitude_Sim", "Max.Amplitude_Delta", 
              "AUC_Obs", "AUC_Sim", "AUC_Delta"), median, na.rm = T) %>% 
  distinct() %>% 
  ungroup()
  

#Sweep   Cor Key        Min.V Max.Amplitude    AUC 
M_mrna <- left_join(mrna[mrna$Source == "Daniel", ], small_metadata) %>% select(-FileName) %>% mutate(Cell = as.character(Cell))


#Set up data cols to help organize full dataset
ionic_cols <- c("Ihtk.0", "Ihtk.Slope", "Ia.0", "Ia.Slope")
tecc_cols <- c("vrest", "r11", "r1", "cc.3_4", "cc.3_5", "cc.4_3", "cc.4_5", "cc.5_3", "cc.5_4")#, "r12", "rc.ig") # ignore rc, ig is a more direct measure
tevc_cols <- c("ig.3_4", "ig.3_5", "ig.4_5")
epsp_cols <- c("Cor", "Min.V_Obs", "Max.Amplitude_Obs", "Max.Amplitude_Sim", "AUC_Obs", "AUC_Sim", 
               "Max.Amplitude_Delta", "AUC_Delta")
mrna_cols <- names(mrna)[!(names(mrna) %in% c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell"))]


M_all <- full_join(M_ionic, M_tecc) %>% full_join(M_tevc) %>% full_join(M_epsp) %>% full_join(M_mrna)

reordered_names <- c(names(M_all)[!(names(M_all) %in% c(tecc_cols, tevc_cols, epsp_cols, ionic_cols, mrna_cols))], 
                                                      c(tecc_cols, tevc_cols, epsp_cols, ionic_cols, mrna_cols))


M_all <- M_all[, reordered_names] %>% filter(Condition %in% c("Baseline", "Compensated", "Delayed") & Cell %in% c(3, 4, 5)) %>% distinct()

# #TODO this needs some prep work. We'll want to capture the variance in these measures.
# # Not clear how to do that. 
# epsp %>% ggplot(aes(x = FileName, Max.Amplitude, color = interaction(Experiment, Cell)))+
#   geom_line()+
#   geom_point()+
#   facet_grid(.~Key)

#TODO move this to top
# QC data by completion rate, having variance, and median mrna abundance
M_all_outliers <- M_all
M_all_skim <- M_all %>% skimr::skim()
M_all_skim <- M_all_skim[M_all_skim$complete_rate >= 0.19 & 
             M_all_skim$numeric.sd > 0, ]

M_all_skim <- M_all_skim[!(M_all_skim$skim_variable %in% mrna_cols) |
            ((M_all_skim$skim_variable %in% mrna_cols) & M_all_skim$numeric.p50 >= 50 ), ]

M_all <- M_all[, names(M_all) %in% c(
  "Condition", "Cell", "Experiment", "Channel", 
  "Sweep", "Source", "Pharm", "Time", "Sample", 
  M_all_skim$skim_variable[!is.na(M_all_skim$skim_variable)])
  ]

# update cols now that data is QCed
ionic_cols <- c("Ihtk.0", "Ihtk.Slope", "Ia.0", "Ia.Slope")[ionic_cols %in% names(M_all)]
tecc_cols <- c("vrest", "r11", "r1", "cc.3_4", "cc.3_5", "cc.4_3", "cc.4_5", "cc.5_3", "cc.5_4")[tecc_cols %in% names(M_all)]
#, "r12", "rc.ig") # ignore rc, ig is a more direct measure
tevc_cols <- c("ig.3_4", "ig.3_5", "ig.4_5")[tevc_cols %in% names(M_all)]
epsp_cols <- c("Cor", "Min.V_Obs", "Max.Amplitude_Obs", "Max.Amplitude_Sim", "AUC_Obs", "AUC_Sim", 
               "Max.Amplitude_Delta", "AUC_Delta")[epsp_cols %in% names(M_all)]
mrna_cols <- mrna_cols[mrna_cols %in% names(M_all)]
```


# About the data
## What conditions exist in both datasets?
```{r}
temp <- mrna %>% select(Pharm, Time, Source) %>% distinct()

temp %>% group_by(Pharm, Source) %>%  mutate(exists = "T") %>% spread(Time, exists)
```

## How many networks had _any_ extracellular activity by their colleciton point?
```{r}
metadata %>% 
  select(Experiment, Condition, ExtracellularActive) %>% 
  filter(Condition %in% c("Baseline", "Compensated", "Delayed")) %>% 
  distinct() %>% 
  group_by(Condition, ExtracellularActive) %>% 
  tally() %>%
  filter(!is.na(ExtracellularActive)) %>% 
  pivot_wider(names_from = "ExtracellularActive", values_from = "n")
```

## How many individuals were there in each group?
```{r}
M_all %>% select(Condition, Experiment, Cell) %>% distinct() %>% group_by(Condition) %>% tally() 

M_all %>% select(Condition, Experiment) %>% distinct() %>% group_by(Condition) %>% tally() 
```

# What's happening in Brian's Data?
## Prep data -- cull outliers and median interpolate missing values
```{r}
# select the mRNAs present in both Brian's data and mine. 
mrna_b <-select(mrna, 
                 Source, Pharm, Time, Experiment, Cell, 
                 bkkca, cav1, cav2, 
                 inx1, inx2, inx3, inx4, inx5, 
                 nav, 
                 shab, shaker, shal, shaw1, shaw2) %>% 
  filter(Source == "Brian")
  # mutate(Pharm = ifelse(Source == "Daniel" & Time == "Baseline", "None", Pharm)) 
  
mrna_b %>% skimr::skim()

mrna_b %>% 
  group_by(Time, Pharm, Source) %>% 
  tally()

mrna_b$uid <- as.character(seq(1, nrow(mrna_b)))
mrna_b <- mrna_b %>% 
  select(-Experiment, -Cell) %>% 
  unite(Group, Source, Pharm, Time)

mrna_b <- mrna_b[, c("Group", "uid",
                       names(mrna_b)[!(names(mrna_b) %in% c("Group", "uid"))])
                   ]


# Remove Outliers 
mrna_b_winxiqr_list <- map(unique(mrna_b$Group), function(group){
  temp <- mrna_b[mrna_b$Group == group, ]
  dvs <- names(mrna_b)[!(names(mrna_b) %in% c("Group", "uid"))]
  
  for (dv_col  in dvs){
    temp[[dv_col]] <- ifelse(win_x_iqr(temp[[dv_col]]), temp[[dv_col]], NA)
  }
  
  return(temp)
})

mrna_b_winxiqr <- do.call(rbind, mrna_b_winxiqr_list)

# Median interpolate missing
mrna_b_winxiqr_interp <- imputeMissings::impute(mrna_b_winxiqr, method = "median/mode")
```


## Gestalt view: are there distinct groups?

### PCA

All groups
```{r}
vis_pca_3D_plotly(
  input.df = select(mrna_b_winxiqr_interp, -Group, -uid),
  color.by = unlist(select(mrna_b_winxiqr_interp, Group)),
  use.colors = RColorBrewer::brewer.pal(9, "Paired"),
  ellipse.opacity = 0#.02
  )
```

Combine observation groups 
```{r}
mrna_b_annotations <- mrna_b_winxiqr_interp %>%
  separate(Group, c("Source", "Pharm", "Time")) %>%
  select(Source, Pharm, Time)

# Color by Pharm
vis_pca_3D_plotly(
  input.df = select(mrna_b_winxiqr_interp, -Group, -uid),
  color.by = unlist(select(mrna_b_annotations, Pharm)),
  use.colors = RColorBrewer::brewer.pal(9, "Paired"),
  ellipse.opacity = 0#.02
  )


# Color by Time exposed
vis_pca_3D_plotly(
  input.df = select(mrna_b_winxiqr_interp, -Group, -uid),
  color.by = unlist(select(mrna_b_annotations, Time)),
  use.colors = RColorBrewer::brewer.pal(9, "Paired"),
  ellipse.opacity = 0#.02
  )
```

```{r}
mrna_b_pca_plts <- mk_pca_multi_plt(
  input.df = select(mrna_b_winxiqr_interp, -Group, -uid),
  scree.max.y = 100)

cowplot::plot_grid(
  plotlist = list(
    mrna_b_pca_plts$biplt, 
    mrna_b_pca_plts$cont2, 
    mrna_b_pca_plts$cont1, 
    mrna_b_pca_plts$scree)
  )

# ggsave(plot = last_plot(),         
#        filename = here("officer_output", "mRNA_Brian_PCA.tiff"),        
#        width = 11.5, height = 4.76)
```

### UMAP
```{r}
set.seed(16069)
temp.umap = umap(select(mrna_b_winxiqr_interp, -Group, -uid))

temp <- temp.umap$layout %>% as.tibble()

col_by_df <- mrna_b_winxiqr_interp[, "Group"] %>% as.data.frame() %>% rename("Group" = ".")
col_by_df <- separate(col_by_df, col = "Group", sep = "_", c("Author", "Blocker", "Time"))

# plot with convex hulls
# https://stats.stackexchange.com/questions/22805/how-to-draw-neat-polygons-around-scatterplot-regions-in-ggplot2

#getting the convex hull of each unique point set, must contain no missing data
mrna_b_umap_plts <- map(
  c("Group", "Blocker", "Time"), function(current_grouping){
    df <- temp
    if (current_grouping == "Group"){
      df$Group <- mrna_b_winxiqr_interp[[current_grouping]]    
    } else {
      df$Group <- col_by_df[[current_grouping]]
    }
    
    find_hull <- function(df) df[chull(df$V1, df$V2), ]
    hulls <- plyr::ddply(df, "Group", find_hull)
    
    ggplot(df, aes(V1, V2, color = Group, fill = Group))+
      geom_polygon(data = hulls, alpha = 0.1) +
      geom_point()
  })

# plot_grid(plotlist = mrna_b_umap_plts)

mrna_b_umap_plts[[1]] / mrna_b_umap_plts[[2]] / mrna_b_umap_plts[[3]]
```

### Clustering

```{r cache=TRUE}
# If a move to tidygraph/ggraph becomes desirable
# https://rpubs.com/Roeland-KINDT/702542

set.seed(654684)
cluster <- pvclust(
  t(select(mrna_b_winxiqr_interp, -Group, -uid)),
  method.hclust = "ward.D2",
                   method.dist = "correlation",
                   use.cor = "pairwise.complete.obs")
```

```{r, layout="l-body-outset", fig.width = 8, fig.asp = .7}
# fig.width = 7, fig.asp = .607
# 755/1243 # desired output height width

# for bar with all groups
my_colors <- case_when(
  mrna_b_winxiqr$Group == "Brian_AP_Delayed" ~ "#8c2d04",
  
  mrna_b_winxiqr$Group == "Brian_None_Baseline" ~ "#4292c6",
  mrna_b_winxiqr$Group == "Brian_None_Delayed" ~ "#084594",
  
  mrna_b_winxiqr$Group == "Brian_TEA_Compensated" ~ "#ef3b2c",
  mrna_b_winxiqr$Group == "Brian_TEA_Delayed" ~ "#99000d",
  
  mrna_b_winxiqr$Group == "Brian_TTX_Delayed" ~ "#4a1486")

# for bars with one group
flag_ap_d <- ifelse(mrna_b_winxiqr$Group == "Brian_AP_Delayed" , "#8c2d04", NA)
flag_none_b <- ifelse(mrna_b_winxiqr$Group == "Brian_None_Baseline" , "#4292c6", NA)
flag_none_d <- ifelse(mrna_b_winxiqr$Group == "Brian_None_Delayed" , "#084594", NA)
flag_tea_c <- ifelse(mrna_b_winxiqr$Group == "Brian_TEA_Compensated" , "#ef3b2c", NA)
flag_tea_d <- ifelse(mrna_b_winxiqr$Group == "Brian_TEA_Delayed" , "#99000d", NA)
flag_ttx_d <- ifelse(mrna_b_winxiqr$Group == "Brian_TTX_Delayed" , "#4a1486", NA)
  
  
group_flag_list <- list(
  flag_ap_d,
  flag_none_b,
  flag_none_d,
  flag_tea_c,
  flag_tea_d,
  flag_ttx_d
)  
group_flag_name_list <- list(
  "ap_d",
  "none_b",
  "none_d",
  "tea_c",
  "tea_d",
  "ttx_d"
)  


par(mar=c(8,2,2,1)) # quick ref on par https://bookdown.org/ndphillips/YaRrr/plot-margins.html

dend <- cluster %>% 
  as.dendrogram() %>% 
  set("branches_k_color",
      value = c(
        #"#a6cee3", 
        "#1f78b4", 
        "#fb9a99",
        "#e31a1c", 
        #"#fdbf6f", 
        "#ff7f00"
        ),
      k = 4)
  # set("labels_col", 
  #     value = c("#a6cee3", "#1f78b4", "#fb9a99", 
  #               "#e31a1c", "#fdbf6f", "#ff7f00"),
  #     k = 6) #%>%
  

plot(dend)

colored_bars(colors = my_colors, 
             dend = as.dendrogram(cluster), 
             rowLabels = " Groups",
             y_shift = -.15)


bar_y_pos <- -0.15
for (i in seq_along(group_flag_list)){
  bar_y_pos <- bar_y_pos-0.05
  colored_bars(colors = group_flag_list[[i]], 
             dend = as.dendrogram(cluster), 
             rowLabels = group_flag_name_list[[i]],
             y_shift = bar_y_pos)
}


```

## Correlations
### Correlation heatmaps
```{r}
library(ggcorrplot)

cor_plt_list <- list()

for (temp.group in c("Brian_All", unique(mrna_b_winxiqr$Group))){
  print(temp.group)
  if (temp.group == "Brian_All"){
    cor_df <- select(mrna_b_winxiqr, -Group, -uid)
  } else {
    cor_df <- select(filter(mrna_b_winxiqr, Group == temp.group), -Group, -uid)
  }
  
  # p.mat <- cor_pmat(cor_df)
  cor_df_bin <- cor(cor_df, use = "pairwise.complete.obs")
  
  # bin the correlations so there are fewer colors used in the figure
  cor_bins <- seq(-1, 1, length.out = 8)
  for (i in 1:(length(cor_bins)-1)){
    # use the average bin value
    # cor_df_bin[cor_df_bin > cor_bins[i] & cor_df_bin < cor_bins[i+1]] <- (cor_bins[i] + cor_bins[i+1])
    # use the more extreme value to shade with
    cor_df_bin[cor_df_bin > cor_bins[i] & cor_df_bin < cor_bins[i+1]] <- cor_bins[c(i, (i+1))[which.max(abs(cor_bins[i:(i+1)]))]]
  }
  
  cor_plt_list[[(length(cor_plt_list)+1)]] <- ggcorrplot(
    cor_df_bin, 
    # p.mat = p.mat,
    insig = "blank",
    type = "upper",
    outline.col = "white",
    colors = RColorBrewer::brewer.pal(n = 9, name = "PuOr")[c(1,5,9)]
  )+
    labs(subtitle = temp.group)+
    theme(legend.position = "")
  
}


# cor_plt_list[[1]] +
  cor_plt_list[[3]] + cor_plt_list[[4]] +
  cor_plt_list[[5]] + cor_plt_list[[6]] +
  # plot_spacer() +
  plot_spacer() + cor_plt_list[[2]] +
  plot_spacer() + cor_plt_list[[7]] + plot_layout(ncol = 4) #plot_layout(ncol = 5)
```


### Correlations ECDFs
```{r}
cor_list_df <- map(unique(mrna_b_winxiqr$Group), function(group){
  temp <- cor(select(mrna_b_winxiqr[mrna_b_winxiqr$Group == group, ], -Group, -uid), use = "pairwise.complete.obs") %>% as.data.frame()
  temp$row <- rownames(temp)
  temp <- gather(temp, "col", "Corr", names(temp)[names(temp) != "row"])
  temp$Group <- group
  
  return(temp)  
})
cor_list_df <- do.call(rbind, cor_list_df)

# cor_list_df$Group %>% unique()

ecdf_corr_list <- map(
list(list("Brian_None_Baseline", "Brian_None_Delayed"),
     list("Brian_None_Baseline", "Brian_TEA_Compensated"),
     list("Brian_None_Delayed", "Brian_AP_Delayed"),
     list("Brian_None_Delayed", "Brian_TEA_Delayed"),
     list("Brian_None_Delayed", "Brian_TTX_Delayed")
     ),

function(group_comparison){
  plot_ecdf_ks(
  df = cor_list_df[cor_list_df$Group %in% group_comparison, ],
  data.col = "Corr",
  group.col = "Group",
  group1 = group_comparison[1],
  group2 = group_comparison[2],
  colors = c("black", "red"))
})

# cowplot::plot_grid(plotlist = ecdf_corr_list)

ecdf_corr_list[[1]] + ecdf_corr_list[[2]] + plot_spacer()+ 
  ecdf_corr_list[[3]] + ecdf_corr_list[[4]] + ecdf_corr_list[[5]]


# ggsave(plot = last_plot(),         
#        filename = here("officer_output", "ContrastSource_ecdfs.tiff"),        
#        width = 11.5, height = 4.76)
```


## Changes in mean mRNA levels


```{r}
# refresh NO median interpolation
mrna_b_winxiqr <- do.call(rbind, mrna_b_winxiqr_list)

mrna_b_winxiqr_to_test <- mrna_b_winxiqr %>% 
  separate(Group, c("Source", "Pharm", "Time")) %>% 
  select(-Source) %>% 
  distinct()

library(broom)
```

### How does time alter control cells?
_cav2_, _shab_, and _shaker_ change over time.
```{r}
# desired tests
# time in control
temp <- mrna_b_winxiqr_to_test %>% filter(Pharm %in% c("None"))
temp %>% group_by(Time) %>% tally()

temp_ys <- names(select(temp, -Time, -Pharm, -uid))

temp_fms <- map(temp_ys, function(temp_y){
  fm <- lm(as.formula(paste0(temp_y," ~ Time")), data = temp)
  res <- broom::tidy(fm)
  res$y <- temp_y
  return(res)
})

temp_p <- do.call(rbind, temp_fms) %>% filter(term != "(Intercept)")
temp_p <- temp_p %>% select(y, term, estimate, std.error, statistic, p.value) %>% 
  mutate(p.adj = p.adjust(p.value, method = "holm")) %>% 
  mutate(stars = case_when(p.adj < 0.001 ~ "***",
                       p.adj >= 0.001 & p.adj < 0.01 ~ "**",
                       p.adj >= 0.01 & p.adj < 0.05 ~ "*",
                       p.adj >= 0.05 & p.adj < 0.1 ~ ".",
                       p.adj >= 0.1 ~ " "
                       ))

temp_p
```


```{r}
temp %>% 
  pivot_longer(temp_ys, names_to = "mRNA", values_to = "Count") %>% 
  filter(mRNA %in% unlist(distinct(select(filter(temp_p, p.adj < 0.05), y)))) %>% 
  # group_by(Time) %>% 
  ggplot(aes(x= Time, y= Count, fill = mRNA))+
  geom_boxplot()+
  geom_point()+
  ggthemes::theme_clean()+
  scale_fill_brewer()+
  facet_grid(.~mRNA)
```

### How does time alter TEA cells?
_bkkca_ expression, _inx1_ expression, and maybe _inx3_ expression
```{r}
# time in TEA
temp <- mrna_b_winxiqr_to_test %>% filter(Pharm %in% c("TEA"))
temp %>% group_by(Time) %>% tally()

temp_ys <- names(select(temp, -Time, -Pharm, -uid))

temp_fms <- map(temp_ys, function(temp_y){
  fm <- lm(as.formula(paste0(temp_y," ~ Time")), data = temp)
  res <- broom::tidy(fm)
  res$y <- temp_y
  return(res)
})

temp_p <- do.call(rbind, temp_fms) %>% filter(term != "(Intercept)")
temp_p <- temp_p %>% select(y, term, estimate, std.error, statistic, p.value) %>% 
  mutate(p.adj = p.adjust(p.value, method = "holm")) %>% 
  mutate(stars = case_when(p.adj < 0.001 ~ "***",
                       p.adj >= 0.001 & p.adj < 0.01 ~ "**",
                       p.adj >= 0.01 & p.adj < 0.05 ~ "*",
                       p.adj >= 0.05 & p.adj < 0.1 ~ ".",
                       p.adj >= 0.1 ~ " "
                       ))

temp_p
```

```{r}
temp %>% 
  pivot_longer(temp_ys, names_to = "mRNA", values_to = "Count") %>% 
  filter(mRNA %in% unlist(distinct(select(filter(temp_p, p.adj < 0.05), y)))) %>% 
  # group_by(Time) %>% 
  ggplot(aes(x= Time, y= Count, fill = mRNA))+
  geom_boxplot()+
  geom_point()+
  ggthemes::theme_clean()+
  scale_fill_brewer()+
  facet_grid(.~mRNA)
```

### How do blockers alter cells after all have been incubated?
```{r}
# steady state differences?
  # ap vs TEA vs ttx vs control
temp <- mrna_b_winxiqr_to_test %>% filter(Time %in% c("Delayed"))
temp %>% group_by(Pharm) %>% tally()

temp_fms <- map(temp_ys, function(temp_y){
  fm <- lm(as.formula(paste0(temp_y," ~ Pharm")), data = temp)
  res <- broom::tidy(fm)
  res$y <- temp_y
  return(res)
})

temp_p <- do.call(rbind, temp_fms) %>% filter(term != "(Intercept)")
temp_p <- temp_p %>% select(y, term, estimate, std.error, statistic, p.value) %>% 
  mutate(p.adj = p.adjust(p.value, method = "holm")) %>% 
  mutate(stars = case_when(p.adj < 0.001 ~ "***",
                       p.adj >= 0.001 & p.adj < 0.01 ~ "**",
                       p.adj >= 0.01 & p.adj < 0.05 ~ "*",
                       p.adj >= 0.05 & p.adj < 0.1 ~ ".",
                       p.adj >= 0.1 ~ " "
                       ))

temp_p
```


```{r}
temp %>% 
  pivot_longer(temp_ys, names_to = "mRNA", values_to = "Count") %>% 
  filter(mRNA %in% unlist(distinct(select(filter(temp_p, p.adj < 0.05), y)))) %>% 
  mutate(Pharm = factor(Pharm, levels = c("None", "TEA", "AP", "TTX"))) %>% 
  ggplot(aes(x= Pharm, y= Count, fill = mRNA))+
  geom_boxplot()+
  geom_point()+
  ggthemes::theme_clean()+
  scale_fill_brewer()+
  facet_wrap(.~mRNA, scales = "free_y")
```

```{r}

library(ggpubr)

temp %>% 
  pivot_longer(temp_ys, names_to = "mRNA", values_to = "Count") %>% 
  filter(mRNA %in% unlist(distinct(select(filter(temp_p, p.adj < 0.05), y)))[1] ) %>% 
  mutate(Pharm = factor(Pharm, levels = c("None", "TEA", "AP", "TTX"))) %>% 
  ggboxplot(x = "Pharm", 
            y = "Count", 
            fill = "Pharm",
            width = 0.2,
            palette = RColorBrewer::brewer.pal(4, "Set1")
  )+
  geom_point(position = position_jitter(width = 0.05))+
  stat_compare_means(comparisons = list(
    c("None", "TEA"),
    c("None", "AP"),
    c("None", "TTX"),
    c("TEA", "AP")
  ), 
  label = "p.signif")+ # Add significance levels
  stat_compare_means(label.y = 0)+
  theme(legend.position = "")
```

# Transition -- Do some of these changes replicate?
We've seen that at least some mRNAs change, presumably due to time and time incubated in the treatment.

Can we replicate these effects? When we focus on TEA do we get changes in the same transcripts?

## Data preparation
```{r}
# select the mRNAs present in both Brian's data and mine. 
mrna_rep <-select(mrna, 
                  Source, Pharm, Time, Experiment, Cell, 
                  bkkca, cav1, cav2, 
                  inx1, inx2, inx3, inx4, #inx5, #<- inx5 is likely not expressed
                  nav, 
                  shab, shaker, shal, shaw1, shaw2) %>% 
  filter(
    (Source == "Brian" & Pharm %in% c("None", "TEA")) |
      Source == "Daniel"
         ) %>% 
  filter(!(Source == "Brian" & Pharm %in% c("None") & Time == "Delayed")) %>% 
  mutate(Pharm = ifelse(Source == "Daniel" & Time == "Baseline", "None", Pharm)) %>% 
  select(-Pharm) %>% 
  distinct()
  
mrna_rep %>% skimr::skim()

mrna_rep %>% 
  group_by(Time, Source) %>% 
  tally() %>% 
  spread("Time", "n")




mrna_rep$uid <- as.character(seq(1, nrow(mrna_rep)))
mrna_rep <- mrna_rep %>% 
  select(-Experiment, -Cell) %>% 
  unite(Group, Source, Time)

mrna_rep <- mrna_rep[, c("Group", "uid",
                       names(mrna_rep)[!(names(mrna_rep) %in% c("Group", "uid"))])
                   ]


# Remove Outliers 
mrna_rep_winxiqr_list <- map(unique(mrna_rep$Group), function(group){
  temp <- mrna_rep[mrna_rep$Group == group, ]
  dvs <- names(mrna_rep)[!(names(mrna_rep) %in% c("Group", "uid"))]
  
  for (dv_col  in dvs){
    temp[[dv_col]] <- ifelse(win_x_iqr(temp[[dv_col]]), temp[[dv_col]], NA)
  }
  
  return(temp)
})

mrna_rep_winxiqr <- do.call(rbind, mrna_rep_winxiqr_list)

mrna_rep_winxiqr <- mrna_rep_winxiqr %>% 
  separate("Group", into = c("Source", "Time"), sep = "_")
```

## Compare Correlations
```{r}
# mrna_rep_winxiqr


cor_groupings <- expand.grid(
  Source = c("Brian", "Daniel"),
  Time = c("Baseline", "Compensated", "Delayed")
)

cor_list <- map(seq(1, nrow(cor_groupings)), function(i){
  cor_df <- filter(mrna_rep_winxiqr, 
                   Source == cor_groupings[i, "Source"],
                   Time == cor_groupings[i, "Time"]) %>% 
    select(-Source, -Time, -uid)
  
  cor_df <- cor(cor_df, use = "pairwise.complete.obs")
  
  # Shave to diagonal
  for (j in seq(1, nrow(cor_df))){
    cor_df[j, 1:j] <- NA
  }
  
  cor_df <- as.data.frame(cor_df) %>% mutate(x = rownames(cor_df))
  
  cor_df <- pivot_longer(cor_df, 
                         cols = names(select(cor_df, -x)),
                         names_to = "y", 
                         values_to = "Corr") %>% 
  mutate(
  Source = cor_groupings[i, "Source"],
  Time = cor_groupings[i, "Time"]  
) %>% 
  select(Source, Time, x, y, Corr)
  
 return(cor_df)
})

cor_comp_df <- do.call(rbind, cor_list) %>% 
  filter(!is.na(Corr))



cor_comp_df %>% 
  ggplot(aes(x = Time, y = Corr, fill = Source, group = Source))+
  # geom_line()+
  geom_col(position = "dodge")+
  geom_hline(yintercept = 0)+
  geom_hline(yintercept = sqrt(0.6), color = "red", linetype = "dashed")+
  scale_fill_manual(values = c("Black", "DarkGray"))+
  facet_grid(x ~ y)+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))


# cor_comp_df

ecdf_list_time <- map(c("Baseline", "Compensated", "Delayed"), function(Time){
      plot_ecdf_ks(
        df = cor_comp_df[cor_comp_df$Time == Time, ],
        data.col = "Corr",
        group.col = "Source",
        group1 = "Brian",
        group2 = "Daniel",
        colors = c("black", "red"))})


ecdf_list_sourcetime <- map(
  c("Brian", "Daniel"), function(Source){
    map(
      list(c("Baseline", "Compensated"),
           c("Baseline", "Delayed"),
           c("Compensated", "Delayed")), function(Time){
             plot_ecdf_ks(
               df = cor_comp_df[cor_comp_df$Source == Source & cor_comp_df$Time %in% Time, ],
               data.col = "Corr",
               group.col = "Time",
               group1 = Time[1],
               group2 = Time[2],
               colors = c("black", "red"))
           })
  })


plot_grid(plotlist = ecdf_list_time, nrow = 1)/
plot_grid(plotlist = ecdf_list_sourcetime[[1]], nrow = 1)/ # brian
plot_grid(plotlist = ecdf_list_sourcetime[[2]], nrow = 1) # daniel
```

## Compare Directional Changes
```{r}
# calc p values with kruskal-Wallis and follow it up with a Dunn's ####
mrna_rep_winxiqr <- mrna_rep_winxiqr %>% 
  pivot_longer(
    names_to = "mRNA",
    values_to = "Count",
    cols = names(select(mrna_rep_winxiqr, -Source, -Time, -uid)))

stats <- expand.grid(
  Source = c("Brian", "Daniel"),
  # Time = c("Baseline", "Compensated", "Delayed"),
  mRNA = unique(mrna_rep_winxiqr$mRNA),
  Main = NA,
  BvsC = NA,
  BvsD = NA,
  CvsD = NA
)

for (i in 1:nrow(stats)){
  t_Source <- stats[i, "Source"]
  t_mRNA <- stats[i, "mRNA"]
  
  temp <- mrna_rep_winxiqr %>% 
    filter(Source == t_Source & mRNA == t_mRNA & !is.na(Count)) %>% 
    mutate(Time = as.factor(Time)) # Avoid coering to factor in dunnTest()
  
  stats[i, "Main"] <- kruskal.test(Count ~ Time, temp)$p.value
  
  # i = 1
  dunn_res <- dunnTest(Count ~ Time, 
           data = temp, 
           method = "bonferroni") #FIXME 
  #FIXME -- Is bonferroni ideal here or would we be better off with sidak, holm, or hs?
  dunn_res <- dunn_res$res
  
  stats[i, "BvsC"] <- filter(dunn_res, Comparison == "Baseline - Compensated")$P.adj
  stats[i, "BvsD"] <- filter(dunn_res, Comparison == "Baseline - Delayed")$P.adj
  stats[i, "CvsD"] <- filter(dunn_res, Comparison == "Compensated - Delayed")$P.adj
}

# get medians and prepare to plot ####

mrna_rep_medians <- mrna_rep_winxiqr %>% 
  # pivot_longer(
  #   names_to = "mRNA",
  #   values_to = "Count",
  #   cols = names(select(mrna_rep_winxiqr, -Source, -Time, -uid))) %>% 
  group_by(Source, Time, mRNA) %>% 
  summarise(MedianCount = median(Count, na.rm =T)) %>% 
  arrange(Source, mRNA, Time)
  

mrna_rep_medians <- mrna_rep_medians %>% 
  mutate(
    MedianCount2 = MedianCount,
    id = case_when(Time == "Baseline" ~ 1,
                   Time == "Compensated" ~ 2,
                   Time == "Delayed" ~ 3)) %>% 
  pivot_wider(names_from = "Time", values_from = "MedianCount") %>% 
  rename(MedianCount = MedianCount2) %>% 
  group_by(Source, mRNA) %>% 
  mutate(Baseline = median(Baseline, na.rm = T),
         Compensated = median(Compensated, na.rm = T),
         Delayed = median(Delayed, na.rm = T)) %>% 
  ungroup() %>% 
  mutate(updown12 = ifelse(Baseline < Compensated, "up", "down"), 
         updown13 = ifelse(Baseline < Delayed, "up", "down"),
         updown23 = ifelse(Compensated < Delayed, "up", "down"))


# combine stats and prepared plotting df####
mrna_rep_medians <- full_join(mrna_rep_medians, stats) %>% 
  mutate(color1 = ifelse(Main < 0.05 & BvsC < 0.05, updown12, "none"),
         color2 = ifelse(Main < 0.05 & CvsD < 0.05, updown23, "none")) %>% 
  mutate(color1 = factor(color1, levels = c("down", "none", "up")),
         color2 = factor(color2, levels = c("down", "none", "up")))
  



# plot ####
temp <- mrna_rep_winxiqr %>% spread("Time", "Count")

ggplot(mrna_rep_medians)+
  geom_point(data = temp, aes(x = 0.5, y = Baseline), shape = "-")+
  geom_point(data = temp, aes(x = 1.5, y = Compensated), shape = "-")+
  geom_point(data = temp, aes(x = 2.5, y = Delayed), shape = "-")+

  geom_segment(aes(x = 0, xend = 1, y = Baseline, yend = Baseline), size = 1)+
  geom_segment(aes(x = 1, xend = 2, y = Compensated, yend = Compensated, 
                   color = color1), size = 1)+
  geom_segment(aes(x = 2, xend = 3, y = Delayed, yend = Delayed, 
                   color = color2), size = 1)+
  
  geom_segment(aes(x = 1, xend = 1, y = Baseline, yend = Compensated, 
                   color = color1), arrow = arrow(length = unit(0.03, "npc")), size = 1)+
  geom_segment(aes(x = 2, xend = 2, y = Compensated, yend = Delayed, 
                   color = color2), arrow = arrow(length = unit(0.03, "npc")), size = 1)+
  scale_color_manual(values = c("red", "gray", "green"))+
  theme_clean()+
  theme(legend.position = "")+
  facet_grid(Source ~ mRNA)


# ggplot(filter(mrna_rep_medians, mRNA != "inx5"))+
#   geom_point(data = filter(gather(mrna_rep_winxiqr, "mRNA", "Count", 
#                                   names(select(mrna_rep_winxiqr, -Source, -Time, -uid))
#   ), 
#   Time == "Baseline"), 
#   aes(x = 0.5, y = Count), shape = "-")+
#   geom_point(data = filter(gather(mrna_rep_winxiqr, "mRNA", "Count", 
#                                   names(select(mrna_rep_winxiqr, -Source, -Time, -uid))
#   ), 
#   Time == "Compensated"), 
#   aes(x = 1.5, y = Count), shape = "-")+
#   geom_point(data = filter(gather(mrna_rep_winxiqr, "mRNA", "Count", 
#                                   names(select(mrna_rep_winxiqr, -Source, -Time, -uid))
#   ), 
#   Time == "Delayed"), 
#   aes(x = 2.5, y = Count), shape = "-")+
#   geom_segment(aes(x = 0, xend = 1, y = Baseline, yend = Baseline), size = 1)+
#   geom_segment(aes(x = 1, xend = 2, y = Compensated, yend = Compensated, 
#                    color = color1), size = 1)+
#   geom_segment(aes(x = 2, xend = 3, y = Delayed, yend = Delayed, 
#                    color = color2), size = 1)+
#   
#   geom_segment(aes(x = 1, xend = 1, y = Baseline, yend = Compensated, 
#                    color = color1), arrow = arrow(length = unit(0.03, "npc")), size = 1)+
#   geom_segment(aes(x = 2, xend = 2, y = Compensated, yend = Delayed, 
#                    color = color2), arrow = arrow(length = unit(0.03, "npc")), size = 1)+
#   scale_color_manual(values = c("red", "gray", "green"))+
#   theme_clean()+
#   theme(legend.position = "")+
#   facet_grid(Source ~ mRNA)
# # facet_wrap(Source ~ mRNA, scales = "free_y")
```

How similar are the results?
```{r}

mrna_rep_medians


```




# Working Notes
Paper Overview:
Short term changes fail longterm
Part 1. Demonstration that conditions can change mRNA relationships
# Contrast mrna with Brian's Data
compare brian/daniel TEA/baseline groups
```{r eval=FALSE}
list_for_pca <- list(
  mrna_bd_winxiqr[mrna_bd_winxiqr$Group == "Brian_None_Baseline", names(mrna_bd_winxiqr)[!(names(mrna_bd_winxiqr) %in% c("Group", "uid"))]],
  mrna_bd_winxiqr[mrna_bd_winxiqr$Group == "Daniel_None_Baseline", names(mrna_bd_winxiqr)[!(names(mrna_bd_winxiqr) %in% c("Group", "uid"))]],
    mrna_bd_winxiqr[mrna_bd_winxiqr$Group == "Brian_TEA_Compensated", names(mrna_bd_winxiqr)[!(names(mrna_bd_winxiqr) %in% c("Group", "uid"))]],
  mrna_bd_winxiqr[mrna_bd_winxiqr$Group == "Daniel_TEA_Compensated", names(mrna_bd_winxiqr)[!(names(mrna_bd_winxiqr) %in% c("Group", "uid"))]],
    mrna_bd_winxiqr[mrna_bd_winxiqr$Group == "Brian_TEA_Delayed", names(mrna_bd_winxiqr)[!(names(mrna_bd_winxiqr) %in% c("Group", "uid"))]],
  mrna_bd_winxiqr[mrna_bd_winxiqr$Group == "Daniel_TEA_Delayed", names(mrna_bd_winxiqr)[!(names(mrna_bd_winxiqr) %in% c("Group", "uid"))]]
)

pca_summary_descriptions <- map(list_for_pca, function(df){
  mk_pca_multi_plt(input.df = df,
                   scree.max.y = 100)
})


{pca_summary_descriptions[[1]]$scree | pca_summary_descriptions[[3]]$scree | pca_summary_descriptions[[5]]$scree}/
{pca_summary_descriptions[[2]]$scree | pca_summary_descriptions[[4]]$scree | pca_summary_descriptions[[6]]$scree}

ggsave(plot = last_plot(),         filename = here("officer_output", "ContrastSource_PCA_Time_Scree.tiff"),        width = 11.5, height = 4.76)

{pca_summary_descriptions[[1]]$biplt | pca_summary_descriptions[[3]]$biplt | pca_summary_descriptions[[5]]$biplt}/
  {pca_summary_descriptions[[2]]$biplt | pca_summary_descriptions[[4]]$biplt | pca_summary_descriptions[[6]]$biplt}

ggsave(plot = last_plot(),         filename = here("officer_output", "ContrastSource_PCA_Time_biplt.tiff"),        width = 11.5, height = 4.76)
```
dendrogram plot method 1
```{r eval=FALSE}
#FIXME

cluster %>% 
  as.dendrogram() %>% 
  set("branches_k_color", k = 3, value = RColorBrewer::brewer.pal(3, "Set1")) %>%
  plot()

# plot(cluster, hang = -1, main = "Cluster dendogram with AU/BP values (%) Raw Data")

# c(bottom, left, top, right)
# tiff(file=here("officer_output", "ContrastSource_hclust.tiff"),      width=7.96, height=6.68, units="in", res=100) 

par(mar=c(4,2,2,1))
cluster %>% 
  as.dendrogram() %>% 
  set("labels_col", 
      value = c("#a6cee3", "#1f78b4", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00"),
      k = 6) %>%
  set("branches_k_color", 
      value = c("#a6cee3", "#1f78b4", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00"),       k = 6) %>% 
plot()

my_colors <- case_when(mrna_bd_winxiqr$Group == "Brian_None_Baseline" ~ "#fdd49e",
          mrna_bd_winxiqr$Group == "Brian_TEA_Compensated" ~ "#fc8d59",
          mrna_bd_winxiqr$Group == "Brian_TEA_Delayed" ~ "#b30000",
          mrna_bd_winxiqr$Group == "Daniel_None_Baseline" ~ "#c7e9b4",
          mrna_bd_winxiqr$Group == "Daniel_TEA_Compensated" ~ "#41b6c4",
          mrna_bd_winxiqr$Group == "Daniel_TEA_Delayed" ~ "#253494")

colored_bars(colors = my_colors, dend = as.dendrogram(cluster), rowLabels = " Groups")



dev.off()

```
#


scatterplots
```{r eval=FALSE}
#TODO ggscatmat is plotting points over the cors

# mrna_bd_scatter <- map(unique(mrna_bd_winxiqr$Group), function(group){
#   temp <- select(mrna_bd_winxiqr[mrna_bd_winxiqr$Group == group, ], -Group, -uid)
#   GGally::ggscatmat(temp)
# })
# 
# mrna_bd_scatter[[1]]
# mrna_bd_scatter[[2]]
# library(GGally)
# ggscatmat(mtcars)
# 
# pairs(select(mrna_bd_winxiqr[mrna_bd_winxiqr$Group == group, ], -Group, -uid))
```






Compare changes
```{r eval=FALSE}
# refresh NO median interpolation
mrna_bd_winxiqr <- do.call(rbind, mrna_bd_winxiqr_list)

mrna_bd_winxiqr_to_test <- mrna_bd_winxiqr %>% separate(Group, c("Source", "Pharm", "Time")) %>% distinct()

temp_list <- map(
  names(mrna_bd_winxiqr)[!(names(mrna_bd_winxiqr) %in% c("Group", "uid"))], function(temp_col){
    print(temp_col)
    
    temp <- mrna_bd_winxiqr_to_test[!is.na(mrna_bd_winxiqr_to_test[[temp_col]]), ]
    
    temp_b <- temp[temp$Source == "Brian", ]
    temp_d <- temp[temp$Source == "Daniel", ]

    stat_list <- map(list(temp_b, temp_d), function(temp_in){
      temp_shuffle <- temp_in
    
      
      fm <- lm(as.formula(paste0(temp_col, " ~ Time")), data = temp_shuffle)
      
      fm_hsd <- agricolae::HSD.test(fm, trt = "Time") 
      fm_hsd <- fm_hsd$group
      
      fm_hsd$Condition <- rownames(fm_hsd)
      
      

      resample_array <- map(1:1000, function(i){
        temp_shuffle$Time <- sample(temp_shuffle$Time, replace = F)
        fm <- lm(as.formula(paste0(temp_col, " ~ Time")), data = temp_shuffle)      
        return(car::Anova(fm)[1,3])
      }) %>% unlist()

      return(list(
        Source = unique(temp_shuffle$Source),
        dv = temp_col,
        p = car::Anova(fm)[1,4],
        ep = mean(resample_array >= car::Anova(fm)[1,3]),
        hsd_groups = fm_hsd,
        fm = fm))
    })
    
    return(stat_list)  
  })

backup <- temp_list
```

```{r eval=FALSE}
temp_list <- backup
temp_list <- temp_list %>% transpose()

temp_list_1 <- temp_list[[1]] %>% transpose()
temp_list_2 <- temp_list[[2]] %>% transpose()


fm_overview_table <- data.frame(Source = c(unlist(temp_list_1[[1]]), unlist(temp_list_2[[1]])),
                                dv  = c(unlist(temp_list_1[[2]]), unlist(temp_list_2[[2]])),
                                p = c(unlist(temp_list_1[[3]]), unlist(temp_list_2[[3]])),
                                ep = c(unlist(temp_list_1[[4]]), unlist(temp_list_2[[4]]))
                                )

# work up post hoc stats
temp_list_hsd_1 <- map(seq_along(temp_list_1[[5]]), function(i){
      temp_list_1[[5]][[i]] %>% 
      gather("dv", "Estimate", names(temp_list_1[[5]][[i]])[1]) %>% 
      pivot_wider(names_from = "Condition", values_from = c("groups", "Estimate") ) %>% 
      mutate_all(as.character)
  
})

temp_list_hsd_2 <- map(seq_along(temp_list_2[[5]]), function(i){
      temp_list_2[[5]][[i]] %>% 
      gather("dv", "Estimate", names(temp_list_2[[5]][[i]])[1]) %>% 
      pivot_wider(names_from = "Condition", values_from = c("groups", "Estimate") ) %>% 
      mutate_all(as.character)
  
}) 


fm_overview_hsd_1 <- do.call(rbind, temp_list_hsd_1)
fm_overview_hsd_2 <- do.call(rbind, temp_list_hsd_2)
fm_overview_hsd <- rbind(fm_overview_hsd_1, fm_overview_hsd_2) 

fm_overview_table <- cbind(fm_overview_table, fm_overview_hsd)
fm_overview_table <- fm_overview_table[, -5] #rm redundant dv col

fm_overview_table <- left_join(fm_overview_table, 
                               rename(mRNAInfo[, c("Family", "RGeneName")], dv = RGeneName))

# add additional cols
fm_overview_table$fdr <- c(p.adjust(fm_overview_table[fm_overview_table$Source == "Brian", "ep"], method = "fdr"),
                           p.adjust(fm_overview_table[fm_overview_table$Source == "Daniel", "ep"], method = "fdr"))

fm_overview_table[fm_overview_table$Source == "Daniel", "ep"]

fm_overview_table <- fm_overview_table %>% 
  mutate(Estimate_Baseline = as.numeric(Estimate_Baseline),
         Estimate_Compensated = as.numeric(Estimate_Compensated),
         Estimate_Delayed = as.numeric(Estimate_Delayed)) %>% 
  mutate(p = round(p, digits = 4),
         ep = round(ep, digits = 4),
         fdr = round(fdr, digits = 4),
         Estimate_Baseline = round(Estimate_Baseline, digits = 4),
         Estimate_Compensated = round(Estimate_Compensated, digits = 4),
         Estimate_Delayed = round(Estimate_Delayed, digits = 4)) %>% 
  mutate(stars = case_when(fdr > 0.10               ~ "",
                           fdr < 0.10 & fdr > 0.05  ~ ".",
                           fdr < 0.05 & fdr > 0.01  ~ "*",
                           fdr < 0.01 & fdr > 0.001 ~ "**",
                           fdr < 0.001              ~ "***"
  ))

fm_overview_table <- fm_overview_table %>% arrange(Family, dv, Source)

M_ft <-flextable(fm_overview_table,
                 col_keys = c("Family", "dv", "Source",
                              "p", "ep",
                              "fdr", 
                              "stars", "Estimate_Baseline", "Estimate_Compensated", "Estimate_Delayed"))

M_ft <- theme_vanilla(M_ft)
M_ft <- merge_v(M_ft, j = c("Family", "dv") )
# M_ft <- color(M_ft, ~ fdr < 0.05, ~ stars, color = "red")
M_ft <- bold(M_ft, ~ fdr <= 0.05, ~ Source, bold = TRUE)
M_ft <- bold(M_ft, ~ fdr <= 0.05, ~ dv, bold = TRUE)
M_ft <- bold(M_ft, ~ p   <= 0.05, ~ p, bold = TRUE)
M_ft <- bold(M_ft, ~ ep  <= 0.05, ~ ep, bold = TRUE)
M_ft <- bold(M_ft, ~ fdr <= 0.05, ~ fdr, bold = TRUE)
M_ft <- bold(M_ft, ~ fdr <= 0.05, ~ stars, bold = TRUE)

# get the groupings without showing the columns. 

color_a = "#ffeda0"
color_ab= "#feb24c"
color_b = "#f03b20"
color_c = "#2b8cbe"

M_ft <- bg(M_ft, ~ groups_Baseline == "a", ~ Estimate_Baseline, bg = color_a)
M_ft <- bg(M_ft, ~ groups_Baseline == "ab",~ Estimate_Baseline, bg = color_ab)
M_ft <- bg(M_ft, ~ groups_Baseline == "b", ~ Estimate_Baseline, bg = color_b)
M_ft <- bg(M_ft, ~ groups_Baseline == "c", ~ Estimate_Baseline, bg = color_c)

M_ft <- bg(M_ft, ~ groups_Compensated == "a", ~ Estimate_Compensated, bg = color_a)
M_ft <- bg(M_ft, ~ groups_Compensated == "ab",~ Estimate_Compensated, bg = color_ab)
M_ft <- bg(M_ft, ~ groups_Compensated == "b", ~ Estimate_Compensated, bg = color_b)
M_ft <- bg(M_ft, ~ groups_Compensated == "c", ~ Estimate_Compensated, bg = color_c)

M_ft <- bg(M_ft, ~ groups_Delayed == "a", ~ Estimate_Delayed, bg = color_a)
M_ft <- bg(M_ft, ~ groups_Delayed == "ab",~ Estimate_Delayed, bg = color_ab)
M_ft <- bg(M_ft, ~ groups_Delayed == "b", ~ Estimate_Delayed, bg = color_b)
M_ft <- bg(M_ft, ~ groups_Delayed == "c", ~ Estimate_Delayed, bg = color_c)


M_ft <- bg(M_ft, ~ fdr > 0.05, ~ Estimate_Baseline, bg = "White")
M_ft <- bg(M_ft, ~ fdr > 0.05, ~ Estimate_Compensated, bg = "White")
M_ft <- bg(M_ft, ~ fdr > 0.05, ~ Estimate_Delayed, bg = "White")


M_ft <- set_header_labels(M_ft, 
                          dv = "mRNA",
                          stars = "",
                          Estimate_Baseline = "Baseline", 
                          Estimate_Compensated = "Compensated", 
                          Estimate_Delayed = "Delayed" )

M_ft <- autofit(M_ft)
M_ft

pptx_file <- "./officer_output/ContrastTEAPath.pptx"
save_as_pptx("my table" = M_ft, path = pptx_file)




# fm_overview_table %>% 
#   ggplot(aes(x = ep))+
#   geom_histogram(binwidth = 0.025)+
#   geom_vline(xintercept = 0.05)
```




Part 1a. Are there changes? 

Part 1b. Are the conditions separable?

Part 2. Deep dive on one condition. (TEA) 

Part 2a. 





# Primary Questions
## mk plots
What happens at the individual cell level?

plots for stg meeting
membrane
```{r eval=FALSE}
plt_membrane <- M_all %>% 
  select(Condition, Experiment, Cell, r11, r1, Ihtk.0, Ia.0) %>% 
  group_by(Condition, Experiment, Cell) %>% 
  mutate_all(median, na.rm = T) %>% 
  ungroup() %>% 
  distinct() %>% 
  mutate(Condition = case_when(Condition == "Baseline"    ~ "0h",
                               Condition == "Compensated" ~ "1h", 
                               Condition == "Delayed" ~ "24h"
                               ))
  


plot_univariate_decorated_0 <- function(temp = plt_membrane,
                                        yvar = "Ihtk.0",
                                        new.y = "",
                                        new.title = ""){
  # allow for customizaiton of y axis
  if (typeof(new.title) == "character"){
    if(new.y == ""){
      new.title <- yvar
    } else if (typeof(new.y) == "character" | typeof(new.y) == "expression"){
      new.title <- new.title
    } else {
      warning("new.y not supported type")
      new.title <- yvar
    }
  }
  
  names(temp)[names(temp) == yvar] <- "yvar"
  
  temp_bands <- temp %>% 
    group_by(Condition) %>% 
    summarise(
      q10 = quantile(yvar, probs = 0.1, na.rm = T),
      q25 = quantile(yvar, probs = 0.25, na.rm = T),
      # q45 = quantile(yvar, probs = 0.45, na.rm = T),
      q50 = quantile(yvar, probs = 0.5, na.rm = T),
      # q55 = quantile(yvar, probs = 0.55, na.rm = T),
      q75 = quantile(yvar, probs = 0.75, na.rm = T),
      q90 = quantile(yvar, probs = 0.9, na.rm = T),
    ) %>% 
    mutate(outlier_up = q50 + 1.5*(q75 - q25),
           outlier_down = q50 - 1.5*(q75 - q25))
  
  temp <- full_join(temp, temp_bands)
  
  temp_plt <- ggplot(data = temp, aes(x = Condition, y = yvar))+
    # geom_ribbon(aes(x = Condition, ymin = q10, ymax = q90, group = 1), color = "lightgray", fill = "cornflowerblue", alpha = 0.3)+
    geom_ribbon(aes(x = Condition, ymin = q25, ymax = q75, group = 1), color = "darkgray", fill = "cornflowerblue", alpha = 0.3)+
    # geom_ribbon(aes(x = Condition, ymin = q45, ymax = q55, group = 1), color = "black", fill = "cornflowerblue", alpha = 0.3)+
    geom_line(aes(x = Condition, y = q50, group = 1), linetype = "dashed", color = "blue")+
    
    geom_line(aes(x = Condition, y = outlier_up, group = 1), linetype = "dashed", color = "black")+
    geom_line(aes(x = Condition, y = outlier_down, group = 1), linetype = "dashed", color = "black")+
    
    geom_point(aes(x = Condition, y = q50), color = "lightgray", size = 4)+
    geom_point(aes(x = Condition, y = q50), color = "black", size = 4, shape = 1)+
    geom_point(alpha = 0.5)+
    labs(title = new.title, y=new.y, x = "")
  
  return(temp_plt)
}


membrane_dvs_plt <- c("r11", "r1", "Ihtk.0", "Ia.0")
new.y_vector <- c(expression(M~Omega), expression(M~Omega), "nA", "nA" )
new.title_vector     <- c(expression(R[In]), 
                          expression(R[Membrane]), 
                          expression(I[HTK] ~ Intercept), 
                          expression(I[A] ~ Intercept))
membrane_plts <- map(seq_along(membrane_dvs_plt), function(i){plot_univariate_decorated_0(
  temp = ungroup(plt_membrane), 
  yvar = membrane_dvs_plt[i],
  new.y = new.y_vector[i],
  new.title = new.title_vector[i])})

membrane_plts[[1]]

membrane_plts[[2]]

membrane_plts[[3]]

membrane_plts[[4]]

walk(seq_along(membrane_dvs_plt), function(i){
  ggsave(paste0(membrane_dvs_plt[i],".tiff"), 
         plot = membrane_plts[[i]], 
         path = here("officer_output"), 
         width = 11.5/4, height = 4.76)  
})
```

excitability
```{r eval=FALSE}
plt_epsp <- M_all[, c("Condition", "Experiment", "Cell", epsp_cols)] %>% 
  group_by(Condition, Experiment, Cell) %>% 
  mutate_all(median, na.rm = T) %>% 
  ungroup() %>% 
  distinct() %>% 
  mutate(Condition = case_when(Condition == "Baseline"    ~ "0h",
                               Condition == "Compensated" ~ "1h", 
                               Condition == "Delayed" ~ "24h"
                               ))

epsp_dvs_plt <- c("Cor", 
                  "Min.V_Obs", "Max.Amplitude_Obs", "Max.Amplitude_Sim", 
                  "AUC_Obs", "AUC_Sim", 
                  "Max.Amplitude_Delta", "AUC_Delta")
new.y_vector <- c(" ", #FIXME if empty then title doesn't update
                  "mV", "mV", "mV", 
                  "mV/Sec", "mV/Sec",
                  "mV", "mV/Sec")
new.title_vector <- c("Correlation Coefficient", 
                      "Observed Baseline", "Observed Amplitude", "Simulated Amplitude", 
                      "Observed AUC", "Simulated AUC",
                      "Difference Amplitude", "Difference AUC")

epsp_plts <- map(seq_along(epsp_cols), function(i){plot_univariate_decorated_0(
  temp = ungroup(plt_epsp), 
  yvar = epsp_cols[i],
  new.y = new.y_vector[i],
  new.title = new.title_vector[i] )})


epsp_plts[[1]]


walk(seq_along(epsp_dvs_plt), function(i){
  ggsave(paste0(epsp_dvs_plt[i],".tiff"), 
         plot = epsp_plts[[i]], 
         path = here("officer_output"), 
         width = 11.5/4, height = 4.76)  
})
```


mrna
univariate change over time -- bend quartile
```{r eval=FALSE}
plt_membrane <- M_all[, c("Condition", "Experiment", "Cell", mrna_cols)] %>% 
  group_by(Condition, Experiment, Cell) %>% 
  mutate_all(median, na.rm = T) %>% 
  ungroup() %>% 
  distinct() %>% 
  mutate(Condition = case_when(Condition == "Baseline"    ~ "0h",
                               Condition == "Compensated" ~ "1h", 
                               Condition == "Delayed" ~ "24h"
                               ))


mrna_plts <- map(seq_along(mrna_cols), function(i){plot_univariate_decorated_0(
  temp = ungroup(plt_membrane), 
  yvar = mrna_cols[i],
  new.y = "Count",
  new.title = mrna_cols[i] )})


mrna_plts[[1]]+theme(plot.title = element_text(face="italic"))


walk(seq_along(mrna_cols), function(i){
  ggsave(paste0(mrna_cols[i],".tiff"), 
         plot = mrna_plts[[i]]+theme(plot.title = element_text(face="italic")), 
         path = here("officer_output"), 
         width = 11.5/4, height = 4.76)  
})
```




univariate change over time -- boxplots
```{r eval=FALSE}
# devtools::install_github("teunbrand/ggh4x")
library(ggh4x)

plt_mrna_long <- plt_mrna %>%
  gather(mrna, count, mrna_cols) %>% 
  filter(!is.na(count))
  # filter(mrna %in% c("bkkca", "shal")) %>% 
  
return_nested_mrna_plt <- function(temp = plt_mrna_long){
  ggplot(temp, aes(mrna, count))+
    geom_boxplot(aes(fill = Condition))+
    geom_point(position = position_jitter(width = 0.05), #size =3,  
               alpha = 0.7)+  
    theme(axis.text.x=element_blank(),
          legend.position = "")+ # writes over mrna labels so they only show up in the facet
    labs(x = "")+
    facet_nested(~ mrna + Condition, scales = "free_x", switch = "x")
}


# return_nested_mrna_plt(temp = filter(plt_mrna_long, 
#                                      mrna %in% unlist(mRNAInfo[mRNAInfo$Class == "Channel", "RGeneName"])
#                                      ))


return_nested_mrna_plt(temp = filter(plt_mrna_long, 
                                     mrna %in% unlist(mRNAInfo[mRNAInfo$Family == "Voltage-dependent K+ Channel", "RGeneName"])
                                     ))

return_nested_mrna_plt(temp = filter(plt_mrna_long, 
                                     mrna %in% unlist(mRNAInfo[mRNAInfo$Family == "Other K+ Channel", "RGeneName"])
                                     ))

return_nested_mrna_plt(temp = filter(plt_mrna_long, 
                                     mrna %in% unlist(mRNAInfo[mRNAInfo$Family == "Ca2+ Channel", "RGeneName"])
                                     ))

# innexins
# TODO flix axis to right, bind
return_nested_mrna_plt(temp = filter(plt_mrna_long, mrna %in% c("inx1", "inx2", "inx3", "inx4")))
return_nested_mrna_plt(temp = filter(plt_mrna_long, mrna %in% c("inx5")))
return_nested_mrna_plt(temp = filter(plt_mrna_long, mrna %in% c("inx5")))+scale_y_log10()
```

mrna -- spagetti plot
```{r eval=FALSE}
plt_mrna_spagetti <- right_join(
  rename(
    select(mRNAInfo, Family, RGeneName), 
    mrna = RGeneName), 
  plt_mrna_long) %>% 
  select(-Cell, -Experiment) %>% 
  group_by(Condition, mrna) %>% 
  mutate(count = median(count, na.rm = T)) %>% 
  distinct() %>% 
  ungroup() %>% 
  mutate(Baseline = ifelse(Condition == "Baseline", count, NA))%>% 
  group_by(mrna) %>% 
  mutate(Baseline = median(Baseline, na.rm = T)) %>% 
  ungroup() %>% 
  mutate(Delta = Baseline - count)


plt_mrna_spagetti %>% 
  filter(mrna %in% c("inx1", "inx2", "inx3", "inx4", "inx5")) %>% 
  ggplot(aes(x = Condition, y = count, group = mrna))+
  geom_line()
  
plt_mrna_spagetti %>% 
  filter(!(mrna %in% c("inx1", "inx2", "inx3", "inx4", "inx5"))) %>% 
  ggplot(aes(x = Condition, y = count, group = mrna, color = Family))+
  geom_line()+
  facet_wrap(.~Family)
  
# deltas
plt_mrna_spagetti %>% 
  filter(!(mrna %in% c("inx1", "inx2", "inx3", "inx4", "inx5"))) %>% 
  ggplot(aes(x = Condition, y = Delta, group = mrna, color = Family))+
  geom_line()+
  facet_wrap(.~Family)+
  theme(legend.position = "")
```


What happens at the network level?
```{r eval=FALSE}
#FIXME
plt_tevc <- M_all_outliers %>% 
  select(Condition, Experiment, ig.3_4, ig.3_5, ig.4_5) %>% 
  distinct() %>% 
  gather("ElectricalSynapse", "ig", c("ig.3_4", "ig.3_5", "ig.4_5")) %>% 
  filter(!is.na(ig))  %>% 
  mutate(Condition = case_when(Condition == "Baseline"    ~ "0h",
                               Condition == "Compensated" ~ "1h", 
                               Condition == "Delayed" ~ "24h"
                               ))


plt_1.1 <- plot_univariate_decorated_0(
  temp = ungroup(filter(plt_tevc, ElectricalSynapse == "ig.3_4")), 
  yvar = "ig",
  new.y = "nA/mV",
  new.title = expression(I[g]~LC[3] %<->% LC[4]))+
  coord_cartesian(ylim = c(0, 0.1))

plt_1.2 <- plot_univariate_decorated_0(
  temp = ungroup(filter(plt_tevc, ElectricalSynapse == "ig.3_5")), 
  yvar = "ig",
  new.y = "nA/mV",
  new.title = expression(I[g]~LC[3] %<->% LC[5]))+
  coord_cartesian(ylim = c(0, 0.1))

plt_1.3 <- plot_univariate_decorated_0(
  temp = ungroup(filter(plt_tevc, ElectricalSynapse == "ig.4_5")), 
  yvar = "ig",
  new.y = "nA/mV",
  new.title = expression(I[g]~LC[4] %<->% LC[5]))+
  coord_cartesian(ylim = c(0, 0.5))+
  scale_y_continuous(position = "right")


library(patchwork)
plt_1.1 + plt_1.2 + plt_1.3+ plot_layout(widths = c(1, 1, 1) )


ggsave(paste0("ig_lc34.tiff"), 
         plot = plt_1.1, 
         path = here("officer_output"), 
         width = 11.5/4, height = 4.76)  
ggsave(paste0("ig_lc35.tiff"), 
         plot = plt_1.2, 
         path = here("officer_output"), 
         width = 11.5/4, height = 4.76)  
ggsave(paste0("ig_lc45.tiff"), 
         plot = plt_1.3, 
         path = here("officer_output"), 
         width = 11.5/4, height = 4.76)  



#### ####

plt_tecc <- M_all_outliers %>% 
  select(Condition, Experiment, cc.3_4, cc.3_5, cc.4_3, cc.4_5, cc.5_3, cc.5_4) %>% 
  group_by(Condition, Experiment) %>% 
  mutate_all(median, na.rm = T) %>% 
  ungroup() %>% 
  distinct()  %>% 
  mutate(Condition = case_when(Condition == "Baseline"    ~ "0h",
                               Condition == "Compensated" ~ "1h", 
                               Condition == "Delayed" ~ "24h"
                               ))

cowplot::plot_grid(plotlist = list(
  plot_univariate_decorated_0(
    temp = plt_tecc, 
    yvar = "cc.3_4",
    new.y = "Coupling Coefficient",
    new.title = expression(LC[3] %->% LC[4]))+
    coord_cartesian(ylim = c(0, 1)),
  
  plot_univariate_decorated_0(
    temp = plt_tecc, 
    yvar = "cc.3_5",
    new.y = "Coupling Coefficient",
    new.title = expression(LC[3] %->% LC[5]))+
    coord_cartesian(ylim = c(0, 1)),
  
  plot_univariate_decorated_0(
    temp = plt_tecc, 
    yvar = "cc.4_3",
    new.y = "Coupling Coefficient",
    new.title = expression(LC[4] %->% LC[3]))+
    coord_cartesian(ylim = c(0, 1)),
  
  plot_univariate_decorated_0(
    temp = plt_tecc, 
    yvar = "cc.4_5",
    new.y = "Coupling Coefficient",
    new.title = expression(LC[4] %->% LC[5]))+
    coord_cartesian(ylim = c(0, 1)),
  
  plot_univariate_decorated_0(
    temp = plt_tecc, 
    yvar = "cc.5_3",
    new.y = "Coupling Coefficient",
    new.title = expression(LC[5] %->% LC[4]))+
    coord_cartesian(ylim = c(0, 1)),
  
  plot_univariate_decorated_0(
    temp = plt_tecc, 
    yvar = "cc.5_4",
    new.y = "Coupling Coefficient",
    new.title = expression(LC[5] %->% LC[4]))+
    coord_cartesian(ylim = c(0, 1))
))



#### ####

triangle_lower_df <- data.frame(
  id    = c("b", "b", "b"),
  value = c("2", "2", "2"),
  x     = c(0, 1, 1),
  y     = c(0, 1, 0)
)

triangle_upper_df <- data.frame(
  id    = c("a", "a", "a"),
  value = c("1", "1", "1"),
  x     = c(0, 1, 0),
  y     = c(0, 1, 1)
)


plt_2.1 <- plt_tecc %>% 
  ggplot(aes(cc.3_4, cc.4_3))+
  geom_polygon(data = triangle_upper_df, aes(x = x, y = y, group = id), fill = "#e41a1c")+
  geom_polygon(data = triangle_lower_df, aes(x = x, y = y, group = id), fill = "#377eb8")+
  geom_abline(slope = 1, intercept = 0, linetype = "dashed")+
  geom_point()+
  facet_grid(.~Condition)

plt_2.2 <- plt_tecc %>% 
  ggplot(aes(cc.3_5, cc.5_3))+
  geom_polygon(data = triangle_upper_df, aes(x = x, y = y, group = id), fill = "#e41a1c")+
  geom_polygon(data = triangle_lower_df, aes(x = x, y = y, group = id), fill = "#4daf4a")+
  geom_point()+
  facet_grid(.~Condition)

plt_2.3 <- plt_tecc %>% 
  ggplot(aes(cc.4_5, cc.5_4))+
  geom_polygon(data = triangle_upper_df, aes(x = x, y = y, group = id), fill = "#377eb8")+
  geom_polygon(data = triangle_lower_df, aes(x = x, y = y, group = id), fill = "#4daf4a")+
  geom_point()+
  facet_grid(.~Condition)

plt_2.1 / plt_2.2 / plt_2.3
```

what happens at the level of output (excitability)? 

## mk table
run anovas
```{r eval=FALSE}
# temp <- M_all %>% 
#   select(Condition, Experiment, Cell,  Ihtk.0) %>% 
#   group_by(Condition, Experiment, Cell) %>% 
#   mutate(Ihtk.0 = median(Ihtk.0, na.rm = T)) %>% 
#   distinct() %>% 
#   ungroup()
# 
# temp_bands <- temp %>% group_by(Condition) %>% summarise(
#   q10 = quantile(Ihtk.0, probs = 0.1, na.rm = T),
#   q25 = quantile(Ihtk.0, probs = 0.25, na.rm = T),
#   q45 = quantile(Ihtk.0, probs = 0.45, na.rm = T),
#   q50 = quantile(Ihtk.0, probs = 0.5, na.rm = T),
#   q55 = quantile(Ihtk.0, probs = 0.55, na.rm = T),
#   q75 = quantile(Ihtk.0, probs = 0.75, na.rm = T),
#   q90 = quantile(Ihtk.0, probs = 0.9, na.rm = T),
#   )
# 
# temp <- full_join(temp, temp_bands)
# 
# ggplot(data = temp, aes(x = Condition, y = Ihtk.0))+
#   geom_ribbon(aes(x = Condition, ymin = q10, ymax = q90, group = 1), color = "lightgray", fill = "cornflowerblue", alpha = 0.3)+
#   geom_ribbon(aes(x = Condition, ymin = q25, ymax = q75, group = 1), color = "darkgray", fill = "cornflowerblue", alpha = 0.3)+
#   # geom_ribbon(aes(x = Condition, ymin = q45, ymax = q55, group = 1), color = "black", fill = "cornflowerblue", alpha = 0.3)+
#   geom_line(aes(x = Condition, y = q50, group = 1), linetype = "dashed", color = "blue")+
#   geom_point(aes(x = Condition, y = q50), color = "lightgray", size = 4)+
#   geom_point(aes(x = Condition, y = q50), color = "black", size = 4, shape = 1)+
#   geom_point(alpha = 0.5)

# Make table ----
# c(tecc_cols, tevc_cols, epsp_cols, ionic_cols, mrna_cols)
# 
# temp_col = "Ihtk.0"

#TODO figure out what to do with the epsp cols
tictoc::tic()
temp_list <- map(
  c(tecc_cols, tevc_cols, epsp_cols, ionic_cols, mrna_cols), function(temp_col){
    print(temp_col)
    
    temp <- M_all[, c("Condition", "Experiment", "Cell", temp_col)] %>% distinct()
    
    # Identify outliers for each group
    temp_b <- temp[temp$Condition == "Baseline", ]
    temp_c <- temp[temp$Condition == "Compensated", ]
    temp_d <- temp[temp$Condition == "Delayed", ]
    
    temp_b <- temp_b[win_x_iqr(temp_b[[temp_col]], multiplier = 1.5), ]
    temp_c <- temp_c[win_x_iqr(temp_c[[temp_col]], multiplier = 1.5), ]
    temp_d <- temp_d[win_x_iqr(temp_d[[temp_col]], multiplier = 1.5), ]
    
    temp <- rbind(temp_b, temp_c) %>% rbind(temp_d)
    
    # temp <- temp[win_x_iqr(temp[[temp_col]], multiplier = 1.5), ]
    temp <- temp[!is.na(temp[[temp_col]]), ]
    
    # make sure we don't have pseudoreplicates for network measurements
    if (temp_col %in% c("ig.3_4", "ig.3_5", "ig.4_5")){
      temp <- temp %>% 
        select(-Cell) %>% 
        group_by(Condition, Experiment) %>% 
        mutate_all(median, na.rm = T) %>% 
        distinct()
    }
    
    
    if(nrow(temp) < 10){
      
      return(list(
        dv = temp_col,
        p = NA,
        ep = NA,
        hsd_groups = data.frame(dv = c(NA, NA, NA), 
                                groups = c(NA, NA, NA), 
                                Condition = c(NA, NA, NA)
        ),
        fm = NA))
      
    } else {
      
      
      temp_shuffle <- temp
      resample_array <- map(1:1000, function(i){
        temp_shuffle$Condition <- sample(temp_shuffle$Condition, replace = F)
        fm <- lm(as.formula(paste0(temp_col, " ~ Condition")), data = temp_shuffle)      
        return(car::Anova(fm)[1,3])
      }) %>% unlist()

      
      fm <- lm(as.formula(paste0(temp_col, " ~ Condition")), data = temp)
      
      fm_hsd <- agricolae::HSD.test(fm, trt = "Condition") 
      fm_hsd <- fm_hsd$group
      
      fm_hsd$Condition <- rownames(fm_hsd)
      
      
      
      return(list(
        dv = temp_col,
        p = car::Anova(fm)[1,4],
        ep = mean(resample_array >= car::Anova(fm)[1,3]),
        hsd_groups = fm_hsd,
        fm = fm))
    }
  })
tictoc::toc()


temp_list <- temp_list %>% transpose()
fm_overview_table <- data.frame(dv = unlist(temp_list[[1]]),
                                p  = unlist(temp_list[[2]]),
                                ep = unlist(temp_list[[3]]))


# work up post hoc stats
temp_list_hsd <- map(seq_along(temp_list[[4]]), function(i){
  if (!is.na(unique(temp_list[[4]][[i]]$groups))){
    temp_list[[4]][[i]] %>% 
      gather("dv", "Estimate", names(temp_list[[4]][[i]])[1]) %>% 
      pivot_wider(names_from = "Condition", values_from = c("groups", "Estimate") ) %>% 
      mutate_all(as.character)
  }
})  

fm_overview_hsd <- do.call(rbind, temp_list_hsd)
```

Make table
```{r eval=FALSE}
fm_overview_table <- full_join(fm_overview_table, fm_overview_hsd)

 
# add groupings
fm_overview_table <- fm_overview_table %>% mutate(Family = case_when(
  dv %in% c("vrest") ~ "Resting Voltage",
  dv %in% c("r11", "r1") ~ "Membrane Resistance",
  dv %in% ionic_cols ~ "Outward Currents",
  dv %in% epsp_cols ~ "Excitability",
  dv %in% c("r12", "rc", "ig", "cc", "ig.3_4", "ig.3_5", "ig.4_5") ~ "Coupling Measures"
))

fm_overview_table <- fm_overview_table %>% 
  mutate(Family = factor(fm_overview_table$Family, levels = c("Membrane Resistance", "Resting Voltage", "Coupling Measures", "Outward Currents", "Excitability"))) %>% 
  arrange(Family) %>% 
  mutate(Family = as.character(Family))

# temp <- rename(mRNAInfo[, c("Family", "RGeneName")], dv = RGeneName)
fm_overview_table <- full_join(fm_overview_table, 
                               rename(mRNAInfo[, c("Family", "RGeneName")], dv = RGeneName, Family2 = Family))

fm_overview_table <- fm_overview_table %>% 
  mutate(Family = ifelse(is.na(Family) & !is.na(Family2), Family2, Family)) %>% 
  select(-Family2) %>% 
  filter(!is.na(p))


# add additional cols
fm_overview_table$fdr <- p.adjust(fm_overview_table$ep, method = "fdr")

fm_overview_table <- fm_overview_table %>% 
  mutate(Estimate_Baseline = as.numeric(Estimate_Baseline),
         Estimate_Compensated = as.numeric(Estimate_Compensated),
         Estimate_Delayed = as.numeric(Estimate_Delayed)) %>% 
  mutate(p = round(p, digits = 4),
         ep = round(ep, digits = 4),
         fdr = round(fdr, digits = 4),
         Estimate_Baseline = round(Estimate_Baseline, digits = 4),
         Estimate_Compensated = round(Estimate_Compensated, digits = 4),
         Estimate_Delayed = round(Estimate_Delayed, digits = 4)) %>% 
  mutate(stars = case_when(fdr > 0.10               ~ "",
                           fdr < 0.10 & fdr > 0.05  ~ ".",
                           fdr < 0.05 & fdr > 0.01  ~ "*",
                           fdr < 0.01 & fdr > 0.001 ~ "**",
                           fdr < 0.001              ~ "***"
  ))


# library(officer)
library(flextable)
M_ft <-flextable(fm_overview_table,
                 col_keys = c("Family", "dv", "p", "ep",
                              "fdr", 
                              "stars", "Estimate_Baseline", "Estimate_Compensated", "Estimate_Delayed"))

M_ft <- theme_vanilla(M_ft)
M_ft <- merge_v(M_ft, j = c("Family") )
# M_ft <- color(M_ft, ~ fdr < 0.05, ~ stars, color = "red")
M_ft <- bold(M_ft, ~ fdr <= 0.05, ~ dv, bold = TRUE)
M_ft <- bold(M_ft, ~ p   <= 0.05, ~ p, bold = TRUE)
M_ft <- bold(M_ft, ~ ep  <= 0.05, ~ ep, bold = TRUE)
M_ft <- bold(M_ft, ~ fdr <= 0.05, ~ fdr, bold = TRUE)
M_ft <- bold(M_ft, ~ fdr <= 0.05, ~ stars, bold = TRUE)

# get the groupings without showing the columns. 

color_a = "#ffeda0"
color_ab= "#feb24c"
color_b = "#f03b20"
color_c = "#2b8cbe"

M_ft <- bg(M_ft, ~ groups_Baseline == "a", ~ Estimate_Baseline, bg = color_a)
M_ft <- bg(M_ft, ~ groups_Baseline == "ab",~ Estimate_Baseline, bg = color_ab)
M_ft <- bg(M_ft, ~ groups_Baseline == "b", ~ Estimate_Baseline, bg = color_b)
M_ft <- bg(M_ft, ~ groups_Baseline == "c", ~ Estimate_Baseline, bg = color_c)

M_ft <- bg(M_ft, ~ groups_Compensated == "a", ~ Estimate_Compensated, bg = color_a)
M_ft <- bg(M_ft, ~ groups_Compensated == "ab",~ Estimate_Compensated, bg = color_ab)
M_ft <- bg(M_ft, ~ groups_Compensated == "b", ~ Estimate_Compensated, bg = color_b)
M_ft <- bg(M_ft, ~ groups_Compensated == "c", ~ Estimate_Compensated, bg = color_c)

M_ft <- bg(M_ft, ~ groups_Delayed == "a", ~ Estimate_Delayed, bg = color_a)
M_ft <- bg(M_ft, ~ groups_Delayed == "ab",~ Estimate_Delayed, bg = color_ab)
M_ft <- bg(M_ft, ~ groups_Delayed == "b", ~ Estimate_Delayed, bg = color_b)
M_ft <- bg(M_ft, ~ groups_Delayed == "c", ~ Estimate_Delayed, bg = color_c)


M_ft <- bg(M_ft, ~ fdr > 0.05, ~ Estimate_Baseline, bg = "White")
M_ft <- bg(M_ft, ~ fdr > 0.05, ~ Estimate_Compensated, bg = "White")
M_ft <- bg(M_ft, ~ fdr > 0.05, ~ Estimate_Delayed, bg = "White")


M_ft <- set_header_labels(M_ft, 
                          dv = "", stars = "",
                          Estimate_Baseline = "Baseline", Estimate_Compensated = "Compensated", Estimate_Delayed = "Delayed" )

M_ft <- autofit(M_ft)
M_ft

pptx_file <- "./officer_output/DanielAnova.pptx"
save_as_pptx("my table" = M_ft, path = pptx_file)




# fm_overview_table %>% 
#   ggplot(aes(x = ep))+
#   geom_histogram(binwidth = 0.025)+
#   geom_vline(xintercept = 0.05)
```


## Another take on excitability:
### binned Cor
```{r eval=FALSE}

# Goal: extract Absolute measures and differential measures for 
# 1. Burst Amplitude (max mV)
# 2. AUC 
# 3. Stimulus correlation (between)


# read in trace
brian2_trace_files <- list.files(here("data", "predicted_voltage"))

brian2_trace_sets <- brian2_trace_files %>% 
  str_remove(pattern = "-actual_v.rds") %>% 
  str_remove(pattern = "-predict_v.rds") %>% 
  unique()

epsp_summary_list <- map(seq(1, length(brian2_trace_sets)), function(i){
  print(i)
  brian2_read_in <- brian2_trace_files[str_detect(brian2_trace_files, brian2_trace_sets[i])]
  

  # retrieve data and merge into a single df
  temp <- map(brian2_read_in, function(read_file){
    temp_predict <- readRDS(here("data", "predicted_voltage", read_file))
    
    if(str_detect(read_file, pattern = "predict_v")){
      #consolidate into one df
      for (j in seq(1, length(temp_predict))){
        temp_predict[[j]]$Sweep <- j
      }
      temp_predict <- do.call(rbind, temp_predict)
    }
    return(temp_predict)
  })
  
  names(temp) <- brian2_read_in
  
  temp_a <- temp[str_detect(names(temp), pattern = "actual_v")][[1]]
  temp_p <- temp[str_detect(names(temp), pattern = "predict_v")][[1]] %>% as.data.frame() %>% as_tibble()
  temp_a$nrow <- seq(1, nrow(temp_a))
  temp_p$nrow <- seq(1, nrow(temp_p))
  temp_a$Sweep <- as.character(temp_a$Sweep)
  temp_p$Sweep <- as.character(temp_p$Sweep)
  
  temp <- full_join(temp_a, select(temp_p, -Time)) %>% select(-nrow)
  
  # Show difference between expected/actual
  # i = 1
  # [1] "190808a_0014-epsp-In4-actual_v.rds"  "190808a_0014-epsp-In4-predict_v.rds" shows why we need to be able to audit the outcome.
  # Here the end of sweep 4 deviates from baseline so the delta is off
  # TODO instead of subtracting a value at the end, we should look at the times with i_inj less than x and then use a percentile from that to estimate the baseline.
  

  # To get around this in the short term we'll calulate the factors independently for expected/obs
  # downsample_data(temp, len = 10000) %>% 
  # # temp %>% 
  #   mutate(predicted = predicted - offset) %>% 
  #   mutate(difference = In4-predicted) %>% 
  #   ggplot(aes(x = Time))+
  #   geom_ribbon(aes(ymin=In4, ymax=predicted), fill = "cornflowerblue")+
  #   geom_line(aes(y=In4), color = "black")+
  #   geom_line(aes(y=predicted), color = "cornflowerblue", alpha = 0.3)+
  #   # geom_line(aes(y=difference-offset), color = "purple")+
  #   facet_grid(Sweep~.)
  
  # This is an inelegant workaround for data that is based on in9/12. This prevents duplication of the large set below
  
  rewrite_names <- F
  if ("In9" %in% names(temp)){
    names(temp) <- c("In4", "In7", "Sweep", "Time", "predicted", "offset")
    rewrite_names <- T
  }
  
  Use.Bin.Size <- 19687
  
  temp_processed <- temp
  temp_processed$TimeBin <- rep(rep(seq(1, (nrow(temp)/4)/Use.Bin.Size), each = Use.Bin.Size), times = 4)

  # begin to work with data proper
  # Add optional ways to slice the data based on what we expect to occur
  # At the moment we leave this unused
  temp_processed <- temp_processed %>% 
    mutate(
      Period = case_when(
        Time > 0.40  & Time <  4.87  ~ "A",
        Time > 4.87  & Time < 10.74  ~ "B",
        Time > 10.74 & Time < 16.74  ~ "C",
        Time > 16.74 & Time < 19.685 ~ "D"
      ),
      Period_eq = case_when(
        Time > 0.40  & Time <  0.40 + 2.945 ~ "A",
        Time > 4.87  & Time <  4.87 + 2.945 ~ "B",
        Time > 10.74 & Time < 10.74 + 2.945 ~ "C",
        Time > 16.74 & Time < 16.74 + 2.945 ~ "D"
      ),
      Burst = case_when(
        Time > 0.40  & Time <  2    ~ "A",
        Time > 4.87  & Time <  6.17 ~ "B",
        Time > 10.74 & Time < 12.54 ~ "C",
        Time > 16.74 & Time < 18.5  ~ "D"
      ),
      Burst_eq = case_when(
        Time > 0.40  & Time <  2    + 1.30 ~ "A",
        Time > 4.87  & Time <  6.17 + 1.30 ~ "B",
        Time > 10.74 & Time < 12.54 + 1.30 ~ "C",
        Time > 16.74 & Time < 18.5  + 1.30 ~ "D"
      )
    ) %>% 
    # correlation with expected
    group_by(Sweep, TimeBin) %>% 
    mutate(Cor = cor(In4, predicted)) %>% 
    ungroup() %>% 
    gather(Key, mV, c("In4", "predicted")) %>% 
    ## Metrics for whole sweep
    group_by(Key, Sweep) %>% 
    # Min voltage
    mutate(Min.V = min(mV, na.rm = T)) %>%
    # Defining Baseline as average of the lowest 20% of points
    mutate(Use.in.Base = quantile(mV, probs = .2, na.rm = T)) %>%
    mutate(Use.in.Base = ifelse(mV <= Use.in.Base, mV, NA)) %>%
    mutate(Use.in.Base = mean(Use.in.Base, na.rm = T)) %>%
    # Max voltage
    mutate(Max.Amplitude = max(mV, na.rm = T)) %>%
    # AUC
    # Using Min.V
    # mutate(AUC = sum(mV - Min.V, na.rm = T)/(max(temp$Time)/Use.Bin.Size)) %>%
    ungroup() 
  
  temp_processed <- temp_processed[seq(1, nrow(temp_processed), by = Use.Bin.Size), ]
  
  
  
  if (rewrite_names){
    temp_processed <- temp_processed %>% 
      mutate(Key = ifelse(Key == "In4", "In9", Key))
  }
  
  
  temp_processed <- temp_processed[, c("Sweep", "TimeBin", "Time", "Cor", "Key", "Min.V", #"Use.in.Base", 
                                       "Max.Amplitude", "AUC")] %>% 
    distinct() #%>% 
    # pivot_wider(names_from = "Key", values_from = c("Min.V", #"Use.in.Base", 
    #                                                 "Max.Amplitude", "AUC")) 
  
  
  # add annotations to aid merging
  file_name <- brian2_read_in[[1]] %>% str_split(pattern = "-")
  
  temp_processed$Experiment <- as.character(str_split(as.character(file_name[[1]][1]), pattern = "_")[[1]][1])
  temp_processed$FileName <- paste0(as.character(file_name[[1]][1]), ".abf")
  temp_processed$Channel <- as.character(file_name[[1]][3])
  
  return(temp_processed)
})


epsp_summary <- do.call(rbind, epsp_summary_list)
# epsp_summary <- epsp_summary[, c("Experiment", "FileName", "Channel", "Sweep", "Cor", "Key", "Min.V", "Max.Amplitude", "AUC")]

epsp_summary %>% filter(FileName == "190808a_0014.abf", Sweep == 1) %>% 
  ggplot(aes(x = Time, y = Cor))+
  geom_point()


ggplot(aes(x = Time, y = Cor))+
  scattermore::geom_scattermost(
    as.data.frame(epsp_summary[epsp_summary$Sweep == 1, ]),
    # col=viridisLite::viridis(100, alpha=0.05)[1+99*d[,2]],
    pointsize=1,
    pixels=c(700,700)) +
  ggtitle("geom_scattermost")


```

### Binned by event
```{r eval=FALSE}

# Goal: extract Absolute measures and differential measures for 
# 1. Burst Amplitude (max mV)
# 2. AUC 
# 3. Stimulus correlation (between)


# read in trace
brian2_trace_files <- list.files(here("data", "predicted_voltage"))

brian2_trace_sets <- brian2_trace_files %>% 
  str_remove(pattern = "-actual_v.rds") %>% 
  str_remove(pattern = "-predict_v.rds") %>% 
  unique()

epsp_summary_list <- map(seq(1, length(brian2_trace_sets)), function(i){
  print(i)
  brian2_read_in <- brian2_trace_files[str_detect(brian2_trace_files, brian2_trace_sets[i])]
  

  # retrieve data and merge into a single df
  temp <- map(brian2_read_in, function(read_file){
    temp_predict <- readRDS(here("data", "predicted_voltage", read_file))
    
    if(str_detect(read_file, pattern = "predict_v")){
      #consolidate into one df
      for (j in seq(1, length(temp_predict))){
        temp_predict[[j]]$Sweep <- j
      }
      temp_predict <- do.call(rbind, temp_predict)
    }
    return(temp_predict)
  })
  
  names(temp) <- brian2_read_in
  
  temp_a <- temp[str_detect(names(temp), pattern = "actual_v")][[1]]
  temp_p <- temp[str_detect(names(temp), pattern = "predict_v")][[1]] %>% as.data.frame() %>% as_tibble()
  temp_a$nrow <- seq(1, nrow(temp_a))
  temp_p$nrow <- seq(1, nrow(temp_p))
  temp_a$Sweep <- as.character(temp_a$Sweep)
  temp_p$Sweep <- as.character(temp_p$Sweep)
  
  temp <- full_join(temp_a, select(temp_p, -Time)) %>% select(-nrow)
  
  # Show difference between expected/actual
  # i = 1
  # [1] "190808a_0014-epsp-In4-actual_v.rds"  "190808a_0014-epsp-In4-predict_v.rds" shows why we need to be able to audit the outcome.
  # Here the end of sweep 4 deviates from baseline so the delta is off
  # TODO instead of subtracting a value at the end, we should look at the times with i_inj less than x and then use a percentile from that to estimate the baseline.
  

  # To get around this in the short term we'll calulate the factors independently for expected/obs
  # downsample_data(temp, len = 10000) %>% 
  # # temp %>% 
  #   mutate(predicted = predicted - offset) %>% 
  #   mutate(difference = In4-predicted) %>% 
  #   ggplot(aes(x = Time))+
  #   geom_ribbon(aes(ymin=In4, ymax=predicted), fill = "cornflowerblue")+
  #   geom_line(aes(y=In4), color = "black")+
  #   geom_line(aes(y=predicted), color = "cornflowerblue", alpha = 0.3)+
  #   # geom_line(aes(y=difference-offset), color = "purple")+
  #   facet_grid(Sweep~.)
  
  # This is an inelegant workaround for data that is based on in9/12. This prevents duplication of the large set below
  
  rewrite_names <- F
  if ("In9" %in% names(temp)){
    names(temp) <- c("In4", "In7", "Sweep", "Time", "predicted", "offset")
    rewrite_names <- T
  }
  
  # begin to work with data proper
  # Add optional ways to slice the data based on what we expect to occur
  # At the moment we leave this unused
  temp_processed <- temp %>% 
    mutate(
      Segment = case_when(
        Time > 0.40  & Time < 2      ~ "A_B",
        Time > 2     & Time < 4.87   ~ "A_I",
        Time > 4.87  & Time < 6.17   ~ "B_B",
        Time > 6.17  & Time < 10.74  ~ "B_I",        
        Time > 10.74 & Time < 12.54  ~ "C_B",
        Time > 12.54 & Time < 16.74  ~ "C_I",
        Time > 16.74 & Time < 18.5   ~ "D_B",
        Time > 18.5  & Time < 19.685 ~ "D_I"
      )
    ) %>% 
    # correlation with expected
    group_by(Sweep, Segment) %>% 
    mutate(Cor = cor(In4, predicted)) %>% 
    ungroup() %>% 
    gather(Key, mV, c("In4", "predicted")) %>% 
    ## Metrics for whole sweep
    group_by(Key, Sweep) %>% 
    # Min voltage
    mutate(Min.V = min(mV, na.rm = T)) %>%
    # Defining Baseline as average of the lowest 20% of points
    mutate(Use.in.Base = quantile(mV, probs = .2, na.rm = T)) %>%
    mutate(Use.in.Base = ifelse(mV <= Use.in.Base, mV, NA)) %>%
    mutate(Use.in.Base = mean(Use.in.Base, na.rm = T)) %>%
    # Max voltage
    mutate(Max.Amplitude = max(mV, na.rm = T)) %>%
    # AUC
    # Using Min.V
    # mutate(AUC = sum(mV - Min.V, na.rm = T)/19.68685) %>%
    ungroup() 
  
  
  if (rewrite_names){
    temp_processed <- temp_processed %>% 
      mutate(Key = ifelse(Key == "In4", "In9", Key))
  }
  
  
  temp_processed <- temp_processed[, c("Sweep", "Segment", "Cor", "Key", "Min.V", #"Use.in.Base", 
                                       "Max.Amplitude")] %>% 
    distinct() #%>% 
    # pivot_wider(names_from = "Key", values_from = c("Min.V", #"Use.in.Base", 
    #                                                 "Max.Amplitude", "AUC")) 
  
  
  # add annotations to aid merging
  file_name <- brian2_read_in[[1]] %>% str_split(pattern = "-")
  
  temp_processed$Experiment <- as.character(str_split(as.character(file_name[[1]][1]), pattern = "_")[[1]][1])
  temp_processed$FileName <- paste0(as.character(file_name[[1]][1]), ".abf")
  temp_processed$Channel <- as.character(file_name[[1]][3])
  
  return(temp_processed)
})


epsp_summary <- do.call(rbind, epsp_summary_list)
# epsp_summary <- epsp_summary[, c("Experiment", "FileName", "Channel", "Sweep", "Cor", "Key", "Min.V", "Max.Amplitude", "AUC")]



epsp_summary <- left_join(epsp_summary, metadata) %>% 
  select(-FileName, -Type) %>% 
  mutate(Cell = case_when(Channel == "In4" ~ In4,
                          Channel == "In9" ~ In9)) %>% 
  mutate(Cell = as.character(Cell))  %>% 
  mutate(Key = case_when(Key %in% c("In4", "In9") ~ "Obs",
                                  Key %in% c("predicted")  ~ "Sim")) %>% 
  pivot_wider(names_from = "Key", values_from  = c("Min.V", "Max.Amplitude")) %>% 
  mutate(Max.Amplitude_Sim = Max.Amplitude_Sim + (Min.V_Obs - Min.V_Sim)) %>% 
  mutate(Max.Amplitude_Delta = Max.Amplitude_Obs - Max.Amplitude_Sim) %>% 
  group_by(Condition, Experiment, Cell, Segment, Sweep) %>% 
  select(-Min.V_Sim) %>% 
  mutate_at(c("Cor", 
              "Min.V_Obs", #"Min.V_Sim", "Min.V_Delta", 
              "Max.Amplitude_Obs", "Max.Amplitude_Sim", "Max.Amplitude_Delta"), median, na.rm = T) %>% 
  distinct() %>% 
  ungroup()


epsp_summary %>% 
  ggplot(aes(x = Segment, y = Cor, group = Sweep, color = Sweep))+
  geom_point(position = position_jitter(width = 0.1), alpha = 0.3)+
  geom_smooth(se = F)+
  facet_grid(.~Condition)+
  ggsci::scale_color_aaas()

epsp_summary %>% 
  filter(!is.na(Segment)) %>% 
  ggplot(aes(x = Cor, y = Sweep, fill = factor(stat(quantile))))+#, group = Sweep, color = Sweep))+
  # ggridges::geom_density_ridges()+
  ggridges::stat_density_ridges(
               geom = "density_ridges_gradient", calc_ecdf = TRUE,
               quantiles = 4, quantile_lines = TRUE
             ) +
               scale_fill_viridis_d(name = "Quartiles")+
  coord_flip()+
  facet_grid(Condition~Segment)+
  theme(legend.position = "")
  


## Here's the stimulus used in the protocol ====
# sweep duration should be 19.687 seconds
epsp_stim <- readABF_as_matrix(here("inst", "extdata", "epsp_stim_files", "08 current injection.abf"),
                  channels = "Axo1I2")
epsp_stim <- as_tibble(epsp_stim) %>%
  mutate(Time = Time - min(Time, na.rm = T)) %>%
  rename(Stim = Axo1I2)



epsp_stim <- mutate(epsp_stim,
Stim = Stim - min(Stim, na.rm = T),
         Stim = (Stim / 11.9034)-1) 


epsp_summary %>% 
  filter(!is.na(Segment)) %>% 
  mutate(x = case_when(
    Segment == "A_B" ~ 0.40,
    Segment == "A_I" ~ 2,
    Segment == "B_B" ~ 4.87,
    Segment == "B_I" ~ 6.17,
    Segment == "C_B" ~ 10.74,
    Segment == "C_I" ~ 12.54,
    Segment == "D_B" ~ 16.74,
    Segment == "D_I" ~ 18.5
  ),
  xend = case_when(
    Segment == "A_B" ~ 2,
    Segment == "A_I" ~ 4.87,
    Segment == "B_B" ~ 6.17,
    Segment == "B_I" ~ 10.74,
    Segment == "C_B" ~ 12.54,
    Segment == "C_I" ~ 16.74,
    Segment == "D_B" ~ 18.5,
    Segment == "D_I" ~ 19.687
  )) %>% 
  ggplot()+
  geom_segment(aes(x = x, y = Cor, xend = xend, yend = Cor, colour = Cor))+
  facet_grid(Condition~Sweep)+
  geom_line(data = epsp_stim, aes(Time, Stim))+
  theme(legend.position = "")+
  scale_color_viridis_c(direction = -1, option = "B")
#   option	
# A character string indicating the colormap option to use. Four options are available: "magma" (or "A"), "inferno" (or "B"), "plasma" (or "C"), "viridis" (or "D", the default option) and "cividis" (or "E").
  





epsp_stim %>% 
  mutate(Stim = Stim - min(Stim, na.rm = T),
         Stim = (Stim / 11.9034)-1) %>%
  ggplot(aes(Time, Stim))+
  geom_line()

# 
# 
# shading_annotations <- data.frame(
#   starts = c(0.40,
#              4.87,
#              10.74,
#              16.74),
#   next_start = c(4.87,
#                  10.74,
#                  16.74,
#                  19.685),
#   equal_len = c(0.40,
#                 4.87,
#                 10.74,
#                 16.74) + 2.945,
#   on_end = c(2,
#              6.17,
#              12.54, 
#              18.5),
#   equal_on = c(0.40,
#                4.87,
#                10.74,
#                16.74) + 1.30
# )
# 
# annotation_df <- data.frame(x = c(0.5, 0.5, 2.1, 1.8),
#                             y = seq(0.25, -1.25, length.out = 4),
#                             text = c("Period",
#                                      "Minumum Period",
#                                      "Burst", 
#                                      "Min Burst"))
# 
# segmentation_demo_plt <- ggplot()+
#   geom_vline(xintercept = c(shading_annotations$starts, shading_annotations$equal_len, shading_annotations$next_start, shading_annotations$equal_on), color = "gray")+
#   geom_path(data = epsp_stim, aes(Time, Stim+1.5))+
#   geom_rect(data = shading_annotations, aes(xmin = starts, xmax = next_start, ymin = 0, ymax = 0.5), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[1], color = RColorBrewer::brewer.pal(3, "Set1")[1])+
#   geom_rect(data = shading_annotations, aes(xmin = starts, xmax = equal_len, ymin = -0.5, ymax = 0), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[1], color = RColorBrewer::brewer.pal(3, "Set1")[1])+
#   geom_rect(data = shading_annotations, aes(xmin = starts, xmax = on_end, ymin = -1, ymax = -0.5), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[2], color = RColorBrewer::brewer.pal(3, "Set1")[2])+
#   geom_rect(data = shading_annotations, aes(xmin = starts, xmax = equal_on, ymin = -1.5, ymax = -1), alpha = 0.3, fill = RColorBrewer::brewer.pal(3, "Set1")[2], color = RColorBrewer::brewer.pal(3, "Set1")[2])+
#   theme_classic()+
#   # geom_vline(xintercept = 12.54)+
#   geom_text(data = annotation_df[1:2, ], aes(x=x, y=y, label = text), hjust = "inward", color = RColorBrewer::brewer.pal(3, "Set1")[1])+
#   geom_text(data = annotation_df[3:4, ], aes(x=x, y=y, label = text), hjust = "inward", color = RColorBrewer::brewer.pal(3, "Set1")[2])+
#   ylim(-1.5, 9.5)+
#   labs(title = "Ways to Segement EPSP Stim")
# 
# 
# segmentation_demo_plt
```

### Rolling Cor
```{r eval=FALSE}

# Goal: extract Absolute measures and differential measures for 
# 1. Burst Amplitude (max mV)
# 2. AUC 
# 3. Stimulus correlation (between)


# read in trace
brian2_trace_files <- list.files(here("data", "predicted_voltage"))

brian2_trace_sets <- brian2_trace_files %>% 
  str_remove(pattern = "-actual_v.rds") %>% 
  str_remove(pattern = "-predict_v.rds") %>% 
  unique()

epsp_summary_list <- map(seq(1, length(brian2_trace_sets)), function(i){
  print(i)
  brian2_read_in <- brian2_trace_files[str_detect(brian2_trace_files, brian2_trace_sets[i])]
  

  # retrieve data and merge into a single df
  temp <- map(brian2_read_in, function(read_file){
    temp_predict <- readRDS(here("data", "predicted_voltage", read_file))
    
    if(str_detect(read_file, pattern = "predict_v")){
      #consolidate into one df
      for (j in seq(1, length(temp_predict))){
        temp_predict[[j]]$Sweep <- j
      }
      temp_predict <- do.call(rbind, temp_predict)
    }
    return(temp_predict)
  })
  
  names(temp) <- brian2_read_in
  
  temp_a <- temp[str_detect(names(temp), pattern = "actual_v")][[1]]
  temp_p <- temp[str_detect(names(temp), pattern = "predict_v")][[1]] %>% as.data.frame() %>% as_tibble()
  temp_a$nrow <- seq(1, nrow(temp_a))
  temp_p$nrow <- seq(1, nrow(temp_p))
  temp_a$Sweep <- as.character(temp_a$Sweep)
  temp_p$Sweep <- as.character(temp_p$Sweep)
  
  temp <- full_join(temp_a, select(temp_p, -Time)) %>% select(-nrow)
  
  # Show difference between expected/actual
  # i = 1
  # [1] "190808a_0014-epsp-In4-actual_v.rds"  "190808a_0014-epsp-In4-predict_v.rds" shows why we need to be able to audit the outcome.
  # Here the end of sweep 4 deviates from baseline so the delta is off
  # TODO instead of subtracting a value at the end, we should look at the times with i_inj less than x and then use a percentile from that to estimate the baseline.
  

  # To get around this in the short term we'll calulate the factors independently for expected/obs
  # downsample_data(temp, len = 10000) %>% 
  # # temp %>% 
  #   mutate(predicted = predicted - offset) %>% 
  #   mutate(difference = In4-predicted) %>% 
  #   ggplot(aes(x = Time))+
  #   geom_ribbon(aes(ymin=In4, ymax=predicted), fill = "cornflowerblue")+
  #   geom_line(aes(y=In4), color = "black")+
  #   geom_line(aes(y=predicted), color = "cornflowerblue", alpha = 0.3)+
  #   # geom_line(aes(y=difference-offset), color = "purple")+
  #   facet_grid(Sweep~.)
  
  # This is an inelegant workaround for data that is based on in9/12. This prevents duplication of the large set below
  
  rewrite_names <- F
  if ("In9" %in% names(temp)){
    names(temp) <- c("In4", "In7", "Sweep", "Time", "predicted", "offset")
    rewrite_names <- T
  }
  
  # begin to work with data proper
  # Add optional ways to slice the data based on what we expect to occur
  # At the moment we leave this unused
  temp_processed <- temp %>% 
    mutate(
      Period = case_when(
        Time > 0.40  & Time <  4.87  ~ "A",
        Time > 4.87  & Time < 10.74  ~ "B",
        Time > 10.74 & Time < 16.74  ~ "C",
        Time > 16.74 & Time < 19.685 ~ "D"
      ),
      Period_eq = case_when(
        Time > 0.40  & Time <  0.40 + 2.945 ~ "A",
        Time > 4.87  & Time <  4.87 + 2.945 ~ "B",
        Time > 10.74 & Time < 10.74 + 2.945 ~ "C",
        Time > 16.74 & Time < 16.74 + 2.945 ~ "D"
      ),
      Burst = case_when(
        Time > 0.40  & Time <  2    ~ "A",
        Time > 4.87  & Time <  6.17 ~ "B",
        Time > 10.74 & Time < 12.54 ~ "C",
        Time > 16.74 & Time < 18.5  ~ "D"
      ),
      Burst_eq = case_when(
        Time > 0.40  & Time <  2    + 1.30 ~ "A",
        Time > 4.87  & Time <  6.17 + 1.30 ~ "B",
        Time > 10.74 & Time < 12.54 + 1.30 ~ "C",
        Time > 16.74 & Time < 18.5  + 1.30 ~ "D"
      )
    ) %>% 
    # correlation with expected
    group_by(Sweep) %>% 
    mutate(Cor = cor(In4, predicted)) %>% 
    ungroup() %>% 
    gather(Key, mV, c("In4", "predicted")) %>% 
    ## Metrics for whole sweep
    group_by(Key, Sweep) %>% 
    # Min voltage
    mutate(Min.V = min(mV, na.rm = T)) %>%
    # Defining Baseline as average of the lowest 20% of points
    mutate(Use.in.Base = quantile(mV, probs = .2, na.rm = T)) %>%
    mutate(Use.in.Base = ifelse(mV <= Use.in.Base, mV, NA)) %>%
    mutate(Use.in.Base = mean(Use.in.Base, na.rm = T)) %>%
    # Max voltage
    mutate(Max.Amplitude = max(mV, na.rm = T)) %>%
    # AUC
    # Using Min.V
    mutate(AUC = sum(mV - Min.V, na.rm = T)/19.68685) %>%
    ungroup() 
  
  
  if (rewrite_names){
    temp_processed <- temp_processed %>% 
      mutate(Key = ifelse(Key == "In4", "In9", Key))
  }
  
  
  temp_processed <- temp_processed[, c("Sweep", "Cor", "Key", "Min.V", #"Use.in.Base", 
                                       "Max.Amplitude", "AUC")] %>% 
    distinct() #%>% 
    # pivot_wider(names_from = "Key", values_from = c("Min.V", #"Use.in.Base", 
    #                                                 "Max.Amplitude", "AUC")) 
  
  
  # add annotations to aid merging
  file_name <- brian2_read_in[[1]] %>% str_split(pattern = "-")
  
  temp_processed$Experiment <- as.character(str_split(as.character(file_name[[1]][1]), pattern = "_")[[1]][1])
  temp_processed$FileName <- paste0(as.character(file_name[[1]][1]), ".abf")
  temp_processed$Channel <- as.character(file_name[[1]][3])
  
  return(temp_processed)
})


epsp_summary <- do.call(rbind, epsp_summary_list)
epsp_summary <- epsp_summary[, c("Experiment", "FileName", "Channel", "Sweep", "Cor", "Key", "Min.V", "Max.Amplitude", "AUC")]

```

## Bivariate relationships

### What relationships exist at baseline?
#### Correlations
```{r eval=FALSE}

# QC data by completion rate, having variance, and median mrna abundance
M_all_skim <- M_all %>% skimr::skim()
M_all_skim <- M_all_skim[M_all_skim$complete_rate >= 0.19 & 
             M_all_skim$numeric.sd > 0, ]

M_all_skim <- M_all_skim[!(M_all_skim$skim_variable %in% mrna_cols) |
            ((M_all_skim$skim_variable %in% mrna_cols) & M_all_skim$numeric.p50 >= 50 ), ]

M_all <- M_all[, names(M_all) %in% c(
  "Condition", "Cell", "Experiment", "Channel", 
  "Sweep", "Source", "Pharm", "Time", "Sample", 
  M_all_skim$skim_variable[!is.na(M_all_skim$skim_variable)])
  ]


#TODO
M_all$Condition %>% unique()

M_winxiqr_list <- map(c("Baseline", "Compensated", "Delayed"), function(condition){
  temp <- M_all[M_all$Condition == condition, ]
  
  dvs <- names(M_all)[!(names(M_all) %in% c("Condition", "Cell", "Experiment", "Channel", "Sweep", "Source", "Pharm", "Time", "Sample"))]
  
  for (dv_col  in dvs){
    temp[[dv_col]] <- ifelse(win_x_iqr(temp[[dv_col]]), temp[[dv_col]], NA)
  }
  
  return(temp)
})

M_winxiqr <- do.call(rbind, M_winxiqr_list)
M_winxiqr <- M_winxiqr %>% 
  select(-Sweep) %>% 
  group_by(Condition, Cell, Experiment, Channel, Source, Pharm, Time, Sample) %>% 
  mutate_all(median, na.rm = T) %>% 
  ungroup() %>% 
  distinct()





# cowplot::plot_grid(plotlist = tea_plt_list, labels = letters)




  

dvs <- names(M_all)[!(names(M_all) %in% c("Condition", "Cell", "Experiment", "Channel", "Sweep", "Source", "Pharm", "Time", "Sample"))]

condition = "Baseline"
condition = "Compensated"
condition = "Delayed"

# figure out the maximum set of dvs that we can use to have a consistent set across the three conditions
# TODO
# or median interpolate
# non_passing_variables <- map(c("Baseline", "Compensated", "Delayed"), function(condition){
#   temp <- M_winxiqr[M_winxiqr$Condition == condition, dvs]
#   temp_cor <- cor(temp, use = "pairwise.complete.obs") %>% as.data.frame()
#   temp_cor$row <- rownames(temp_cor)
#   temp_cor <- temp_cor %>% gather("col", "cor", names(temp_cor)[names(temp_cor) != "row"]) %>% filter(is.na(cor))
#   return(unique(temp_cor[, c("row", "col")]))
# })
# 
# 
# non_passing_variables <- full_join(non_passing_variables[[1]], non_passing_variables[[2]]) %>% full_join(non_passing_variables[[3]]) %>% distinct() %>% dim()



temp <- M_winxiqr[M_winxiqr$Condition == condition, 
                  dvs[!(dvs %in% c("cc.3_4", "cc.3_5", "cc.4_3", 
                                   "cc.4_5", "cc.5_3", "cc.5_4", 
                                   "ig.3_4", "ig.3_5", "ig.4_5"))]]



  select(-kcnq1,
         -d1br, -hisr3, -ih, -machrb, -hisr2, -htr1b, -htr2b, -kainate2b, -kainate2c, -kcnk1, 
         -rdlr, -mglur4, #rm bc it's coming up as na vs max amp delta. 
         -machra, -mglur7, -nmda1a, -nmda2b, -trpm1, -x18s) #FIXME mv to all

MCorr <- cor(temp, use = "pairwise.complete.obs")

# pMat <- ggcorrplot::cor_pmat(temp)

MCorr <- as.data.frame(MCorr) 
MCorr$row_names <- rownames(MCorr)
MCorr <- MCorr %>% gather(col_names, Corr, names(MCorr)[names(MCorr) != "row_names"])

# pMat <- as.data.frame(pMat) 
# pMat$row_names <- rownames(pMat)
# pMat <- pMat %>% gather(col_names, p, names(pMat)[names(pMat) != "row_names"])

ggplot(MCorr, aes(col_names, row_names, fill = Corr))+
  geom_tile()+
  # geom_tile(data = pMat[pMat$p > 0.05, ], aes(col_names, row_names, fill = p), fill = "white", color = "white")+
  scale_fill_gradient2(low = RColorBrewer::brewer.pal(7, "PuOr")[1],
                       mid = RColorBrewer::brewer.pal(7, "PuOr")[4],
                       high = RColorBrewer::brewer.pal(7, "PuOr")[7],
                       midpoint = 0, 
                       na.value = "#00000000")+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0), legend.position = "")+
  labs(x = "", y = "")










cor_list <- map(c("Baseline", "Compensated", "Delayed"), function(condition){
  temp <- M_winxiqr[M_winxiqr$Condition == condition, 
                    dvs[!(dvs %in% c("cc.3_4", "cc.3_5", "cc.4_3", 
                                     "cc.4_5", "cc.5_3", "cc.5_4", 
                                     "ig.3_4", "ig.3_5", "ig.4_5"))]]
  
  MCorr <- cor(temp, use = "pairwise.complete.obs")
  
  MCorr <- as.data.frame(MCorr) 
  MCorr$row_names <- rownames(MCorr)
  MCorr <- MCorr %>% gather(col_names, Corr, names(MCorr)[names(MCorr) != "row_names"])
  
  MCorr$Condition = condition
  return(MCorr)
})

cor_list_df <- do.call(rbind, cor_list)


library(gganimate)
cor_list_df %>% 
ggplot(aes(col_names, row_names, fill = Corr))+
  geom_tile()+
  # geom_tile(data = pMat[pMat$p > 0.05, ], aes(col_names, row_names, fill = p), fill = "white", color = "white")+
  scale_fill_gradient2(low = RColorBrewer::brewer.pal(7, "PuOr")[1],
                       mid = RColorBrewer::brewer.pal(7, "PuOr")[4],
                       high = RColorBrewer::brewer.pal(7, "PuOr")[7],
                       midpoint = 0, 
                       na.value = "#00000000")+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0), legend.position = "")+
  labs(x = "", y = "", title = 'Condition: {closest_state}')+
  # Here comes the gganimate specific bits

  # transition_time(Condition)
  # ease_aes('linear')
  transition_states(
    Condition,
    transition_length = 0.5,
    state_length = 1
  ) +
  enter_fade()

```


```{r eval=FALSE}

M_winxiqr_list <- map(c("Baseline", "Compensated", "Delayed"), function(condition){
  temp <- M_all[M_all$Condition == condition, ]
  
  dvs <- names(M_all)[!(names(M_all) %in% c("Condition", "Cell", "Experiment", "Channel", "Sweep", "Source", "Pharm", "Time", "Sample"))]
  
  for (dv_col  in dvs){
    temp[[dv_col]] <- ifelse(win_x_iqr(temp[[dv_col]]), temp[[dv_col]], NA)
  }
  
  return(temp)
})

M_winxiqr <- do.call(rbind, M_winxiqr_list)
M_winxiqr <- M_winxiqr %>% 
  select(-Sweep) %>% 
  group_by(Condition, Cell, Experiment, Channel, Source, Pharm, Time, Sample) %>% 
  mutate_all(median, na.rm = T) %>% 
  ungroup() %>% 
  distinct()





# cowplot::plot_grid(plotlist = tea_plt_list, labels = letters)


dvs <- names(M_all)[!(names(M_all) %in% c("Condition", "Cell", "Experiment", "Channel", "Sweep", "Source", "Pharm", "Time", "Sample"))]

# condition = "Baseline"
# condition = "Compensated"
# condition = "Delayed"

# figure out the maximum set of dvs that we can use to have a consistent set across the three conditions
# TODO
# or median interpolate
# non_passing_variables <- map(c("Baseline", "Compensated", "Delayed"), function(condition){
#   temp <- M_winxiqr[M_winxiqr$Condition == condition, dvs]
#   temp_cor <- cor(temp, use = "pairwise.complete.obs") %>% as.data.frame()
#   temp_cor$row <- rownames(temp_cor)
#   temp_cor <- temp_cor %>% gather("col", "cor", names(temp_cor)[names(temp_cor) != "row"]) %>% filter(is.na(cor))
#   return(unique(temp_cor[, c("row", "col")]))
# })
# 
# 
# non_passing_variables <- full_join(non_passing_variables[[1]], non_passing_variables[[2]]) %>% full_join(non_passing_variables[[3]]) %>% distinct() %>% dim()



# temp <- M_winxiqr[M_winxiqr$Condition == condition, 
#                   dvs[!(dvs %in% c("cc.3_4", "cc.3_5", "cc.4_3", 
#                                    "cc.4_5", "cc.5_3", "cc.5_4", 
#                                    "ig.3_4", "ig.3_5", "ig.4_5"))]]
# 
#   # select(-kcnq1,
#   #        -d1br, -hisr3, -ih, -machrb, -hisr2, -htr1b, -htr2b, -kainate2b, -kainate2c, -kcnk1, 
#   #        -rdlr, -mglur4, #rm bc it's coming up as na vs max amp delta. 
#   #        -machra, -mglur7, -nmda1a, -nmda2b, -trpm1, -x18s) #FIXME mv to all
# 
# MCorr <- cor(temp, use = "pairwise.complete.obs")
# 
# #TODO find some way to get only the significant correlations. library Corrr? 
# # pMat <- ggcorrplot::cor_pmat(temp) 
# 
# MCorr <- as.data.frame(MCorr) 
# MCorr$row_names <- rownames(MCorr)
# MCorr <- MCorr %>% gather(col_names, Corr, names(MCorr)[names(MCorr) != "row_names"])
# 
# # pMat <- as.data.frame(pMat) 
# # pMat$row_names <- rownames(pMat)
# # pMat <- pMat %>% gather(col_names, p, names(pMat)[names(pMat) != "row_names"])
# 
# ggplot(MCorr, aes(col_names, row_names, fill = Corr))+
#   geom_tile()+
#   # geom_tile(data = pMat[pMat$p > 0.05, ], aes(col_names, row_names, fill = p), fill = "white", color = "white")+
#   scale_fill_gradient2(low = RColorBrewer::brewer.pal(7, "PuOr")[1],
#                        mid = RColorBrewer::brewer.pal(7, "PuOr")[4],
#                        high = RColorBrewer::brewer.pal(7, "PuOr")[7],
#                        midpoint = 0, 
#                        na.value = "#00000000")+
#   theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0), legend.position = "")+
#   labs(x = "", y = "")










cor_list <- map(c("Baseline", "Compensated", "Delayed"), function(condition){
  temp <- M_winxiqr[M_winxiqr$Condition == condition, 
                    dvs[!(dvs %in% c("cc.3_4", "cc.3_5", "cc.4_3", 
                                     "cc.4_5", "cc.5_3", "cc.5_4", 
                                     "ig.3_4", "ig.3_5", "ig.4_5"))]]
  
  MCorr <- cor(temp, use = "pairwise.complete.obs")
  
  MCorr <- as.data.frame(MCorr) 
  MCorr$row_names <- rownames(MCorr)
  MCorr <- MCorr %>% gather(col_names, Corr, names(MCorr)[names(MCorr) != "row_names"])
  
  MCorr$Condition = condition
  return(MCorr)
})

cor_list_df <- do.call(rbind, cor_list)


library(gganimate)
plt <- cor_list_df %>% 
ggplot(aes(col_names, row_names, fill = Corr))+
  geom_tile()+
  # geom_tile(data = pMat[pMat$p > 0.05, ], aes(col_names, row_names, fill = p), fill = "white", color = "white")+
  scale_fill_gradient2(low = RColorBrewer::brewer.pal(7, "PuOr")[1],
                       mid = RColorBrewer::brewer.pal(7, "PuOr")[4],
                       high = RColorBrewer::brewer.pal(7, "PuOr")[7],
                       midpoint = 0, 
                       na.value = "#00000000")+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0), legend.position = "")+
  labs(x = "", y = "", title = 'Condition: {closest_state}')+
  # Here comes the gganimate specific bits

  # transition_time(Condition)
  # ease_aes('linear')
  transition_states(
    Condition,
    transition_length = 0.5,
    state_length = 1
  ) +
  enter_fade()


anim_save(here("officer_output", "FullDVCorrChange.gif"), plt)
```

![](../plots/BaselineTEA.png)

#### ECDFs
```{r eval=FALSE}
ecdf_corr_list <- 
map(list(
  list(
    cor_list_df[cor_list_df$Condition %in% c("Baseline", "Compensated"), ],
    c("Baseline", "Compensated"),
    c("#4d4d4d", 
      "#67a9cf"#, 
      #"#1c9099"
      )
  ),
  list(
    cor_list_df[cor_list_df$Condition %in% c("Baseline", "Delayed"), ],
    c("Baseline", "Delayed"),
    c("#4d4d4d", 
      #"#67a9cf", 
      "#1c9099")
  ),
  list(
    cor_list_df[cor_list_df$Condition %in% c("Compensated", "Delayed"), ],
    c("Compensated", "Delayed"),
    c(#"#4d4d4d", 
      "#67a9cf",
      "#1c9099")
  )
), function(list.obj){
  plot_ecdf_ks(
  df = list.obj[[1]],
  data.col = "Corr",
  group.col = "Condition",
  group1 = list.obj[[2]][1],
  group2 = list.obj[[2]][2],
  colors = list.obj[[3]])
})



ggsave(plot = cowplot::plot_grid(plotlist = ecdf_corr_list, nrow = 1), 
       filename = here("officer_output", "DanielECDF.tiff"),
       width = 11.5, height = 4.76)
```



ecdfs split by data type
```{r eval=FALSE}
temp <- cor_list_df %>% 
  mutate(Condition = case_when(Condition == "Baseline" ~ "0h",
                               Condition == "Compensated" ~ "1h",
                               Condition == "Delayed" ~ "24h"))


temp$Group <- NA

cor_mem_names <- c("vrest", "r11", "r1", "Ihtk.0", "Ihtk.Slope", "Ia.0", "Ia.Slope")
cor_exc_names <- c("Cor", "Min.V_Obs", "Max.Amplitude_Obs", "Max.Amplitude_Sim", "AUC_Obs", "AUC_Sim", "Max.Amplitude_Delta", "AUC_Delta") 
cor_mrna_names <- c("ache", "bkkca", "cav1", "cav2", "ccapr", "chat", "d1ar", "d2ar", "glucl", "hiscl", "hisr1", "htr1a", "htr7", "inx1", "inx2", "inx3", "inx4", "inx5", "irk", "kainate1b", "kainate2a", "kainate2c", "kcnh1eag", "kcnh2", "kcnh3", "kcnq2", "kcnt1", "lcch3like", "machra", "mgabar1", "mgabar2", "mgabar3", "mglur1", "mglur2", "mglur5", "nalcn", "nav", "nmda1b", "nmda2a", "nmda2like", "shab", "shaker", "shal", "shaw1", "shaw2", "skkca", "trpa1", "trpalike", "trpm3", "trpmlike", "vacht", "vglut")


temp[temp$row_names %in% cor_mem_names &
       temp$col_names %in% cor_mem_names, "Group"] <- "mem"

temp[temp$row_names %in% cor_exc_names &
       temp$col_names %in% cor_exc_names, "Group"] <- "exc"

temp[temp$row_names %in% cor_mrna_names &
       temp$col_names %in% cor_mrna_names, "Group"] <- "mrna"

## mrna only ====


## membrane only ====



## excitability only ====


color_0h  <- "gray"#"#fdd49e"
color_1h  <- "#fc8d59"
color_24h <- "#b30000"
  


ecdf_corr_list <- 
  map(list(
    list(
      temp[temp$Condition %in% c("0h", "1h") &
             temp$Group == "mem", ],
      c("0h", "1h"),
      c(color_0h, 
        color_1h#,
        #color_24h
      )), 
    list(
      temp[temp$Condition %in% c("1h", "24h") &
             temp$Group == "mem", ],
      c("1h", "24h"),
      c(#color_0h, 
        color_1h,
        color_24h
      )),
    list(
      temp[temp$Condition %in% c("0h", "24h") &
             temp$Group == "mem", ],
      c("0h", "24h"),
      c(color_0h, 
        # color_1h,
        color_24h
      )),
    
    ##
    list(
      temp[temp$Condition %in% c("0h", "1h") &
             temp$Group == "exc", ],
      c("0h", "1h"),
      c(color_0h, 
        color_1h#,
        #color_24h
      )), 
    list(
      temp[temp$Condition %in% c("1h", "24h") &
             temp$Group == "exc", ],
      c("1h", "24h"),
      c(#color_0h, 
        color_1h,
        color_24h
      )),
    list(
      temp[temp$Condition %in% c("0h", "24h") &
             temp$Group == "exc", ],
      c("0h", "24h"),
      c(color_0h, 
        # color_1h,
        color_24h
      )),
    
    ## 
    list(
      temp[temp$Condition %in% c("0h", "1h") &
             temp$Group == "mrna", ],
      c("0h", "1h"),
      c(color_0h, 
        color_1h#,
        #color_24h
      )), 
    list(
      temp[temp$Condition %in% c("1h", "24h") &
             temp$Group == "mrna", ],
      c("1h", "24h"),
      c(#color_0h, 
        color_1h,
        color_24h
      )),
    list(
      temp[temp$Condition %in% c("0h", "24h") &
             temp$Group == "mrna", ],
      c("0h", "24h"),
      c(color_0h, 
        # color_1h,
        color_24h
      ))
    
  ), function(list.obj){
    plot_ecdf_ks(
      df = list.obj[[1]],
      data.col = "Corr",
      group.col = "Condition",
      group1 = list.obj[[2]][1],
      group2 = list.obj[[2]][2],
      colors = list.obj[[3]])
  })

cowplot::plot_grid(plotlist = ecdf_corr_list)


# ggsave(plot = cowplot::plot_grid(plotlist = ecdf_corr_list, nrow = 1), 
#        filename = here("officer_output", "DanielECDF_mrnaonly.tiff"),
#        width = 11.5, height = 4.76)
```




####Repeat with only mrna
```{r eval=FALSE}
M_winxiqr_list <- map(c("Baseline", "Compensated", "Delayed"), function(condition){
  temp <- M_all[M_all$Condition == condition, ]
  
  dvs <- names(M_all)[(names(M_all) %in% mrna_cols)] # <---- THIS IS THE CHANGE 
  
  for (dv_col  in dvs){
    temp[[dv_col]] <- ifelse(win_x_iqr(temp[[dv_col]]), temp[[dv_col]], NA)
  }
  
  return(temp)
})

M_winxiqr <- do.call(rbind, M_winxiqr_list)
M_winxiqr <- M_winxiqr %>% 
  select(-Sweep) %>% 
  group_by(Condition, Cell, Experiment, Channel, Source, Pharm, Time, Sample) %>% 
  mutate_all(median, na.rm = T) %>% 
  ungroup() %>% 
  distinct()




dvs <- names(M_all)[(names(M_all) %in% mrna_cols)] # <---- THIS IS THE CHANGE 

temp <- M_winxiqr[M_winxiqr$Condition == condition, 
                  dvs[!(dvs %in% c("cc.3_4", "cc.3_5", "cc.4_3", 
                                   "cc.4_5", "cc.5_3", "cc.5_4", 
                                   "ig.3_4", "ig.3_5", "ig.4_5"))]]

cor_list <- map(c("Baseline", "Compensated", "Delayed"), function(condition){
  temp <- M_winxiqr[M_winxiqr$Condition == condition, 
                    dvs[!(dvs %in% c("cc.3_4", "cc.3_5", "cc.4_3", 
                                     "cc.4_5", "cc.5_3", "cc.5_4", 
                                     "ig.3_4", "ig.3_5", "ig.4_5"))]]
  
  MCorr <- cor(temp, use = "pairwise.complete.obs")
  
  MCorr <- as.data.frame(MCorr) 
  MCorr$row_names <- rownames(MCorr)
  MCorr <- MCorr %>% gather(col_names, Corr, names(MCorr)[names(MCorr) != "row_names"])
  
  MCorr$Condition = condition
  return(MCorr)
})

cor_list_df <- do.call(rbind, cor_list)


library(gganimate)
plt <- cor_list_df %>% 
ggplot(aes(col_names, row_names, fill = Corr))+
  geom_tile()+
  # geom_tile(data = pMat[pMat$p > 0.05, ], aes(col_names, row_names, fill = p), fill = "white", color = "white")+
  scale_fill_gradient2(low = RColorBrewer::brewer.pal(7, "PuOr")[1],
                       mid = RColorBrewer::brewer.pal(7, "PuOr")[4],
                       high = RColorBrewer::brewer.pal(7, "PuOr")[7],
                       midpoint = 0, 
                       na.value = "#00000000")+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0), legend.position = "")+
  labs(x = "", y = "", title = 'Condition: {closest_state}')+
  # Here comes the gganimate specific bits

  # transition_time(Condition)
  # ease_aes('linear')
  transition_states(
    Condition,
    transition_length = 0.5,
    state_length = 1
  ) +
  enter_fade()


anim_save(here("officer_output", "FullDVCorrChange_mrnaonly.gif"), plt)
```

```{r eval=FALSE}
ecdf_corr_list <- 
map(list(
  list(
    cor_list_df[cor_list_df$Condition %in% c("Baseline", "Compensated"), ],
    c("Baseline", "Compensated"),
    c("#4d4d4d", 
      "#67a9cf"#, 
      #"#1c9099"
      )
  ),
  list(
    cor_list_df[cor_list_df$Condition %in% c("Baseline", "Delayed"), ],
    c("Baseline", "Delayed"),
    c("#4d4d4d", 
      #"#67a9cf", 
      "#1c9099")
  ),
  list(
    cor_list_df[cor_list_df$Condition %in% c("Compensated", "Delayed"), ],
    c("Compensated", "Delayed"),
    c(#"#4d4d4d", 
      "#67a9cf",
      "#1c9099")
  )
), function(list.obj){
  plot_ecdf_ks(
  df = list.obj[[1]],
  data.col = "Corr",
  group.col = "Condition",
  group1 = list.obj[[2]][1],
  group2 = list.obj[[2]][2],
  colors = list.obj[[3]])
})

ggsave(plot = cowplot::plot_grid(plotlist = ecdf_corr_list, nrow = 1), 
       filename = here("officer_output", "DanielECDF_mrnaonly.tiff"),
       width = 11.5, height = 4.76)
```

Combined fig corr/ecdf
```{r eval=FALSE}
temp_list <- tea_plt_list

temp_list[[4]] <- ecdf_corr_list[[1]]
temp_list[[5]] <- ecdf_corr_list[[2]]
temp_list[[6]] <- ecdf_corr_list[[3]]


cowplot::plot_grid(plotlist = temp_list)
#TODO how much of the difference in KS between compensated and baseline is noise? I guess we have to cut out the currents and redo it to figure out...
```

Contrast ecdfs with and without currents.
```{r eval=FALSE}
temp_list2 <- ecdf_corr_list

temp_list2[[4]] <- ecdf_corr_nocurrents_list[[1]]
temp_list2[[5]] <- ecdf_corr_nocurrents_list[[2]]
temp_list2[[6]] <- ecdf_corr_nocurrents_list[[3]]

cowplot::plot_grid(plotlist = temp_list2)
```


### How do these relationships change for TEA over time?
```{r eval=FALSE}
#TODO
```



## Multivariate relationships
### globally, clustering etc
set up data
```{r eval=FALSE}
# Copied from above ----
M_winxiqr_list <- map(c("Baseline", "Compensated", "Delayed"), function(condition){
  temp <- M_all[M_all$Condition == condition, ]
  
  dvs <- names(M_all)[!(names(M_all) %in% c("Condition", "Cell", "Experiment", "Channel", "Sweep", "Source", "Pharm", "Time", "Sample"))]
  
  for (dv_col  in dvs){
    temp[[dv_col]] <- ifelse(win_x_iqr(temp[[dv_col]]), temp[[dv_col]], NA)
  }
  
  return(temp)
})

M_winxiqr <- do.call(rbind, M_winxiqr_list)
M_winxiqr <- M_winxiqr %>% 
  select(-Sweep) %>% 
  group_by(Condition, Cell, Experiment, Channel, Source, Pharm, Time, Sample) %>% 
  mutate_all(median, na.rm = T) %>% 
  ungroup() %>% 
  distinct()

# Median imputation ----
M_winxiqr <- M_winxiqr %>% 
  select(-Channel, -Source, -Pharm, -Time, -Sample)

M_winxiqr <- M_winxiqr %>% 
  group_by(Condition, Experiment, Cell) %>%
  mutate_all(median, na.rm = T) %>% 
  ungroup() %>% 
  distinct()
  
library(imputeMissings)
M_winxiqr <- imputeMissings::impute(M_winxiqr, method = "median/mode")


for_label_Condition <- M_winxiqr$Condition
rownames(M_winxiqr) <- paste(M_winxiqr$Experiment, M_winxiqr$Cell, sep = "-")
```

#### Cluster
dendrogram 
```{r eval=FALSE}
library(pvclust)
library(ggdendro)
set.seed(654684)
cluster <- pvclust(t(select(M_winxiqr, - Condition, -Experiment, -Cell)),
                   method.hclust = "ward.D2",
                   method.dist = "correlation",
                   use.cor = "pairwise.complete.obs")
```

dendrogram plot method 1
```{r eval=FALSE}
library(dendextend)

tiff(file=here("officer_output", "hclust.tiff"),
     width=7.96, height=6.68, units="in", res=100)

cluster %>% 
  as.dendrogram() %>% 
  set("branches_k_color", k = 3, value = RColorBrewer::brewer.pal(3, "Set1")) %>%
  plot()


dev.off()


# tiff(file=here("officer_output", "ContrastSource_hclust.tiff"),      width=7.96, height=6.68, units="in", res=100) 

par(mar=c(7,2,2,1))
cluster %>% 
  as.dendrogram() %>% 
  set("labels_col", 
      value = c("#1f78b4", "#e31a1c", "#ff7f00"), k = 3) %>%
  set("branches_k_color", 
      value = c("#1f78b4", "#e31a1c", "#ff7f00"), k = 3) %>% 
plot()

my_colors <- case_when(for_label_Condition == "Baseline" ~ "#fdd49e",
                       for_label_Condition == "Compensated" ~ "#fc8d59",
                       for_label_Condition == "Delayed" ~ "#b30000")

colored_bars(colors = my_colors, dend = as.dendrogram(cluster), rowLabels = " Groups")

# plot(cluster, hang = -1, main = "Cluster dendogram with AU/BP values (%) Raw Data")
```

dendrogram plot method 2
```{r eval=FALSE}
plt <- ggdendro::ggdendrogram(cluster$hclust)

cluster_dend <- ggdendro::dendro_data(as.dendrogram(cluster$hclust), type = "rectangle")
cluster_dend_segments <- ggdendro::segment(cluster_dend)


label_df <- data.frame(labels = M_winxiqr[, "Condition"],
                       exps = M_winxiqr[, "Experiment"])
label_df$orderby <- as.numeric(as.character(ggdendro::label(cluster_dend)$label))
label_df <- arrange(label_df, orderby)


# cluster_dend_labs <- data.frame(ggdendro::label(cluster_dend), Time = as.factor(no_outlier_tea_df[match(label(no_outlier_tea_df)$label, rownames(no_outlier_tea_df)), "Time"]))

ggplot()+
  geom_segment(data = cluster_dend_segments,
               aes(x = x, y = y, xend = xend, yend = yend),
               size = 1.25,
               colour = "black",
               lineend = "round")+ 
  geom_text(data = data.frame(ggdendro::label(cluster_dend),
                              Time = label_df$labels,
                              exps = label_df$exps), 
            aes(x = x, y = y, label = exps, colour = Time), 
            nudge_y = 0, family = "boldserif", size = 5, angle = 90, hjust = 1)+ 
  xlab("")+ 
  ylab("Height")+
  # lims(y = c(-0.1, 0.8))+
  theme(axis.line.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        text = element_text(family = "serif"),
        legend.position = "bottom")

ggsave(plot = last_plot(), 
       filename = here("officer_output", "hclust_ggplot.tiff"),
       width = 11.5, height = 4.76)
```

have dendrogram on both sides
```{r eval=FALSE}
# cluster_2 <- pvclust(no_outlier_tea_df[, c(MeasuredKCurrents, MeasuredmRNA)],
#                    method.hclust = "ward.D2",
#                    method.dist = "correlation",
#                    use.cor = "pairwise.complete.obs")
# 
# mrna_cluster_dend <- as.dendrogram(cluster)
# cell_cluster_dend <- as.dendrogram(cluster_2)
# 
# 
# mrna_cutree <- cutree(mrna_cluster_dend, k = 5)
# cell_cutree <- cutree(cell_cluster_dend, k = 4)
# 
# 
# library(RColorBrewer)
# mypalette <- rev(brewer.pal(9, "PuOr")[-1])
# 
# 
# matrix_for_heatmap <- as.matrix(no_outlier_tea_df[, c(MeasuredKCurrents, MeasuredmRNA)])
# 
# # Reference
# # https://rpubs.com/Sammi/132435
# heatmap(
# matrix_for_heatmap,
# Rowv = mrna_cluster_dend,
# Colv = cell_cluster_dend,
# 
# RowSideColors = as.character(mrna_cutree),
# ColSideColors = as.character(cell_cutree),
# # scale = "col"
# 
# key = T, 
# col = mypalette
# )
# 
# 
# library(gplots)
# heatmap.2(
# matrix_for_heatmap,
# Rowv = mrna_cluster_dend,
# Colv = cell_cluster_dend,
# 
# RowSideColors = as.character(mrna_cutree),
# ColSideColors = as.character(cell_cutree),
# # scale = "col"
# 
# trace = "none",
# key = T
# # col = mypalette
# )
# 
# 
# # source("http://faculty.ucr.edu/~tgirke/Documents/R_BioCond/My_R_Scripts/my.colorFct.R")
# # heatmap(y, 
# #         Rowv = as.dendrogram(hr), 
# #         Colv = as.dendrogram(hc), 
# #         col=my.colorFct(), 
# #         scale="row")
```


Clustering with subsets of the data
membrane properties
```{r eval=FALSE}
set.seed(654684)
cluster <- pvclust(t(M_winxiqr[, names(M_winxiqr)[names(M_winxiqr) %in% c(
  "vrest", "r11", "r1", "Ihtk.0", "Ihtk.Slope", "Ia.0", "Ia.Slope")] ]),
                   method.hclust = "ward.D2",
                   method.dist = "correlation",
                   use.cor = "pairwise.complete.obs")

?hclust

par(mar=c(7,2,2,1))
cluster$hclust %>% 
  as.dendrogram() %>% 
  set("labels_col", 
      value = c("#023858", "#737373", "#4d004b"), k = 3) %>%
  set("branches_k_color", 
      value = c("#023858", "#737373", "#4d004b"), k = 3) %>% 
plot()

my_colors <- case_when(for_label_Condition == "Baseline" ~ "#fdd49e",
                       for_label_Condition == "Compensated" ~ "#fc8d59",
                       for_label_Condition == "Delayed" ~ "#b30000")

colored_bars(colors = my_colors, dend = as.dendrogram(cluster), rowLabels = " Groups")







```

Excitability
```{r eval=FALSE}
set.seed(654684)
cluster <- pvclust(t(M_winxiqr[, names(M_winxiqr)[names(M_winxiqr) %in% epsp_cols] ]),
                   method.hclust = "ward.D2",
                   method.dist = "correlation",
                   use.cor = "pairwise.complete.obs")
```

mRNA
```{r eval=FALSE}
set.seed(654684)
cluster <- pvclust(t(M_winxiqr[, names(M_winxiqr)[names(M_winxiqr) %in% mrna_cols] ]),
                   method.hclust = "ward.D2",
                   method.dist = "correlation",
                   use.cor = "pairwise.complete.obs")
```



Evaluating clustering quality
```{r eval=FALSE}
# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install("BiocGenerics")
library(BiocGenerics)
library(imputeMissings)
library(magrittr) # for %>% (this is part of tidyverse)
library(clues)
library(NMF)

## Evaluate clustering performance ==========================================
get_cluster_comparisons <- function(reference.clustering = mrna_raw$Cell,
                                    generated.clustering) {
  if (length(reference.clustering) != length(generated.clustering)) {
    warning("Input vectors are not of the same length!")
  } else {
    # reference.clustering = mrna_raw$Cell
    # generated.clustering = kmeans.m$cluster
    output <- array(0, dim = 6)
    reference.clustering <- as.numeric(reference.clustering) %>% as.factor()
    generated.clustering <- as.numeric(generated.clustering) %>% as.factor()
    output <- NMF::purity(reference.clustering, generated.clustering)
    names(output) <- "Purity"
    # Get a lot of concurrance measures
    # https://davetang.org/muse/2017/09/21/adjusted-rand-index/
    output <- c(
      output,
      clues::adjustedRand(
        BiocGenerics::as.vector(reference.clustering),
        BiocGenerics::as.vector(generated.clustering)
      )
    )
    return(output)
  }
}



```

resampling based evaluation of jaccard
```{r eval=FALSE}
temp.clust <- as.dendrogram(cluster$hclust)
assignment <- cutree(temp.clust, k = 3)[order.dendrogram(temp.clust)]

# use names to get groupings
time_groups <- as.factor(unlist(transpose(stringr::str_split(names(assignment), pattern = "-"))[[1]]))

library(purrr)
set.seed(9348957)
resample.indices <- map(1:10001, function(i){
  if (i == 1){
    indices <- get_cluster_comparisons(reference.clustering = time_groups,
                                       assignment)
  }else{
    indices <- get_cluster_comparisons(reference.clustering = time_groups,
                                       sample(assignment, replace = F))
  }
})
resample.indices <- do.call(rbind, resample.indices)
resample.indices <- resample.indices %>% as.data.frame()

library(ggplot2)
resample.indices %>% 
  ggplot(aes(x = Jaccard))+
  geom_density()+
  geom_vline(xintercept = as.numeric(resample.indices[1, "Jaccard"]))+
  xlim(0,1)+
  theme_minimal()+
  labs(subtitle = paste0("ep = ", as.character(round(mean(resample.indices$Jaccard >= resample.indices[1, "Jaccard"]), digits = 4))))
# empirical p-value from 10,000 random samplings
ggsave(plot = last_plot(), 
       filename = here("officer_output", "hclust_jaccard_dist.tiff"),
       width = 11.5, height = 4.76)
```

#### PCA

```{r eval=FALSE}





list_for_pca <- list(
  M_winxiqr[M_winxiqr$Condition == "Baseline", 
            names(M_winxiqr)[!(names(M_winxiqr) %in% c("Condition", "Cell", "Experiment"))]],
  M_winxiqr[M_winxiqr$Condition == "Compensated", 
            names(M_winxiqr)[!(names(M_winxiqr) %in% c("Condition", "Cell", "Experiment"))]],
  M_winxiqr[M_winxiqr$Condition == "Delayed", 
            names(M_winxiqr)[!(names(M_winxiqr) %in% c("Condition", "Cell", "Experiment"))]]
)

pca_summary_descriptions <- map(list_for_pca, function(df){
  mk_pca_multi_plt(input.df = df,
                   scree.max.y = 100)
})

pca_summary_descriptions <- map(list_for_pca, function(df){
  mk_pca_multi_plt(input.df = df,
                 scree.max.y = 100)
})


# {p4|p0}/{p1+p2+p3}

{pca_summary_descriptions[[1]]$scree | pca_summary_descriptions[[2]]$scree | pca_summary_descriptions[[3]]$scree}/
{pca_summary_descriptions[[1]]$biplt | pca_summary_descriptions[[2]]$biplt | pca_summary_descriptions[[3]]$biplt}
# {pca_summary_descriptions[[1]]$cont1 | pca_summary_descriptions[[2]]$cont1 | pca_summary_descriptions[[3]]$cont1}

ggsave(plot = last_plot(), 
       filename = here("officer_output", "PCA_Contrast.tiff"),        
       width = 11.5, height = 4.76)

```

3d
```{r eval=FALSE}






vis_pca_3D(input.df = M_winxiqr[, names(M_winxiqr)[!(names(M_winxiqr) %in% c("Condition", "Cell", "Experiment"))]],
           # color.by = M_winxiqr[, "Condition"],
           color.by = case_when(M_winxiqr[, "Condition"] == "Baseline" ~ "0h",
                                M_winxiqr[, "Condition"] == "Compensated" ~ "1h",
                                M_winxiqr[, "Condition"] == "Delayed" ~ "24h"),
           turn.x.times = 1,
           # use.colors = c("#fdd49e", "#fc8d59", "#b30000")
           use.colors = c("#cc4c02", "#e31a1c", "#800026")
           #RColorBrewer::brewer.pal(3, "Set1")
)
```

With subsets of the data
```{r eval=FALSE}
## mrna only ====
vis_pca_3D(
  input.df =  M_winxiqr[, names(M_winxiqr)[!(names(M_winxiqr) %in% c(
    "Condition", "Cell", "Experiment",
    "vrest", "r11", "r1", 
    "cc.3_4", "cc.3_5", "ig.3_4", "ig.3_5", 
    "Cor", "Min.V_Obs", "Max.Amplitude_Obs", "Max.Amplitude_Sim", 
    "AUC_Obs", "AUC_Sim", "Max.Amplitude_Delta", "AUC_Delta", 
    "Ihtk.0", "Ihtk.Slope", "Ia.0", "Ia.Slope"
  ))]],
  color.by = case_when(M_winxiqr[, "Condition"] == "Baseline" ~ "0h",
                       M_winxiqr[, "Condition"] == "Compensated" ~ "1h",
                       M_winxiqr[, "Condition"] == "Delayed" ~ "24h"),
  turn.x.times = 1,
  use.colors = c("#cc4c02", "#e31a1c", "#800026")
)



## membrane only ====
vis_pca_3D(
  input.df =  M_winxiqr[, names(M_winxiqr)[(names(M_winxiqr) %in% c(
    # "Condition", "Cell", "Experiment",
    "vrest", "r11", "r1", 
    # "cc.3_4", "cc.3_5", "ig.3_4", "ig.3_5", 
    # "Cor", "Min.V_Obs", "Max.Amplitude_Obs", "Max.Amplitude_Sim", 
    # "AUC_Obs", "AUC_Sim", "Max.Amplitude_Delta", "AUC_Delta", 
    "Ihtk.0", "Ihtk.Slope", "Ia.0", "Ia.Slope"
  ))]],
  color.by = case_when(M_winxiqr[, "Condition"] == "Baseline" ~ "0h",
                       M_winxiqr[, "Condition"] == "Compensated" ~ "1h",
                       M_winxiqr[, "Condition"] == "Delayed" ~ "24h"),
  turn.x.times = 1,
  use.colors = c("#cc4c02", "#e31a1c", "#800026")
)


## excitability only ====


vis_pca_3D(
  input.df =  M_winxiqr[, names(M_winxiqr)[(names(M_winxiqr) %in% c(
    # "Condition", "Cell", "Experiment",
    # "vrest", "r11", "r1", 
    # "cc.3_4", "cc.3_5", "ig.3_4", "ig.3_5", 
    "Cor", "Min.V_Obs", "Max.Amplitude_Obs", "Max.Amplitude_Sim", 
    "AUC_Obs", "AUC_Sim", "Max.Amplitude_Delta", "AUC_Delta"#, 
    # "Ihtk.0", "Ihtk.Slope", "Ia.0", "Ia.Slope"
  ))]],
  color.by = case_when(M_winxiqr[, "Condition"] == "Baseline" ~ "0h",
                       M_winxiqr[, "Condition"] == "Compensated" ~ "1h",
                       M_winxiqr[, "Condition"] == "Delayed" ~ "24h"),
  turn.x.times = 1,
  use.colors = c("#cc4c02", "#e31a1c", "#800026")
)

```




### specifically

```{r eval=FALSE}

```
# ###############################################################################


# ###############################################################################





# Secondary Questions
```{r eval=FALSE}
scatter_w_wo_outliers(temp = distinct(select(filter(M_all, Time == "Baseline"), shal, Ia.0)), 
                  X = "shal", 
                  Y = "Ia.0")

scatter_w_wo_outliers(temp = distinct(select(filter(M_all, Time == "Compensated"), shal, Ia.0)), 
                  X = "shal", 
                  Y = "Ia.0")

scatter_w_wo_outliers(temp = distinct(select(filter(M_all, Time == "Delayed"), shal, Ia.0)), 
                  X = "shal", 
                  Y = "Ia.0")

```


                       
                       
```{r reference}
# ref ----
# c(
#   ## Ion Channels ====
#   #Kv
#   "Shab", "Shaker", "Shal", "Shaw1", "Shaw2",
#   "KCNQ1", "KCNQ2", 
#   "KCNH1", "KCNH2", "KCNH3",
#   #K
#   "BKKCa", "SKKCa", 
#   "KCNT1", "IRK", "KCNK1", "KCNK2", 
#   #Ca
#   "CaV1", "CaV2", "CaV3", 
#   #Na
#   "CbNaV", 
#   "NALCN", 
#   #Hyp/CyclNuc Activated/Gated
#   "IH", 
#   ## CNGs
#   
#   #TRPs
#   "TRP-A1", "TRP-A-like", "TRP-M1", "TRP-M3", "TRP-M-like", 
#   ##-V5, -V6, -Pyrexia
#   
#   
#   #Biogenic amine activated
#   "HisCL", 
#   
#   ## Receptors Biogenic Amines ====
#   #octopamine
#   
#   #dopamine
#   "DAR1A", "DAR2",  "Dopa-1Br",
#   #serotonin
#   "HTR1A", "HTR2", "HTR7", "5HTr-1Br",  
#   
#   #histamine
#   "His-1r", "His-2r", "His-3r", 
#   #gaba
#   "GABAB-R1",
#   "LCCH3r",
#   "RDLr", 
#   "mGABA2", "mGABA3", 
#   
#   ## Receptors Glutamate/Acetylcholine ====
#   #metabotropic glutamate receptors
#   "mGluR1", "mGluR2", "mGluR4", "mGluR5", "mGluR7",
#   #kainate-like receptors
#   "Kainate-1A", "Kainate-1B", "Kainate-2A", "Kainate-2B", "Kainate-2C",
#   #NMDA-like receptors
#   "NMDA-1A", "NMDA-1B", "NMDA-2A", "NMDA-2B", "NMDA-2-like", 
#   #glutamate-gated chloride channel
#   "GluCl",
#   #acetylcholine receptors
#   "mACHrA", "mACHrB", 
#   
#   # Crustacean cardioactive peptide receptor ===
#   "CCAPr", 
#   
#   #Acetylcholinesterase
#   "ACHE", 
#   # Actylcholine catalyst
#   "ChAT", 
#   
#   #vesicular ach transporter
#   "vAChT", 
#   #vesicular glut transporter
#   "vGluT", 
#   
#   ## Innexins ====
#   "INX1", "INX2", "INX3", "INX4", "INX5"
# )
```




```{r eval=FALSE}
load(here("data", "ionic.rds"))
load(here("data", "tevc.rds"))
load(here("data", "tecc.rds"))
load(here("data", "mrna.rds"))

mRNAInfo <- readxl::read_excel(here("inst", "extdata", "mRNAInfo.xlsx")) # tables from Northcutt 2016 and annotations
```

# ionic ~ mrna?

## Make a joint dataset
```{r eval=FALSE}
M <- left_join(ionic, mrna)

M <- M[!is.na(M$x18s), ]

MeasuredmRNA <- names(mrna)[!(names(mrna) %in% c("Source", "Pharm", "Time", "Sample", "Experiment", "Cell"))]

# temp.plts <- map(seq_along(MeasuredmRNA), function(i){
#   ggplot(M, aes_string(MeasuredmRNA[i], y = "Ihtk.0", color = "Time"))+
#   geom_smooth(method = "lm", se = F)+
#   geom_point()
# })
# 
# cowplot::plot_grid(plotlist = temp.plts)
# 
# mrna
```

## Clean up data cols
```{r eval=FALSE}
PercentNotNA <- map(MeasuredmRNA, function(i){
  mean(!is.na(M[[i]]))
}) %>% unlist()

ThresholdPercentNotNA <- 0.6
MeasuredmRNA <- MeasuredmRNA[PercentNotNA >= ThresholdPercentNotNA] # use in map call
MeasuredKCurrents <- c("Ihtk.0", "Ihtk.Slope", "Ia.0", "Ia.Slope") # use in map call
```

## How well does this work for currents we know something about?
Ia ~ shal
```{r eval=FALSE}
# TEXTING WITH DAVE
scatter_w_wo_outliers(temp = filter(M, Time == "Baseline"), 
                  X = "shal", 
                  Y = "Ia.0")

# broom::tidy(lm(Ia.0 ~ shal, temp))
# broom::tidy(lm(Ia.0 ~ shal, temp[temp$flag, ]))
```


```{r eval=FALSE, include=FALSE}
library(brms)
# Loading required package: StanHeaders
# rstan (Version 2.19.3, GitRev: 2e1f913d3ca3)
# For execution on a local, multicore CPU with excess RAM we recommend calling
options(mc.cores = parallel::detectCores())
# To avoid recompilation of unchanged Stan programs, we recommend calling
rstan_options(auto_write = TRUE)
# For improved execution time, we recommend calling
Sys.setenv(LOCAL_CPPFLAGS = '-march=corei7 -mtune=corei7')
# although this causes Stan to throw an error on a few processors.


temp <- temp[!is.na(temp$Ia.0), ]

tic <- Sys.time()
fm1 <- lm(Ia.0 ~ shal, temp)
toc1 <- Sys.time() - tic

tic <- Sys.time()
fm2 <- brm(Ia.0 ~ shal, data  = temp, family = gaussian())
toc2 <- Sys.time() - tic

tic <- Sys.time()
fm3 <- brm(Ia.0 ~ shal, data  = temp, family = student())
toc3 <- Sys.time() - tic



toc1
toc2
toc3

t1 <- broom::tidy(fm1)
t2 <- broom::tidy(fm2)
t3 <- broom::tidy(fm3)



bayes_ex1 <- 
ggplot(temp, aes(x = shal, y = Ia.0))+
  geom_point()+
  geom_abline(slope = as.numeric(t1[2, "estimate"]), intercept = as.numeric(t1[1, "estimate"]), size = 1, color = "gray")+
  geom_abline(slope = as.numeric(t2[2, "estimate"]), intercept = as.numeric(t2[1, "estimate"]), size = 1, color = "cornflowerblue")+
  geom_abline(slope = as.numeric(t3[2, "estimate"]), intercept = as.numeric(t3[1, "estimate"]), size = 1, color = "firebrick")+
  theme_bw()
```



Ia ~ shaker
```{r eval=FALSE}
scatter_w_wo_outliers(temp = filter(M, Time == "Baseline"), 
                  X = "shaker", 
                  Y = "Ia.0")
```


Model comparison *shal best predicts Ia*
```{r eval=FALSE}
temp <- filter(M, Time == "Baseline") 
# What's the best model?
library(AICcmodavg)
# no rm points
aictab(cand.set = list(
  lm(Ia.0 ~ shal, temp),
  lm(Ia.0 ~ shaker, temp),
  lm(Ia.0 ~ shal+shaker, temp),
  lm(Ia.0 ~ shal*shaker, temp)
))

# rm points
temp_no_outliers <- temp %>% 
  mutate(shal = ifelse(win_x_iqr(shal), shal, NA)) %>% 
  mutate(shaker = ifelse(win_x_iqr(shaker), shaker, NA)) %>% 
  mutate(Ia.0 = ifelse(win_x_iqr(Ia.0), Ia.0, NA))


aictab(cand.set = list(
  lm(Ia.0 ~ shal, temp_no_outliers),
  lm(Ia.0 ~ shaker, temp_no_outliers),
  lm(Ia.0 ~ shal+shaker, temp_no_outliers),
  lm(Ia.0 ~ shal*shaker, temp_no_outliers)
))
```




IHTK ~ bkkca
```{r eval=FALSE}
scatter_w_wo_outliers(temp = filter(M, Time == "Baseline"), 
                  X = "bkkca", 
                  Y = "Ihtk.0")
```





How might we exclude outliers? Cooks Distance? Iterated Cooks?
```{r eval=FALSE, include=FALSE}
temp <- filter(M, Time == "Baseline") %>%
  mutate(flag = ifelse(bkkca < 3000, T, F))

fm <- lm(Ihtk.0 ~ bkkca, temp)

temp$cooksd <- cooks.distance(fm)

ggplot(temp, aes_string("bkkca", "Ihtk.0", color = "flag"))+
  geom_smooth(method = lm, se = F, color = "gray")+
  geom_smooth(data = temp[temp$flag == T, ], method = lm, se = F, fullrange = T)+
  geom_point(aes(color = cooksd < (mean(cooks.distance(fm))*2.2) ))+
  scale_color_manual(values = c("gray", "black"))+
  theme_bw()+
  theme(legend.position = "")

# broom::tidy(lm(Ihtk.0 ~ bkkca, temp))
# broom::tidy(lm(Ihtk.0 ~ bkkca, temp[temp$flag, ]))
broom::tidy(lm(Ihtk.0 ~ bkkca, temp[temp$cooksd < (mean(cooks.distance(fm))*4) , ]))
# temp %>% filter(flag == F)

```

Checking the use of iterated Cook's distance 
Using cooks is going to be challenging. It'll be hard to choose a stopping criteria as 
```{r eval=FALSE, include=FALSE}
flag_cooks_outliers <- function(
  df = filter(M, Time == "Baseline"),
  mod = "Ihtk.0 ~ bkkca",
  multiplier = 4,
  center = "mean"){
  
  fm <- lm(as.formula(mod), df)
  
  cd <- cooks.distance(fm)
  
  if (center == "mean"){
    cd_outlier <- cd > mean(cd)*multiplier 
  } else if (center == "median") {
    cd_outlier <- cd > median(cd)*multiplier 
  } else {
    warning("center must be mean or median")
  }
  
  return(cd_outlier)
}

# run 10 iterations of cooks distance. When a cell is identified as an outlier, drop it and note when it was deamed an outlier

temp <- M %>% dplyr::select(Ihtk.0, bkkca, Time) %>% filter(Time == "Baseline")
temp$dropout <- NA

for (i in 1:10){
  current_outliers <- flag_cooks_outliers(df = temp[is.na(temp$dropout), ],
                    mod = "Ihtk.0 ~ bkkca",
                    multiplier = 4,
                    center = "mean")
  
  temp[is.na(temp$dropout), ][current_outliers, "dropout"] <- i
  
}

ggplot(temp, aes(x = bkkca, y = Ihtk.0, color = as.factor(dropout)))+
  geom_point()

bkkca_cook_outliers <- temp$dropout
temp %>% group_by(dropout) %>% tally()
# # A tibble: 5 x 2
#   dropout     n
#     <int> <int>
# 1       1     1
# 2       2     1
# 3       3     1
# 4       4     1
# 5      NA    12





temp <- M  %>% filter(Time == "Baseline")
temp$dropout <- NA
for (i in 1:10){
  current_outliers <- flag_cooks_outliers(df = temp[is.na(temp$dropout), ],
                    mod = "Ia.0 ~ shal",
                    multiplier = 4,
                    center = "mean")
  temp[is.na(temp$dropout), ][current_outliers, "dropout"] <- i
}

temp %>% group_by(dropout) %>% tally()


temp <- M  %>% filter(Time == "Baseline")
temp$dropout <- NA
for (i in 1:10){
  current_outliers <- flag_cooks_outliers(df = temp[is.na(temp$dropout), ],
                    mod = "Ia.0 ~ shaker",
                    multiplier = 4,
                    center = "mean")
  temp[is.na(temp$dropout), ][current_outliers, "dropout"] <- i
}

temp %>% group_by(dropout) %>% tally()
```

contrast cooks with a fit t distribution.
```{r eval=FALSE, include=FALSE}
# temp <- filter(M, Time == "Baseline")
# 
# tic <- Sys.time()
# fm0 <- lm(Ihtk.0 ~ bkkca, temp[temp$bkkca < 3000, ])
# toc1 <- Sys.time() - tic
# 
# tic <- Sys.time()
# fm1 <- lm(Ihtk.0 ~ bkkca, temp)
# toc1 <- Sys.time() - tic
# 
# tic <- Sys.time()
# fm2 <- brm(Ihtk.0 ~ bkkca, data  = temp, family = gaussian())
# toc2 <- Sys.time() - tic
# 
# tic <- Sys.time()
# fm3 <- brm(Ihtk.0 ~ bkkca, data  = temp, family = student())
# toc3 <- Sys.time() - tic
# 
# 
# 
# toc1
# toc2
# toc3
# 
# t0 <- broom::tidy(fm0)
# t1 <- broom::tidy(fm1)
# t2 <- broom::tidy(fm2)
# t3 <- broom::tidy(fm3)
# 
# 
# temp$dropout <- bkkca_cook_outliers
# # temp[is.na(temp$dropout), "dropout"] <- 11
# 
# alpha_param <-  0.8
# # bayes_ex1 <- 
# ggplot(temp, aes(x = bkkca, y = Ihtk.0, color = as.factor(dropout)))+
#   
#   geom_abline(slope = as.numeric(t0[2, "estimate"]), intercept = as.numeric(t0[1, "estimate"]), size = 1, alpha = alpha_param, color = "black")+
#   geom_abline(slope = as.numeric(t1[2, "estimate"]), intercept = as.numeric(t1[1, "estimate"]), size = 1, alpha = alpha_param, color = "black")+
#   geom_abline(slope = as.numeric(t2[2, "estimate"]), intercept = as.numeric(t2[1, "estimate"]), size = 1, alpha = alpha_param, color = "cornflowerblue")+
#   geom_abline(slope = as.numeric(t3[2, "estimate"]), intercept = as.numeric(t3[1, "estimate"]), size = 1, alpha = alpha_param, color = "firebrick")+
#   
#   geom_point(size = 2, color = "white")+
#   geom_point(size = 2)+
#   geom_point(size = 2, color = "black", shape = 1)+
#   
#   theme_bw()+
#   theme(legend.position = "bottom")+
#   scale_color_brewer(type = "div", palette = "PuOr")




```



IHTK ~ skkca
```{r eval=FALSE}
scatter_w_wo_outliers(temp = filter(M, Time == "Baseline"), 
                  X = "skkca", 
                  Y = "Ihtk.0")
```


How do K channels predict IKv intercepts?
```{r eval=FALSE}
# TODO redo this using the info in mRNAInfo 
# TODO use next block as inspiration.

# filter(M, Time == "Baseline") %>% 
#   select(Ihtk.0, Ihtk.Slope, Ia.0, Ia.Slope, 
#          #Kv
#          shab, shaker, shal, shaw1, shaw2,
#          kcnq1, kcnq2,
#          kcnh1, kcnh2, kcnh3,
#          #k
#          bkkca, skkca,
#          kcnt1, irk, kcnk1, kcnk2
#   ) %>% 
#   pivot_longer(cols = c(
#     #kv
#     "shab", "shaker", "shal", "shaw1", "shaw2", 
#     "kcnq1", "kcnq2",
#     "kcnh1", "kcnh2", "kcnh3", 
#     #k
#     "bkkca", "skkca", 
#     "kcnt1", "irk", "kcnk1", "kcnk2"
#   ), names_to = "mRNA", values_to = "Count") %>% 
#   pivot_longer(cols = c("Ihtk.0", 
#                         # "Ihtk.Slope", 
#                         "Ia.0"#, 
#                         # "Ia.Slope"
#                         ),
#                names_to = "Key", values_to = "Value") %>% 
#   ggplot(aes(x = Count, y = Value))+
#   geom_smooth(method = lm, se = F)+
#   geom_point()+
#   # facet_wrap(Key ~ mRNA, nrow = 4, scales = "free")
#   facet_grid(Key ~ mRNA)+
#   theme_bw()
#   
# 
# PlotList <- 
# map(c(
#   #Kv
#   "Shab", "Shaker", "Shal", "Shaw1", "Shaw2", 
#   "Kcnq1", "Kcnq2",
#   "Kcnh1", "Kcnh2", "Kcnh3", 
#   #K
#   "BkkCa", "SkkCa", 
#   "Kcnt1", "Irk", "Kcnk1", "Kcnk2"
# ), function(X){
#   map(c("Ihtk.0", 
#         # "Ihtk.Slope", 
#         "Ia.0"#, 
#         # "Ia.Slope"
#   ), function(Y){
#     ggplot(filter(M, Time == "Baseline"), aes_string(X, Y))+
#       geom_smooth(method = lm, se = F)+
#       geom_point()+
#       theme_bw()
#   })
# })
#   
# PlotList <- transpose(PlotList)  
# 
# library(cowplot)
# cowplot::plot_grid(plotlist = PlotList[[1]])
# 
# cowplot::plot_grid(plotlist = PlotList[[2]])
```





## Linear models -- what predicts ionics?
This falls under the auspices of EDA. 
```{r eval=FALSE}
KCurrent = "Ihtk.0"
mRNA = "BkkCa"

# Make outlier free version of the baseline data

M_baseline_outlier_free <- filter(M, Time == "Baseline")

for (NAME in names(M)[!(names(M) %in% c("Condition" , "Cell", "Experiment", "Source", "Pharm", "Time", "Sample"))]){
  M_baseline_outlier_free[[NAME]] <- ifelse(win_x_iqr(M_baseline_outlier_free[[NAME]]), M_baseline_outlier_free[[NAME]], NA)
}



# Which have relationships at baseline?
fm.list <- map(MeasuredKCurrents, function(KCurrent){
  map(MeasuredmRNA, function(mRNA){
    lm(as.formula(paste0(KCurrent, " ~ ", mRNA)), data = M_baseline_outlier_free)
  })
})


p.list <- map(fm.list, function(ListLvl1){
  map(ListLvl1, function(ListLvl2){
    broom::tidy(ListLvl2)[2, "p.value"] # non-intercept p
  }) %>% unlist()
})

p.df <- do.call(cbind, p.list) %>% as.data.frame()

names(p.df) <- MeasuredKCurrents
p.df$mRNA <- MeasuredmRNA





# Uncorrected
p.df.long <- p.df %>% 
  gather(iK, pValue, all_of(MeasuredKCurrents))
  # dplyr::filter(iK %in% c("Ia.0", "Ihtk.0")) %>% 
  # mutate(pAdj = p.adjust(pValue, method = "fdr")) %>% 
  
highlight.text.temp.df <- p.df.long %>% 
  mutate(highlight = ifelse(pValue <= 0.05, 1, 0)) %>% 
  select(-pValue) %>% pivot_wider(names_from = iK, values_from = highlight) %>% 
  mutate(highlight = ifelse(Ihtk.0 == 0, 
                     ifelse(Ihtk.Slope == 0,
                     ifelse(Ia.0 == 0, 
                     ifelse(Ia.Slope == 0, 
                            0, 1), 1), 1), 1) ) %>% 
  mutate(highlight = ifelse(highlight == 1, "firebrick", "black")) %>% 
  arrange(mRNA)

plt.fm <-   
p.df.long %>% 
  ggplot(aes(x = mRNA, color = pValue <= 0.05))+
  geom_hline(yintercept = 0.95, color = "gray", linetype = "dashed")+
  # geom_point()+
  # geom_rect(aes(xmin = mRNA, xmax = mRNA, ymin = 0, ymax = 1- pValue), size = 2, color = "gray", alpha = 0.0001)+
  geom_rect(aes(xmin = mRNA, xmax = mRNA, ymin = 0, ymax = 1- pValue), size = 2)+
  
  # geom_segment(aes(x = mRNA, xend = mRNA, y = 0, yend = 1- pValue), size = 2)+
  # geom_segment(aes(x = mRNA, xend = mRNA, y = 0, yend = 1- pAdj), size = 2)+
  facet_grid(iK~.)+
  scale_color_manual(values = c("black", "firebrick"))+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, color = highlight.text.temp.df[["highlight"]]),
        legend.position = "")

# Corrected with fdr
plt.fm.fdr <- 
p.df %>% 
  gather(iK, pValue, all_of(MeasuredKCurrents)) %>% 
  # dplyr::filter(iK %in% c("Ia.0", "Ihtk.0")) %>% 
  mutate(pAdj = p.adjust(pValue, method = "fdr")) %>% 
  ggplot(aes(x = mRNA, color = pAdj <= 0.05))+
  geom_hline(yintercept = 0.95, color = "gray", linetype = "dashed")+
  # geom_point()+
  geom_rect(aes(xmin = mRNA, xmax = mRNA, ymin = 0, ymax = 1- pValue), size = 2, color = "gray", alpha = 0.0001)+
  geom_rect(aes(xmin = mRNA, xmax = mRNA, ymin = 0, ymax = 1- pAdj), size = 2, color = "black")+
  
  # geom_segment(aes(x = mRNA, xend = mRNA, y = 0, yend = 1- pValue), size = 2)+
  # geom_segment(aes(x = mRNA, xend = mRNA, y = 0, yend = 1- pAdj), size = 2)+
  facet_grid(iK~.)+
  scale_color_manual(values = c("black", "firebrick"))+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
        legend.position = "")
```

## PCA what loads with ionics?
```{r eval=FALSE}
library(factoextra)
# library(missMDA) # for imputePCA 
library("FactoMineR") #PCA

MNumericOnly <- M_baseline_outlier_free
MNumericOnly <- MNumericOnly[, c(MeasuredKCurrents, MeasuredmRNA)]

ResPCA <- PCA(MNumericOnly, scale.unit = T)

get_eig(ResPCA)

fviz_screeplot(ResPCA, addlabels = T)

fviz_pca_biplot(ResPCA, repel = T)
# Ihtk.Slope, Ihtk.0, Ia.0, Ia.Slope, and Kainate1A are all loading together (roughly)

fviz_pca_var(ResPCA, 
             col.var = "contrib",
             # gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping
             )
```

## What correlates with ionics?
```{r eval=FALSE}
library(corrr)

MCorrr <- MNumericOnly %>% 
  correlate()

temp <- MCorrr %>% 
  as_tibble() %>% 
  select(rowname, Ihtk.0, Ihtk.Slope, Ia.0, Ia.Slope) %>% 
  gather(colname, Cor, c("Ihtk.0", "Ihtk.Slope", "Ia.0", "Ia.Slope")) 

# temp$rowname <- as.factor(temp$rowname) 
#TODO fix ordering


temp %>% 
  ggplot(aes(rowname, Cor, color = Cor))+
  geom_segment(aes(x = rowname, xend = rowname, y = 0, yend = Cor))+
  geom_point()+
  geom_point(shape = 1, color = "black")+
  geom_hline(yintercept = 0)+
  ylim(-1,1)+
  facet_grid(colname~.)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  scale_color_gradient2(low = RColorBrewer::brewer.pal(7, "PuOr")[1],
                         mid = RColorBrewer::brewer.pal(7, "PuOr")[4],
                         high = RColorBrewer::brewer.pal(7, "PuOr")[7],
                         midpoint = 0, 
                         na.value = "#00000000")



# 
# 
# 
# # rplot(MCorrr)
# 
# # You have to zoom or the chords don't show up. \_()_/
# # network_plot(MCorrr, min_cor = .7)
# 
# 
library(ggcorrplot)
# 
MCorr <- cor(MNumericOnly, use = "pairwise.complete.obs")

pMat <- cor_pmat(MNumericOnly)
# 
library(RColorBrewer)
# ggcorrplot(MCorr, 
#            colors = RColorBrewer::brewer.pal(7, "PuOr")[c(1, 4 ,7)]#,
#            # p.mat = pMat
#            # lab = T
#            )
# 
# # library(GGally)
# # GGally::ggscatmat(MNumericOnly)
# GGally::ggcorr(MCorr,
#        # nbreaks = 5,
#        low = RColorBrewer::brewer.pal(7, "PuOr")[1],
#                          mid = RColorBrewer::brewer.pal(7, "PuOr")[4],
#                          high = RColorBrewer::brewer.pal(7, "PuOr")[7])


library(corrplot)
corrplot(MCorr, method = "square", type = "upper", tl.col = "black", order = "hclust", col = brewer.pal(n = 9, name = "PuOr"),
         p.mat = pMat,
         sig.level = 0.01, insig = "blank")
  

```







# from untitled 2



```{r eval=FALSE}
#TODO read in ionic


```

Marginal plot
```{r eval=FALSE}
# p <- ionic %>% filter(!is.na(Ihtk.0) & !is.na(Ia.0)) %>% 
#   ggplot(aes(Ihtk.0, Ia.0, group = Condition, color = Condition))+
#   # geom_smooth(method = "lm", se = F)+
#     geom_point(size = 2)+
#     theme_minimal()+
#   theme(legend.position = "bottom")
# 
# p <- ggExtra::ggMarginal(
#   p,
#   type = 'density',
#   margins = 'both',
#   size = 5,
#   groupColour = TRUE, groupFill = TRUE
# )
# 
# ggsave(plot = p, filename = "Ionic0M.tiff", path = here("data", "figures"))
```


```{r eval=FALSE}
# p <- ionic %>% filter(!is.na(Ihtk.Slope) & !is.na(Ia.Slope)) %>% 
#   ggplot(aes(Ihtk.Slope, Ia.Slope, group = Condition, color = Condition))+
#   # geom_smooth(method = "lm", se = F)+
#     geom_point(size = 2)+
#     theme_minimal()+
#   theme(legend.position = "bottom")
# 
# p <- ggExtra::ggMarginal(
#   p,
#   type = 'density',
#   margins = 'both',
#   size = 5,
#   groupColour = TRUE, groupFill = TRUE
# )
# 
# ggsave(plot = p, filename = "IonicDM.tiff", path = here("data", "figures"))
```


```{r eval=FALSE}
# cowplot::plot_grid(plotlist = 
# map(c("Ihtk.0", "Ia.0", "Ihtk.Slope", "Ia.Slope"), function(i){
#     ggplot(ionic, aes(x = Condition, group = Condition, fill = Condition))+
#   # geom_smooth(method = "lm", se = F)+
#     geom_boxplot(aes_string(y = i), width = 0.1)+
#     ggbeeswarm::geom_beeswarm(aes_string(y = i), shape = 1)+
#     # geom_point(size = 2)+
#     stat_summary(aes_string(y = i, group = "1"), fun.y = mean, geom = "line")+
#     stat_summary(aes_string(y = i, group = "1"), fun.y = mean, geom = "point", size = 4, shape = 4)+
#     theme_minimal()+
#   theme(legend.position = "")+
#   labs(x = "", y = "", title = i)
# })
# 
# )
# 
# ggsave(plot = last_plot(), filename = "IonicDelta.tiff", path = here("data", "figures"))
```


```{r eval=FALSE}
ionic %>% 
  filter(!is.na(Cell)) %>% 
  select(-c(Ihtk.0, Ihtk.Slope)) %>%  
  distinct() %>% 
  group_by(Condition, Cell) %>% 
  tally()


ionic %>% 
  filter(!is.na(Cell)) %>% 
  select(-c(Ia.0, Ia.Slope)) %>%  
  distinct() %>% 
  group_by(Condition, Cell) %>% 
  tally()

ionic %>% 
  filter(!is.na(Cell)) %>% 
  select(-c(Ihtk.0, Ihtk.Slope)) %>%  
  distinct() %>% 
  group_by(Condition) %>% 
  tally()

ionic %>% 
  filter(!is.na(Cell)) %>% 
  select(-c(Ia.0, Ia.Slope)) %>%  
  distinct() %>% 
  group_by(Condition) %>% 
  tally()



```


### from untitled2 assumes df = brians joined data





```{r eval=FALSE}
# x %>% 
#   gather(mrna, cor, 2:ncol(.)) %>% 
#   ggplot(aes(rowname, mrna, fill = cor))+
#   geom_tile()+
#   scale_fill_gradient2(low = "Red", mid = "White", high = "Blue")
# 
# library("corrplot")
# 
# x <- as.data.frame(x)
# 
# rownames(x) <- x$rowname
# 
# corrplot::corrplot(
#   as.matrix(select(x, -rowname)), method = "color", order = "hclust", 
#   addrect = 3,
#   na.label = " "
#   )
# 
# # corrplot.mixed(as.matrix(select(x, -rowname)), upper = "color")
# 
# cowplot::plot_grid(plotlist = list(pp, pp))
# 
# # install.packages("ggcorrplot")
# library(ggcorrplot)
# 
# 
# 
# df <- df %>% mutate(Set = paste(Pharm, Condition))
# 
# 
# Sets <- unique(df$Set)
# 
# baseline <- df %>% filter(Set == "none Baseline") %>% select(-c(Set, Pharm, Condition, UID)) %>% correlate()
#   baseline <- as.data.frame(baseline)
#   rownames(baseline) <- baseline$rowname
#   baseline <- baseline %>% select(-rowname)
# 
# 
# cowplot::plot_grid(plotlist = 
# map(Sets, function(i){
#   temp <- df %>% filter(Set == i) %>% select(-c(Set, Pharm, Condition, UID)) %>% correlate()
#   temp <- as.data.frame(temp)
#   rownames(temp) <- temp$rowname
#   temp <- temp %>% select(-rowname)
#   
#   # temp <- temp-baseline
#   
#   ggcorrplot(temp)+labs(title = i)
# })
# )



```




##Attempts at visualizing correlations
```{r eval=FALSE}
# treatments <- unique(M$TREATMENT)
# mrnas <- c("CAV1", "CAV2", "SHAL", "BKKCa", "CbNaV", "Shab", "Shaker", "Shaw1", "Shaw2", "INX1", "INX2", "INX3", "INX4", "INX5")
# 
# 
# cor.list <- map(treatments, function(i){
#   temp <- M[M$TREATMENT == i, ]  
#   cor(temp[, mrnas], temp[, mrnas], use = "pairwise.complete.obs", method = "spearman")
# })
# names(cor.list) <- treatments
# 
# library("corrplot")
# walk(treatments, function(i){
#   print(i)
#   corrplot(cor.list[[i]], method = "color")
# })
# 
# 
# corrplot(cor.list$`24h-CONTROL`, method = "color")
# 
# #corrplot((cor.list$`4AP24h` - cor.list$Control), method = "color")
# 
# walk(treatments[-3], function(i){
#   print(i)
# gplots::heatmap.2((cor.list[[i]] - cor.list$`TEA-Acute`),
#   cellnote = round((cor.list[[i]] - cor.list$`TEA-Acute`), digits = 2),  # same data set for cell labels
#   #main = "Correlation", # heat map title
#   notecol="black",      # change font color of cell labels to black
#   density.info="none",  # turns off density plot inside color legend
#   trace="none",         # turns off trace lines inside the heat map
#   #margins =c(12,9),     # widens margins around plot
#   #col=my_palette,       # use on color palette defined earlier
#   #breaks=col_breaks,    # enable color transition at specified limits
#   dendrogram="none",     # only draw a row dendrogram
#   Colv="NA")            # turn off column clustering
# })
# 
# library("PerformanceAnalytics")
# chart.Correlation(temp[, mrnas], histogram=TRUE, pch=19)
```


### vis with line plot?
```{r eval=FALSE}
# N <- M[1, !(names(M) %in% c("CELL", "Pharm", "Time"))]
# N$cor <- ""
# 
# walk(1:length(cor.list), function(i){
#   temp <- as.data.frame(cor.list[[i]])
#   temp$cor <- rownames(temp)
#   temp$TREATMENT <- treatments[i]
#   N <<- full_join(N, temp) 
# })
# N <- N[-1, ]
# #N <- gather(N, )
```

```{r eval=FALSE}
# ggplot(N, aes(x = TREATMENT, y = CAV1, color = cor, group = cor))+
#   geom_point()+
#   geom_line()
```





###



# Deep dive on the effects of TEA
## Electrophysiology

## Molecular bio

## Merging and processing

### Quality control and outlier analysis

### Characterizing the baselinem

### 
### Compare Brian's and My molecular data



## What structure is there in the dataset?


## What correspondence between ephys ~ mRNA is there?

## How can we extend this to the data Brian Collected?
